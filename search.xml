<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Benthos 框架下的限速器降级方案探索</title>
    <url>/2025/05/20250508.html</url>
    <content><![CDATA[<h1 id="Benthos-框架下的限速器降级方案探索"><a href="#Benthos-框架下的限速器降级方案探索" class="headerlink" title="Benthos 框架下的限速器降级方案探索"></a>Benthos 框架下的限速器降级方案探索</h1><h2 id="rate-limit限速器"><a href="#rate-limit限速器" class="headerlink" title="rate_limit限速器"></a><code>rate_limit</code>限速器</h2><p>用于限制Benthos中并行组件(或跨实例)之间的共享资源使用, 一般使用<code>resources</code>配置, 如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rate_limit_resources:</span>  <span class="comment"># 固有字段, 表示限速器的资源</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">my_limite</span> <span class="comment"># 限速器资源标签</span></span><br><span class="line">    <span class="attr">local:</span> <span class="comment"># 本地限速器, 只能在单个实例内部生效</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">500</span>  <span class="comment"># 表示每秒500次处理</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure>
<p>一些内部组件支持直接在配置中带上<code>rate_limit</code>配置, 例如<code>http_client</code>, 其原理是在组件内部通过<code>*service.Resources</code>的<code>AccessRateLimit</code>方法直接获取对应资源</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">http_client:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">TODO</span></span><br><span class="line">    <span class="attr">verb:</span> <span class="string">GET</span></span><br><span class="line">    <span class="attr">rate_limit:</span> <span class="string">my_limite</span></span><br></pre></td></tr></table></figure>
<p>通过这种方式使用速率限制，可以保证输入仅以每秒 500 个请求的速率轮询 HTTP 源, 其内部实现大致如下</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">    service.RegisterBatchInput(<span class="string">"http_client"</span>, httpClientInputSpec(), newHttpClient)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpClientInputSpec</span><span class="params">()</span></span> *service.ConfigSpec {</span><br><span class="line">    <span class="comment">// 给出一个接受 rate_limit 配置的字段</span></span><br><span class="line">    <span class="keyword">return</span> service.NewConfigSpec().service.NewStringField(<span class="string">"rate_limit"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHtpClient</span><span class="params">(conf *service.ParsedConfig, mgr *service.Resources)</span></span> (*httpClientInput, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// 拿到限速器的标签</span></span><br><span class="line">    rate_limit, _ := conf.FieldString(<span class="string">"rate_time"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否在 rate_limit_resources 中注册对应标签的限速器</span></span><br><span class="line">    <span class="keyword">if</span> rate_limit != <span class="string">""</span> {</span><br><span class="line">        <span class="keyword">if</span> !mgr.HasRateLimit(rate_limit) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"rate_limit resources %v not found"</span>, rate_limit)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这里是发送HTTP请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpClient)</span></span> Send(ctx context.Content) ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> !h.waitForAccess(ctx) {</span><br><span class="line">        <span class="keyword">if</span> ctx.Err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errTimeout</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正调用限速器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpClient)</span></span> waitForAccess(ctx) <span class="type">bool</span> {</span><br><span class="line">    <span class="keyword">if</span> h.rateLimit == <span class="string">""</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">var</span> period time.Duration</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">        <span class="comment">// 获取限速器实例</span></span><br><span class="line">		<span class="keyword">if</span> rerr := h.mgr.AccessRateLimit(ctx, h.rateLimit, <span class="function"><span class="keyword">func</span><span class="params">(rl service.RateLimit)</span></span> {</span><br><span class="line">			period, err = rl.Access(ctx)</span><br><span class="line">		}); rerr != <span class="literal">nil</span> {</span><br><span class="line">			err = rerr</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			h.log.Errorf(<span class="string">"Rate limit error: %v\n"</span>, err)</span><br><span class="line">			period = time.Second</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> period &gt; <span class="number">0</span> { <span class="comment">// 等待一定时间</span></span><br><span class="line">			<span class="keyword">select</span> {</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(period):</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果组件内本身不提供<code>rate_limit</code>, 或不想在组件内写上这个配置并在初始化的时候使用, 可以通过使用<code>processor</code>结合限速器, 利用背压机制, 即下游阻塞上游也阻塞, 配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">csv:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./foo.csv</span></span><br><span class="line">  <span class="attr">processors:</span> <span class="comment"># 在Input组件csv之后紧接着一个 rate_limit 处理器, 利用背压机制间接限速 input</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">        <span class="attr">resource:</span> <span class="string">my_limit</span></span><br></pre></td></tr></table></figure>
<hr>
<p>以上所有限速器均为本地实现, 无法跨实例使用, 如果有次需求需要使用<code>Redis</code>或其他方案做限速器, 例如基于<code>Benthos</code>的<code>connect</code>的实现 <a href="https://github.com/redpanda-data/connect/blob/main/internal/impl/redis/rate_limit.go">https://github.com/redpanda-data/connect/blob/main/internal/impl/redis/rate_limit.go</a>, 不过需要注意其限速器只是限制速率, 功能上类似漏桶, 如果需要控制QPS需要另行实现令牌桶版本的限速器</p>
<h2 id="如何动态调整限速器的限速值"><a href="#如何动态调整限速器的限速值" class="headerlink" title="如何动态调整限速器的限速值"></a>如何动态调整限速器的限速值</h2><p>一个基本的限速器配置如下(框架原生)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rate_limit_resources:</span>  <span class="comment"># 固有字段, 表示限速器的资源</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">my_limite</span> <span class="comment"># 限速器资源标签</span></span><br><span class="line">    <span class="attr">local:</span> <span class="comment"># 本地限速器, 只能在单个实例内部生效</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">500</span>  <span class="comment"># 一下表示每秒500次处理</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure>
<p>如果想要动态的修改其中的 <code>count</code>字段, 可以考虑一下方法</p>
<ol>
<li><p>使用配置热重载的方式</p>
<p> 启动<code>Benthos</code>二进制时为框架加上 <code>-w</code> 或 <code>--watcher</code>, 让其可以在配置文件发生变化的时候自动重载配置, 使用此种方式时, 将会全量读取新的配置文件, 并且等待所有未确认消息处理完毕并确认后, 重新载入配置并重载组件. <strong>但是需要注意, 如果更新配置文件后存在配置错误将会导致Benthos服务不可用, 其将会持续读取配置文件并解析配置错误, 并不会沿用原有配置文件</strong></p>
</li>
<li><p>使用流模式 <code>streams</code> 启动, 通过 HTTP 动态修改配置</p>
<p> 配置中设置好api的端口, 或使用默认端口 <code>4195</code></p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span> <span class="comment"># 为benthos开启一个HTTP服务, 包含一些基础的请求访问, 例如 /ping /ready /version三个api, 可以通过访问/endpoints获取所有api</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:4195</span></span><br><span class="line">  <span class="attr">debug_endpoints:</span> <span class="literal">false</span> <span class="comment"># 是否开启debug模式</span></span><br></pre></td></tr></table></figure>
<p> 使用流模式启动</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./BenthosApp streams ./streams_config/*.yaml</span><br></pre></td></tr></table></figure>
<p> 获取所有流</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:4195/streams <span class="comment"># 获取所有流, 一个配置文件为一个流</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新指定流的配置, 需要传入完整的配置</span></span><br><span class="line">curl -X PUT http://localhost:4195/streams/one_stream --data-binary @- &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">input:</span></span><br><span class="line"><span class="string">	xxx</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">	xxx</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看流的配置</span></span><br><span class="line">curl http://localhost:4195/streams/one_stream</span><br><span class="line"><span class="comment"># 修正指定流的配置</span></span><br><span class="line">curl -X PATCH http://localhost:4195/streams/one_stream \</span><br><span class="line">  --data-binary @- &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">  "input": {</span></span><br><span class="line"><span class="string">    "my_input": {</span></span><br><span class="line"><span class="string">      "timeout": "92s"</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p> 以上方法, 均是通过修改配置的方式执行, 也就是说如果想要实现降级, <strong>需要配合外部监控平台</strong>, 通过监控pod状态或一些指标, 来<strong>从外部对Benthos的限速器进行修改</strong>, 那是否可能存在一种方法可以在运行时在程序内部自行修改呢?</p>
<p> 通过查阅Benthos相关文档可以得知, 当组件作为资源被引用时, 具备可重用性, 每种命名资源只会创建一个实例, 可以在多个位置使用, 原文如下 <a href="https://docs.redpanda.com/redpanda-connect/configuration/resources/">https://docs.redpanda.com/redpanda-connect/configuration/resources/</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Resources <span class="keyword">are</span> components <span class="keyword">within</span> Redpanda <span class="keyword">Connect</span> that <span class="keyword">are</span> declared <span class="keyword">with</span> a <span class="keyword">unique</span> label <span class="keyword">and</span> can be referenced <span class="keyword">any</span> number <span class="keyword">of</span> times <span class="keyword">within</span> a configuration. <span class="keyword">Only</span> <span class="keyword">one</span> instance <span class="keyword">of</span> <span class="keyword">each</span> named resource <span class="keyword">is</span> created, but it <span class="keyword">is</span> safe <span class="keyword">to</span> use it <span class="keyword">in</span> multiple places <span class="keyword">as</span> they can be shared <span class="keyword">without</span> consequence.</span><br><span class="line">资源是 Redpanda <span class="keyword">Connect</span> 中的组件，它们使用唯一标签声明，并且可以在配置中引用任意次数。每个命名资源只会创建一个实例，但可以安全地在多个位置使用，因为它们可以共享而不会产生任何后果。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Some</span> components such <span class="keyword">as</span> caches <span class="keyword">and</span> rate limits can <span class="keyword">only</span> be created <span class="keyword">as</span> a resource. </span><br><span class="line">某些组件，如缓存和速率限制，只能作为资源创建。</span><br></pre></td></tr></table></figure>
<p> 以上说明可以简单的通过编写一个Benthos框架的代码验证</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">inputs:</span> <span class="comment"># 使用 broker 包裹两个完全一致的输入, 使用同一个标签的限速器 </span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">rdb_input:</span> {}</span><br><span class="line">        <span class="attr">processors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span> <span class="comment"># 给每条消息加上来源和当前时间</span></span><br><span class="line">              <span class="string">root.message</span> <span class="string">=</span> <span class="string">this.string()</span></span><br><span class="line">              <span class="string">root.source</span> <span class="string">=</span> <span class="string">"input_11111"</span></span><br><span class="line">              <span class="string">root.meta.process_time</span> <span class="string">=</span> <span class="string">now()</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">rdb_input:</span> {}</span><br><span class="line">        <span class="attr">processors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              root.message = this.string()</span></span><br><span class="line"><span class="string">              root.source = "input_22222"</span></span><br><span class="line"><span class="string">              root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="comment"># 自定义了一个 mu_local_limiter, 实现完全与框架原生的一致, 但是在初始化阶段打印了一个日志</span></span><br><span class="line"><span class="attr">rate_limit_resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">    <span class="attr">mut_rate_limit_local:</span>  <span class="comment"># 限速为每秒一条</span></span><br><span class="line">      <span class="attr">maxcount:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>input</code> 组件为简单的从Redis中<code>RPop</code>内容, 大致如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rdbInput)</span></span> Read(ctx context.Context) (*service.Message, service.AckFunc, <span class="type">error</span>) {</span><br><span class="line">	<span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接没有考虑Redis为空的情况, 在程序启动前给Redis提前填充了数据</span></span><br><span class="line">	d, err := r.l.Pop(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	msg := service.NewMessage(d)</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>限速器组件实现大致如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">	err := service.RegisterRateLimit(<span class="string">"mut_rate_limit_local"</span>,</span><br><span class="line">		limiterConfig(), newMutRateLimitLocal)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMutRateLimitLocal</span><span class="params">(conf *service.ParsedConfig, mgr *service.Resources)</span></span> (service.RateLimit, <span class="type">error</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    limiter := &amp;my_limit{</span><br><span class="line">        log: mgr.Logger(),</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这里输出一下日志</span></span><br><span class="line">	limiter.log.Infof(<span class="string">"I am Init !!!!!!"</span>)</span><br><span class="line">	<span class="keyword">return</span> limiter, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>主程序启动前提前填充redis</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	l := lists.GetLists()</span><br><span class="line">	<span class="comment">// 按顺序填充 1-100</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">		_ = l.Push(context.Background(), []<span class="type">byte</span>(strconv.Itoa(i)))</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	service.RunCLI(context.Background())</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>程序启动后观察日志输出如下</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"benthos_version"</span>:<span class="string">"v4.48.0"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Running main config from specified file"</span>,<span class="string">"path"</span>:<span class="string">"config.yaml"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"mu_local_limiter"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"I am Init !!!!!!"</span>,<span class="string">"path"</span>:<span class="string">"root.rate_limit_resources"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Listening for HTTP requests at: http://0.0.0.0:4195"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Input type rdb_input is now active"</span>,<span class="string">"path"</span>:<span class="string">"root.input.broker.inputs.0"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Input type rdb_input is now active"</span>,<span class="string">"path"</span>:<span class="string">"root.input.broker.inputs.1"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Output type stdout is now active"</span>,<span class="string">"path"</span>:<span class="string">"root.output"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Launching a Benthos instance, use CTRL+C to close"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"1"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:51.181221041+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"3"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:52.181650517+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"4"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:53.181898361+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"0"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:54.18314283+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_22222"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"5"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:55.183107806+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"6"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:56.183515111+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"2"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:57.183863343+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_22222"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"7"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:58.184574384+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_22222"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"8"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:59.18518018+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br></pre></td></tr></table></figure>
<p>可以得出以下现象:</p>
<ol>
<li>根据消息的乱序输出, 且来源都不一致, 说明两个<code>input</code>在同时工作</li>
<li>在乱序的情况下, 消息保持每秒一条的速率</li>
<li><p><code>rate_limit</code>组件的<code>I am Init !!!!!!</code> 日志仅输出了一次</p>
<p>由此说明<code>rate_limit</code>组件作为资源加载时, <strong>全局单例</strong>, 根据这个特性, 可以设计出一个速率可变的限速器, 其应该继承框架原本的<code>rate_limit</code>方法, 同时额外暴露一些修改限速值的方法, 包内直接单例模式, 例如</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gLimit mutRateLimitLocal</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mutRateLimitLocal <span class="keyword">struct</span> {</span><br><span class="line">	log         *service.Logger</span><br><span class="line">	mut         sync.Mutex</span><br><span class="line">	curSize     <span class="type">int</span></span><br><span class="line">	lastRefresh time.Time</span><br><span class="line"></span><br><span class="line">	minSize   <span class="type">int</span></span><br><span class="line">	benchSize <span class="type">int</span></span><br><span class="line">	maxSize   <span class="type">int</span></span><br><span class="line">	period    time.Duration</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 Benthos 的 RateLimit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mutRateLimitLocal)</span></span> Access(ctx context.Context) (time.Duration, <span class="type">error</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 Benthos 的 RateLimit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mutRateLimitLocal)</span></span> Close(_ context.Context) <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加限速值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upgrade</span><span class="params">()</span></span> {</span><br><span class="line">	gLimit.mut.Lock()</span><br><span class="line">	<span class="keyword">defer</span> gLimit.mut.Unlock()</span><br><span class="line"></span><br><span class="line">	ori := gLimit.benchSize</span><br><span class="line">	gLimit.benchSize *= <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> gLimit.benchSize &gt; gLimit.maxSize {</span><br><span class="line">		gLimit.benchSize = gLimit.maxSize</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	gLimit.log.Infof(<span class="string">"limiter upgrade from %d to %d"</span>, ori, gLimit.benchSize)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降低限速值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DownGrade</span><span class="params">()</span></span> {</span><br><span class="line">	gLimit.mut.Lock()</span><br><span class="line">	<span class="keyword">defer</span> gLimit.mut.Unlock()</span><br><span class="line"></span><br><span class="line">	ori := gLimit.benchSize</span><br><span class="line">	gLimit.benchSize /= <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> gLimit.benchSize &lt; gLimit.minSize {</span><br><span class="line">		gLimit.benchSize = gLimit.minSize</span><br><span class="line">	}</span><br><span class="line">	gLimit.log.Infof(<span class="string">"limiter downGrade from %d to %d"</span>, ori, gLimit.benchSize)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>现在进行验证, 将<code>input</code>组件修改为单个组件, 保证数据的顺序性, 并在读取到特定内容时进行升级降级操作, 并观察输出, 代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rdbInput)</span></span> Read(ctx context.Context) (*service.Message, service.AckFunc, <span class="type">error</span>) {</span><br><span class="line">	<span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	d, err := r.l.Pop(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">string</span>(d) == <span class="string">"5"</span> {</span><br><span class="line">		mut_rate_limit_local.Upgrade()</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">string</span>(d) == <span class="string">"10"</span> {</span><br><span class="line">		mut_rate_limit_local.DownGrade()</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	msg := service.NewMessage(d)</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>input</code>组件相关配置修改为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">        <span class="attr">resource:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br></pre></td></tr></table></figure>
<p>由于数据是顺序输出的, 所以一定会先出现5, 后出现10, 此时启动程序观察输出为</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">{<span class="string">"message"</span>:<span class="string">"1"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:49.100212661+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"2"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:49.100586456+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"3"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:50.096771614+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"4"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:50.096806286+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"mu_local_limiter"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limiter upgrade from 2 to 4"</span>,<span class="string">"path"</span>:<span class="string">"root.rate_limit_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"5"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.097508536+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"6"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.097554408+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"7"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.097980122+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"8"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.098075563+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"mu_local_limiter"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limiter downGrade from 4 to 2"</span>,<span class="string">"path"</span>:<span class="string">"root.rate_limit_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"9"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:52.098415253+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"10"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:52.09846423+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"11"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:53.09906257+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"12"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:53.099122656+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"13"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:54.099771808+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"14"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:54.099812208+08:00"</span>}}</span><br></pre></td></tr></table></figure>
<p>可以观察到当读取到5之后, 限速从2升级为4, 消息速率有每秒两条变为每秒四条, 读取到10的时候降级为2, 此后维持2的限速运行.</p>
<h2 id="背压机制对消息处理速率的影响"><a href="#背压机制对消息处理速率的影响" class="headerlink" title="背压机制对消息处理速率的影响"></a>背压机制对消息处理速率的影响</h2><p>在Benthos中, 限速器组件能够限速的本质原理是, 通过一个给定的时间间隔, 以及在此时间间隔内, <code>Input</code>组件调用<code>Read</code>或<code>ReadBatch</code>(如果是<code>batchInput</code>)的次数, 来限制整体速率, 例如以下限速器配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rate_limit_resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">local_limiter</span></span><br><span class="line">    <span class="attr">local:</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure>
<p>表示限制每秒调用1次<code>Input</code>组件的<code>Read</code>方法或<code>ReadBatch</code>, 其原理是当调用次数超过一次后, 下次调用将会强制等待到大于给定等待时间间隔为止., 本质上其是依赖<code>Benthos</code>的背压机制来达到对消息进行限速的目的, 那如何验证这一机制? 可以简单的写一段Benthos配置来对其进行验证</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span> </span><br><span class="line">  	<span class="attr">max_in_flight:</span> <span class="number">0</span> <span class="comment"># 表示不限制待确认消息的数量</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">1</span>  <span class="comment"># 保持每次只处理一个数据</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sleep:</span> <span class="comment"># 任何类型消息在这里将会 sleep 一秒钟</span></span><br><span class="line">        <span class="attr">duration:</span> <span class="string">1s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">my_stdout:</span> {}</span><br></pre></td></tr></table></figure>
<p>以上配置下, Benthos的输出为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:12.227711335+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:12.22788404+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:13.22813145+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"4"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:14.228667279+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"5"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:15.229376735+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"6"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:16.229656828+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"7"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:17.230157291+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"8"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:18.230574692+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>可以观察到, 从第二条消息开始, 每条消息间隔了一秒钟才被取出来, 那如果将 <code>pipeline.threads</code> 参数变大, 则能代表每秒可以取出来更多消息, 这些消息等待一秒后, 才能取出来下一批消息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">5</span>  <span class="comment"># 每次同時处理5个数据</span></span><br></pre></td></tr></table></figure>
<p>修改后输出同理论一致, 第一秒取出了六条数据, 在第六条数据进入<code>processor</code>阶段时, 前五条数据都在sleep中, 整条链路被阻塞了, 直到下一秒, 前五条消息处理完毕后, 继续处理下五条</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214659776+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214329751+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214761512+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"4"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214990298+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"5"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.215094723+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"6"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.215260697+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"7"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.214789636+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"8"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215151017+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"9"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215217328+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"10"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215294076+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"15"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215655737+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"11"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215366317+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"12"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215124804+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"13"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215432139+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"14"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215565551+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"20"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216655332+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"19"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216587464+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"18"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216449435+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"17"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216183862+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"16"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215772375+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>那这与<code>Input</code>组件的<code>max_in_flight</code>参数有什么关系? <strong>在<code>Input</code>组件中 <code>max_in_flight</code> 参数表示系统可接受的未确认消息的数量</strong>, 可以简单比喻成一个萝卜一个坑, 每次调用<code>Read</code>或<code>ReadBatch</code>都会得到一根萝卜, <code>max_in_flight</code> 表示有多少个坑, 当坑里的萝卜没有被拔出来时(消息未被确认), 无法把新的萝卜放进去, 可以通过以下方式简单验证</p>
<p>保持<code>pipeline.threads</code>不变, 修改<code>Input</code>组件的<code>max_in_flight</code>为1, 表示只接受一个未确认的消息, 配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sleep:</span></span><br><span class="line">        <span class="attr">duration:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure>
<p>此时输出将会是每秒钟一条消息, 因为只能接受一条未确认消息, 而每条消息又会等待1秒钟</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:40.014691582+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:41.015494086+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:42.016571178+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"4"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:43.017364452+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"5"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:44.017900917+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"6"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:45.018384+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"7"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:46.019051633+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>同样的, <code>output</code>组件如果出现阻塞, 也会由于背压机制影响到上游的处理效率, 例如以下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sleep:</span></span><br><span class="line">        <span class="attr">duration:</span> <span class="string">1s</span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">my_stdout_batch:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">batching:</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">100</span>        <span class="comment"># 当收集到100条消息时处理批次</span></span><br><span class="line">      <span class="attr">byte_size:</span> <span class="number">1048576</span> <span class="comment"># 或当批次大小达到1MB时处理</span></span><br><span class="line">      <span class="attr">period:</span> <span class="string">"1s"</span>      <span class="comment"># 或每秒至少处理一次批次</span></span><br><span class="line">      <span class="attr">check:</span> <span class="string">""</span>         <span class="comment"># 可选的条件检查</span></span><br><span class="line">      <span class="attr">processors:</span> []    <span class="comment"># 可选的批次处理器</span></span><br></pre></td></tr></table></figure>
<p>由于<code>output</code>组件存在<code>1s</code>的超时, 所以整个链路将会变为两每秒钟一条消息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T16:04:43.781875208+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T16:04:45.782621816+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T16:04:47.783167403+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="max-in-flight参数在-Input组件和output组件中的差异"><a href="#max-in-flight参数在-Input组件和output组件中的差异" class="headerlink" title="max_in_flight参数在 Input组件和output组件中的差异"></a><code>max_in_flight</code>参数在 <code>Input</code>组件和<code>output</code>组件中的差异</h4><h5 id="输入-Input-组件中的max-in-flight"><a href="#输入-Input-组件中的max-in-flight" class="headerlink" title="输入(Input)组件中的max_in_flight"></a>输入(Input)组件中的<code>max_in_flight</code></h5><p>在输入组件中，<code>max_in_flight</code>参数：</p>
<ul>
<li>设置一个限制，控制在任何给定时间内可以在Benthos流中流动的待确认消息数量</li>
<li>默认值为<code>0</code>，表示没有限制</li>
<li>一旦消息被确认(acknowledged)或拒绝(nacked)，它就不再被视为待处理</li>
<li>如果输入产生逻辑批次，则每个批次被视为对最大值的单次计数, 即限制的是<code>Read</code>和<code>ReadBatch</code>的调用次数而并非具体几条消息</li>
<li>警告：如果此字段限制的消息数量低于输出级别的批处理阈值，则输出级别的批处理策略将会停滞</li>
</ul>
<h5 id="输出-Output-组件中的max-in-flight"><a href="#输出-Output-组件中的max-in-flight" class="headerlink" title="输出(Output)组件中的max_in_flight"></a>输出(Output)组件中的<code>max_in_flight</code></h5><p>在输出组件中，<code>max_in_flight</code>参数：</p>
<ul>
<li>控制在给定时间内可以有多少消息或消息批次同时处理</li>
<li>增加此值可以提高吞吐量</li>
</ul>
</blockquote>
<h2 id="利用背压机制制作限速器"><a href="#利用背压机制制作限速器" class="headerlink" title="利用背压机制制作限速器"></a>利用背压机制制作限速器</h2><p>在上面的探索中, 已经大致搞清了Benthos框架原生的限速器的工作原理, 即利用框架的背压机制, 在下游制造压力, 传导到上游进而限制上游消息的读取速率, 根据这一原理, 可以实现这样一个<code>processor</code>组件:</p>
<ol>
<li>不处理消息, 将消息原样返回</li>
<li>记录消息个数或<code>Input</code>组件调用次数</li>
<li>如果大于指定速率, 就<code>sleep</code>, 将压力传导至上游<code>Input</code>组件</li>
<li>监测一些指标, 当达到某些条件时降低限速, 反之提高限速</li>
</ol>
<p>而这个组件可以放在</p>
<ol>
<li>紧跟着<code>Input</code>组件之后, 可以通过消息数, <code>Read</code>或<code>ReadBatch</code>的调用数, 系统的CPU占用/内存占用等不依赖具体消息内容的指标来进行降级升级</li>
<li>放在<code>Processor</code>组件的末端或中端, 可以通过消息设置的<code>meta</code>信息中处理耗时, 失败次数等与消息内容相关的指标进行升降级</li>
<li>同时放在<code>Input</code>和<code>Processor</code>中, 对多个指标进行监测</li>
</ol>
<p>而为了保证限速器的可重用性, 最好是将其放在<code>resources</code>中, 通过 <code>label</code>在需要使用的地方引用, 同时通过这种方式也可以保证限速器全局唯一, 如果需要多个限速器, 则创建多个<code>label</code>即可, 限速器应该使用<code>Processor</code>实现而非<code>batchProcessor</code>来确保其对消息限速的粒度为单条消息</p>
<blockquote>
<p>Benthos框架在batch组件和非batch组件会自动转换, 例如当<code>Input</code>是batch, <code>Processor</code>为非batch的时候, 此时<code>Input</code>每次都会读取一批消息, 一条一条的交给<code>Processor</code>, 直到所有消息都处理完毕, <code>Input</code>才会读取下一批消息, 所以使用非batch的<code>Processor</code>可以更好的控制单条消息速率</p>
</blockquote>
<h3 id="Example-利用背压机制结合对消息或CPU的监控制作的动态限速器"><a href="#Example-利用背压机制结合对消息或CPU的监控制作的动态限速器" class="headerlink" title="Example: 利用背压机制结合对消息或CPU的监控制作的动态限速器"></a>Example: 利用背压机制结合对消息或CPU的监控制作的动态限速器</h3><p>利用背压机制, 结合 <code>golang.org/x/time/rate</code> 制作一个基于令牌桶的限速器, 通过监测过去一段时间内的消息中特定错误出现频率或CPU使用率动态调节限速值</p>
<blockquote>
<p>选择<code>golang.org/x/time/rate</code>有一个比较重要的原因是其支持运行中修改限速值</p>
</blockquote>
<p>结构定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"benthos_test/lib/consts/errorx"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"github.com/pkg/errors"</span></span><br><span class="line">	<span class="string">"github.com/redpanda-data/benthos/v4/public/service"</span></span><br><span class="line">	<span class="string">"golang.org/x/time/rate"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	limitProcess <span class="keyword">struct</span> {</span><br><span class="line">		log     *service.Logger</span><br><span class="line">		limit   *rate.Limiter</span><br><span class="line">		minEach rate.Limit</span><br><span class="line">		maxEach rate.Limit</span><br><span class="line"></span><br><span class="line">		wg           sync.WaitGroup</span><br><span class="line">		shutdownChan <span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">		cpuC         *cpuChecker</span><br><span class="line">		msgC         *msgChecker</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cpuChecker <span class="keyword">struct</span> {</span><br><span class="line">		checkInterval time.Duration</span><br><span class="line">		cpuMax        <span class="type">float64</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	msgChecker <span class="keyword">struct</span> {</span><br><span class="line">		checkInterval time.Duration</span><br><span class="line">		failureMax    <span class="type">float64</span></span><br><span class="line">		sucCnt        atomic.Int32</span><br><span class="line">		falCnt        atomic.Int32</span><br><span class="line">	}</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在Benthos中注册时使用如下配置配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">limit_process:</span></span><br><span class="line">  <span class="attr">minEach:</span> <span class="number">1</span> <span class="comment"># 最低速率, 每秒钟 1 调小</span></span><br><span class="line">  <span class="attr">each:</span> <span class="number">2</span> <span class="comment"># 初始速率</span></span><br><span class="line">  <span class="attr">maxEach:</span> <span class="number">10</span> <span class="comment"># 最大速率</span></span><br><span class="line">  <span class="attr">capacity:</span> <span class="number">1</span> <span class="comment"># 令牌桶容量, 默认为 1 即可</span></span><br><span class="line">  <span class="attr">msgChecker:</span> <span class="comment"># 启用消息检查</span></span><br><span class="line">    <span class="attr">checkInterval:</span> <span class="string">5s</span> <span class="comment"># 每5s检查一次</span></span><br><span class="line">    <span class="attr">failureMax:</span> <span class="number">0.1</span> <span class="comment"># 允许的消息出现特定错误频率为10%, 超过则需要降级, 反之升级</span></span><br><span class="line">    <span class="attr">specialErr:</span> <span class="string">"xxx"</span> <span class="comment"># 这里可以在加个这个配置, 可以识别指定错误</span></span><br><span class="line"><span class="string">func</span> <span class="string">limitProcessConf()</span> <span class="string">*service.ConfigSpec</span> {</span><br><span class="line">	<span class="string">res</span> <span class="string">:=</span> <span class="string">service.NewConfigSpec()</span></span><br><span class="line">	<span class="string">res.Stable().Summary("limit</span> <span class="string">processor")</span></span><br><span class="line">	<span class="string">res.Fields(</span></span><br><span class="line">		<span class="string">service.NewFloatField("each")</span>,</span><br><span class="line">		<span class="string">service.NewFloatField("minEach").Optional()</span>,</span><br><span class="line">		<span class="string">service.NewFloatField("maxEach").Optional()</span>,</span><br><span class="line">		<span class="string">service.NewIntField("capacity")</span>,</span><br><span class="line">		<span class="string">service.NewObjectField("cpuChecker"</span>,</span><br><span class="line">			<span class="string">service.NewDurationField("checkInterval")</span>,</span><br><span class="line">			<span class="string">service.NewFloatField("cpuMax")</span>,</span><br><span class="line">		<span class="string">).Optional()</span>,</span><br><span class="line">		<span class="string">service.NewObjectField("msgChecker"</span>,</span><br><span class="line">			<span class="string">service.NewDurationField("checkInterval")</span>,</span><br><span class="line">			<span class="string">service.NewFloatField("failureMax")</span>,</span><br><span class="line">		<span class="string">).Optional()</span>,</span><br><span class="line">	<span class="string">)</span></span><br><span class="line">	<span class="string">return</span> <span class="string">res</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>构造Processor</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLimitProcess</span><span class="params">(conf *service.ParsedConfig, mgr *service.Resources)</span></span> (service.Processor, <span class="type">error</span>) {</span><br><span class="line"> 	<span class="comment">// ... 读取配置</span></span><br><span class="line">	res := &amp;limitProcess{</span><br><span class="line">		<span class="comment">// ... 初始化</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心机制: 启动监测器</span></span><br><span class="line">	res.checkerStart()</span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在处理消息时, 记录消息错误, 并从令牌桶中请求令牌</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> Process(ctx context.Context, message *service.Message) (service.MessageBatch, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// 记录消息中的错误</span></span><br><span class="line">	l.recordMsg(message.GetError())</span><br><span class="line">	err := l.limit.Wait(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		l.log.Errorf(<span class="string">"limit process wait error, msg %v"</span>, err)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> service.MessageBatch{message}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> recordMsg(err <span class="type">error</span>) {</span><br><span class="line">	<span class="keyword">if</span> l.msgC == <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用了一个特定的错误, 例如 ErrGptLimit, 也可以添加配置在配置中设置, 再通过检查错误来记录</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; errors.Is(err, errorx.ErrGptLimit) {</span><br><span class="line">		l.msgC.falCnt.Add(<span class="number">1</span>)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		l.msgC.sucCnt.Add(<span class="number">1</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在启动的监测器中, 定时监测状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> cpuCheckerLoop() {</span><br><span class="line">	<span class="keyword">defer</span> l.wg.Done()</span><br><span class="line">	<span class="comment">// 检查CPU使用率的代码...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> msgCheckerLoop() {</span><br><span class="line">	<span class="keyword">defer</span> l.wg.Done()</span><br><span class="line">	tc := time.NewTicker(l.msgC.checkInterval)</span><br><span class="line">	<span class="keyword">defer</span> tc.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="keyword">case</span> &lt;-l.shutdownChan:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-tc.C:</span><br><span class="line">			sucCnt := l.msgC.sucCnt.Swap(<span class="number">0</span>)</span><br><span class="line">			falCnt := l.msgC.falCnt.Swap(<span class="number">0</span>)</span><br><span class="line">			allCnt := sucCnt + falCnt</span><br><span class="line">			<span class="keyword">if</span> allCnt == <span class="number">0</span> {</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			failRate := <span class="type">float64</span>(falCnt) / <span class="type">float64</span>(allCnt)</span><br><span class="line">			<span class="keyword">if</span> failRate &gt; l.msgC.failureMax { <span class="comment">// 超过给定频率就降级</span></span><br><span class="line">				l.downgrade()</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				l.upgrade() <span class="comment">// 反之升级</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>最后在Benthos中使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.get_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">error_process_re</span> <span class="comment"># 这个插件经过调整, 会对前20条消息抛出错误 ErrGPTLimit</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">limit_process_re</span> <span class="comment"># 接近着会产生特定错误的组件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root = this</span></span><br><span class="line"><span class="string">        root.meta.processed = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">my_stdout:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">100</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">processor_resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">limit_process_re</span></span><br><span class="line">    <span class="attr">limit_process:</span></span><br><span class="line">      <span class="attr">minEach:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">each:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">maxEach:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">capacity:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">msgChecker:</span></span><br><span class="line">        <span class="attr">checkInterval:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">failureMax:</span> <span class="number">0.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">error_process_re</span></span><br><span class="line">    <span class="attr">error_process:</span> {}</span><br></pre></td></tr></table></figure>
<p>最终达成的效果是, 在前期会进行降级, 后期升级, 直到到达最大限制</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"error"</span>,<span class="string">"msg"</span>:<span class="string">"Failed to send message to my_stdout: gpt returns code 429"</span>,<span class="string">"path"</span>:<span class="string">"root.output"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor downgrade, each from 2.000 to 1.000, minEach 1.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"error"</span>,<span class="string">"msg"</span>:<span class="string">"Failed to send message to my_stdout: gpt returns code 429"</span>,<span class="string">"path"</span>:<span class="string">"root.output"</span>}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"24"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:21.266977435+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:21.267019259+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"25"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:22.266920475+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:22.266979673+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor upgrade, each from 1.000 to 2.000, maxEach 10.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"55"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:33.766272232+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:33.766325021+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor upgrade, each from 4.000 to 8.000, maxEach 10.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"56"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:34.016153723+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:34.016195951+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"57"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:34.265191395+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:34.265236555+08:00"</span>}}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"95"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:39.015952884+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:39.016003045+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor upgrade, each from 8.000 to 10.000, maxEach 10.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"96"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:39.141389556+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:39.141453408+08:00"</span>}}</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>利用Benthos本身背压机制所制作的限速器, 较为灵活, 适用性强, 可以放在处理链路中的任意环节, 通过对其上游施加压力达到限速效果, 但是需要注意以下几点</p>
<ol>
<li>限速逻辑需要可以支持运行时调整限速值</li>
<li>明确模块的升级/降级触发条件, 可以使资源的占用, 特定的错误, 处理的耗时等</li>
<li>如果需要分布式下的多副本共同限速, 需要使用支持分布式的限速器库或代码</li>
</ol>
<p>过程中的一些代码： <a href="/download/Benthos 框架下的限速器降级方案探索/benthos_test.zip" download>benthos_test.zip</a></p>
]]></content>
      <categories>
        <category>benthos</category>
      </categories>
      <tags>
        <tag>benthos</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>关于关键字，函数以及指针的初步了解</title>
    <url>/2019/12/20191208.html</url>
    <content><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>对于关键字这一方面，有以下几个需要我特别注意的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>typedef</td>
<td>类型定义，可理解为类型重命名</td>
</tr>
<tr>
<td>static</td>
<td>1.修饰局部变量改变其生命周期（作用域不变）2.修饰全局变量改变作用域，连接属性由外转内 3.修饰函数，同全局变量类似</td>
</tr>
<tr>
<td>#define</td>
<td>定义常量和宏</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在学习函数这一方面的时候，碰到了一些小问题，总会在声明函数之后加上一个分号，导致一些语法上的错误<br>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_max</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误格式！！！</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_max</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确格式</span></span><br></pre></td></tr></table></figure>
<p>希望以后谨记。。。</p>
<h2 id="指针的初步理解"><a href="#指针的初步理解" class="headerlink" title="指针的初步理解"></a>指针的初步理解</h2><p>对我来说，指针变量更像是一个电话号码，给它打电话，就能找到要找到的人</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span>* p = &amp;a;</span><br><span class="line">  <span class="comment">//声明一个整形指针变量 P ，并将 a 的**地址**赋值给 P</span></span><br><span class="line">  *p = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//此时在用 p 指代 a ，此时的意思即为 a=20 （打电话给 a 说：你现在等于20了，(●&#x27;◡&#x27;●)）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或许是本科学习过的微机原理以及汇编语言的关系，我对内存的理解可并不像是一个初学者，我相信这能对我有所帮助。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11中的新特性</title>
    <url>/2020/07/20200727.html</url>
    <content><![CDATA[<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><p>C++11：支持内置类型与自定义类型的列表初始化，其中自定义类型不是天然支持列表初始化，需要显示定义参数类型为<code>initiaizer_list</code>的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span> (<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    : _a(a)</span><br><span class="line">    , _b(b)</span><br><span class="line">  &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">  <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> c&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">float</span> d = &#123; <span class="number">1.2</span> &#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m = &#123; &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">A a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="变量类型推导"><a href="#变量类型推导" class="headerlink" title="变量类型推导"></a>变量类型推导</h1><ul>
<li>auto：编译时根据初始化表达式进行类型推导</li>
<li>decltype：运行时类型识别，如果有参数列表，推导返回值类型，如果没有参数列表，只有函数名，推导为函数的接口类型</li>
</ul>
<h1 id="final与override"><a href="#final与override" class="headerlink" title="final与override"></a>final与override</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span> <span class="comment">//不能被继承</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">override</span> <span class="comment">//强制子类重写父类虚函数</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="默认成员函数控制"><a href="#默认成员函数控制" class="headerlink" title="默认成员函数控制"></a>默认成员函数控制</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> a): _a(a) </span><br><span class="line">	&#123;&#125; </span><br><span class="line">  <span class="comment">// 显式缺省构造函数，由编译器生成 </span></span><br><span class="line">	<span class="built_in">A</span>() = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> C&amp; c) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">//把一个函数声明成已删除函数，不能再被使用</span></span><br><span class="line">  <span class="comment">//拷贝构造声明为delete：放拷贝</span></span><br><span class="line">  </span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a); </span><br><span class="line"> <span class="comment">// 在类中声明，在类外定义时让编译器生成默认赋值运算符重载 </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="type">int</span> _a; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">A&amp; A::<span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line">	A a2; </span><br><span class="line">	a2 = a1; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>简单来说，左值：可以出现在<code>=</code>的两边、或者可以取地址的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* p2 = &amp;b;</span><br></pre></td></tr></table></figure>
<p>右值：只能出现在<code>=</code>的右边，或者不可以取地址（非绝对）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>；</span><br><span class="line"><span class="type">int</span>* p = &amp;<span class="number">10</span>;</span><br><span class="line"><span class="comment">//此处10和20均为右值</span></span><br></pre></td></tr></table></figure>
<p>C++中的右值：</p>
<ul>
<li>纯右值：常量、临时变量。<code>getA(A) = b;    int* p = &amp;(getA());</code></li>
<li>将亡值：声明周期即将结束的值</li>
</ul>
<p>临时变量：函数以值返回的变量，调用类的构造函数创建的变量</p>
<ul>
<li>左值引用：引用的实体既可以为左值，也可以为右值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ra = a;</span><br><span class="line"><span class="comment">//ra实体为左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ri = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//ri实体为右值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>右值引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; lr = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//实体为常量</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; lr2 = <span class="built_in">getA</span>();</span><br><span class="line"><span class="comment">//实体为临时变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r3 = <span class="built_in">getA</span>();<span class="comment">//左值引用，实体为右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; r4 = a;<span class="comment">//不能使用，右值引用语法不能用来引用左值</span></span><br></pre></td></tr></table></figure>
<p>小结：</p>
<p>左值引用，右值引用的语法意义：都是变量的别名</p>
<p>左值引用：就可以引用左值，也可以引用右值，如果引用右值，需要为const左值引用</p>
<p>右值引用：引用右值</p>
<ul>
<li>移动构造：参数类型为右值引用，提高拷贝的效率<ul>
<li>相对于拷贝构造，可以实现浅拷贝的情况下，不产生错误</li>
<li>右值引用指向的实体一般是将亡值，可以直接获取右值引用所指向的实体资源，不需要深拷贝</li>
</ul>
</li>
<li>移动赋值：参数类型为右值引用，也是浅拷贝，原理同上</li>
<li><code>move</code>：移动语义，将左值变为右值，使用时候需要注意保证属性被修改的左值在之后不会再用到</li>
</ul>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p><code>[捕捉列表](参数列表)mutable-&gt;返回值类型&#123;函数体&#125;</code></p>
<ul>
<li>捕捉列表（capture-list）：在lambda函数的开始位置，编译器根据[]来判断接下来 的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用。 </li>
<li>参数列表（parameters）：与普通函数的参数列表一致，如果不需要参数传递，则可以连同()一起省略 </li>
<li>mutable：默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。使用该修饰符时，参数列表不可省略(即使参数为空)。 </li>
<li>返回值类型（returntype）：用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分 可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导。 </li>
<li>函数体（statement）：在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量。 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">[] &#123;&#125;;</span><br><span class="line">[a, b]()<span class="keyword">mutable</span> &#123;a = <span class="number">100</span>; b = <span class="number">200</span>; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;a = <span class="number">1</span>; b = <span class="number">2</span>; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="built_in">func</span>(a, b);</span><br></pre></td></tr></table></figure>
<h2 id="捕捉列表"><a href="#捕捉列表" class="headerlink" title="捕捉列表"></a>捕捉列表</h2><ul>
<li>[var]：以值传递的方式捕捉变量var</li>
<li>[=]：表示以值传递的方式捕捉父类作用域的所有变量</li>
<li>[&amp;]：表示以引用传递的方式捕捉父作用域的所有变量，如果是传引用形式，不需要mutable也可以修改捕捉列表中的变量</li>
<li>[&amp;var]：以引用传递的方式捕捉变量var</li>
<li>[this]：以值传递方式捕捉当前的this指针</li>
<li>捕捉列表可以交叉使用</li>
<li>父类作用域不一定是直接父类作用域，嵌套的也可以</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//[=]以传值的形式捕捉父类作用域的所有变量</span></span><br><span class="line">[=](<span class="type">int</span> num)<span class="keyword">mutable</span>-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">  <span class="comment">//return a + b + c + num;</span></span><br><span class="line">  <span class="comment">//c还没有被定义，不能捕捉</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun2 = [&amp;](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">fun2</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了a以外其他变量都以值传递捕捉，a以引用传递捕捉</span></span><br><span class="line"><span class="comment">//错误写法[=, a]，都是值传递</span></span><br><span class="line"><span class="keyword">auto</span> fun3 = [=, &amp;a](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun4 = [&amp;, a](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>lambda表达式不能相互赋值，但可以拷贝；可以吧lambda表达式赋给一个函数指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun1 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> fun2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">fun1 = fun2;<span class="comment">//赋值操作，不能执行</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun3</span><span class="params">(fun2)</span></span>;<span class="comment">//拷贝操作</span></span><br><span class="line"><span class="keyword">auto</span> fun4 = fun2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*fptr)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fptr2)</span></span>;</span><br><span class="line"></span><br><span class="line">fptr ptr;</span><br><span class="line"></span><br><span class="line">ptr = fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口不一致</span></span><br><span class="line"><span class="comment">//fptr2 ptr2 = fun1;</span></span><br></pre></td></tr></table></figure>
<h1 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h1><p>头文件thread</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>thread</td>
<td>构造一个线程对象，没有关联任何线程函数，即没有启动任何线程</td>
</tr>
<tr>
<td>thread(fun, args1, args2, …)</td>
<td>构造一个线程对象，并关联线程函数fun，函数参数为args</td>
</tr>
<tr>
<td>get_id()</td>
<td>获取线程ID</td>
</tr>
<tr>
<td>joinable()</td>
<td>线程是否还在执行，joinable代表的是一个正在执行中的线程</td>
</tr>
<tr>
<td>join()</td>
<td>该函数调用后会阻塞线程，当该函数结束后，主线程继续执行</td>
</tr>
<tr>
<td>detach()</td>
<td>线程分离，把被创建的线程与线程对象分离</td>
</tr>
</tbody>
</table>
</div>
<p>RAII：资源获取立即初始化，在构造函数中初始化资源，在析构函数中销毁资源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadMange</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ThreadMange</span>(thread&amp; t)</span><br><span class="line">		: _thread(t)</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ThreadMange</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_thread.<span class="built_in">joinable</span>())</span><br><span class="line">			_thread.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	thread&amp; _thread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//thread t1;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(r1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(r2, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t3</span><span class="params">(r3, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ThreadMange <span class="title">tm1</span><span class="params">(t1)</span></span>;</span><br><span class="line">	<span class="function">ThreadMange <span class="title">tm2</span><span class="params">(t2)</span></span>;</span><br><span class="line">	<span class="function">ThreadMange <span class="title">tm3</span><span class="params">(t3)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*t1.join();</span></span><br><span class="line"><span class="comment">	t2.join();</span></span><br><span class="line"><span class="comment">	t3.join();*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要类的成员函数做线程函数，需要写完整的作用域，并且需要显示取地址，参数需要加上this所指的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B::bfun&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(&amp;B::bfun, &amp;b)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数参数类型为引用，在线程中需要修改原是变量，则需要听过ref转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(fun, ref(a))</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子性操作库（atomic）"><a href="#原子性操作库（atomic）" class="headerlink" title="原子性操作库（atomic）"></a>原子性操作库（atomic）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">sum2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		sum2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func, num)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func, num)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个变量声明为原子类型变量之后，不需要对该变量加互斥锁，线程也能够对该变量互斥访问，可以根据<code>atomic</code>类模版，定义出需要的任意原子类型。</p>
<p>由于原子类型通常属于资源型数据，故在C++11中，标准库将拷贝构造，移动构造以及运算符重载默认置为<code>delete</code></p>
<h1 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h1><ol>
<li>mutex</li>
</ol>
<p>try_lock：非阻塞加锁操作，如果其他线程没有释放当前锁，则直接返回加锁失败结果</p>
<p>lock：阻塞加锁操作，如果其他线程没有释放当前锁，阻塞等待，直到其他线程释放当前锁</p>
<p>unlock：解锁</p>
<ol>
<li>recursive_mutex：递归上锁，允许对互斥量进行多次上锁，但解锁需要调用与上锁相同的递归深度</li>
<li>timed_mutex</li>
</ol>
<ul>
<li>try_lock_for：接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程 释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返 回 false。 </li>
<li>try_lock_until() ：接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期 间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得 锁），则返回 false。 </li>
</ul>
<ol>
<li>recursive_timed_mutex</li>
</ol>
<h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>lock_guard类模版通过RAII的方式对其管理的互斥量进行了封装，在需要加锁的地方，使用任意一个互斥体实例化一个lock_guard，调用其构造函数即上锁，在出作用域前，lock_guard对象要被销毁，会调用其析构函数而自动解锁，可以有效避免死锁问题。</p>
<p>缺陷：太过单一，用户无法对该锁进行控制</p>
<h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>相较于lock_guard有了更多的接口</p>
<p>上锁/解锁操作：lock、try_lock、try_lock_for、try_lock_until和unlock </p>
<p>修改操作：移动赋值、交换(swap：与另一个unique_lock对象互换所管理的互斥量所有权)、释放 (release：返回它所管理的互斥量对象的指针，并释放所有权) </p>
<p>获取属性：owns_lock(返回当前对象是否上了锁)、operator bool()(与owns_lock()的功能相同)、 mutex(返回当前unique_lock所管理的互斥量的指针)。</p>
<h1 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h1><ol>
<li><p>原子操作：指令不会被打断，线程安全操作，效率较高</p>
<p> atomic\<T\>：把T类型数据封装成原子操作</T\></p>
</li>
<li><p>加锁：通过多线程之间的加锁阻塞保证线程安全，效率较低，加锁解锁比较耗时（相对于原子操作）</p>
<p> mutex、recursive_mutex、timed_mutex、recursive_timed_mutex</p>
<p> lock：阻塞式加锁</p>
<p> unlock：解锁</p>
<p> try_lock：非阻塞式加锁</p>
</li>
</ol>
<p>lock_guard、unique_lock：RAII实现，通过对象的生命周期控制锁的生命周期：</p>
<p>构造函数-&gt;加锁、析构函数-&gt;解锁</p>
<p>不支持拷贝操作</p>
<h1 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h1><ul>
<li>throw：当问题出现时，程序会抛出一个异常，通过throw关键字来完成</li>
<li>catch：在想要处理问题的地方，通过异常处理程序捕获一场，catch用于捕获异常，可以有多个catch进行捕获</li>
<li>try：try代码块中的代码表示将被激活特定的异常</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="number">0</span>;<span class="comment">//抛出异常</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//try：可能发生异常的代码放在这里</span></span><br><span class="line">		<span class="built_in">fun2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">char</span> ch)</span><br><span class="line">	&#123;<span class="comment">//捕获对应类型的异常</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;catch(char)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">char</span>* str)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;catch(char*)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;catch(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h2><p><strong>异常的抛出和匹配原则：</strong> </p>
<ol>
<li>异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。 </li>
<li>被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。 </li>
<li>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁。（这里的处理类似于函数的传值返回） </li>
<li>catch(…)可以捕获任意类型的异常，但是不知道异常错误是什么。 </li>
<li>实际中抛出和捕获的匹配原则有个例外，并不是类型完全匹配，可以抛出派生类对象，使用基类捕获。</li>
</ol>
<p><strong>在函数调用链中异常栈展开匹配原则：</strong> </p>
<ol>
<li>首先检查throw本身是否在try块内部，如果是再查找匹配的catch语句。如果有匹配的，则调到catch的地方进行处理。 </li>
<li>没有匹配的catch则退出当前函数栈，继续在调用函数的栈中进行查找匹配的catch。 </li>
<li>如果到达main函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的catch子句的过程称为栈展开。所以实际中一般都会加一个catch(…)捕获任意类型的异常，否则当有异常没捕 获，程序就会直接终止。 </li>
<li>找到匹配的catch子句并处理以后，会继续沿着catch子句后面继续执行</li>
</ol>
<p><strong>异常的重新抛出：</strong>有可能单个的catch不能完全处理异常，在进行一些矫正处理后，希望再交给更外层的调用链函数来处理，catch则可以通过重新抛出异常传递给更上层的函数进行处理</p>
<p><strong>异常安全：</strong></p>
<ul>
<li>构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化</li>
<li>析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等) </li>
<li>C++中异常经常会导致资源泄漏的问题，比如在new和delete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，而C++经常使用RAII来解决以上问题。</li>
</ul>
<p><strong>异常规范：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>; </span><br><span class="line"><span class="comment">// 这里表示这个函数只会抛出bad_alloc的异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>; </span><br><span class="line"><span class="comment">// 这里表示这个函数不会抛出异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure>
<h2 id="标准库中的异常体系"><a href="#标准库中的异常体系" class="headerlink" title="标准库中的异常体系"></a>标准库中的异常体系</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    arr.<span class="built_in">at</span>(<span class="number">10</span>) = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未知异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::execptiom</code>是所有标准C++异常的父类，用所有异常的根基类的引用或指针进行捕捉，可以匹配所有继承体系的所有类型，通过根基类虚函数重写，完成多态的逻辑，最终通过多态完成对异常的精准处理</p>
<h2 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h2><p><strong>优点：</strong></p>
<ol>
<li>异常对象定义好了，相比错误码的方式可以清晰准确的展示出错误的各种信息，甚至可以包含堆栈调用的信息，这样可以帮助更好的定位程序的bug。 </li>
<li>返回错误码的传统方式有个很大的问题是，在函数调用链中，深层的函数返回了错误，需要得层层返回错误，最外层才能拿到错误。</li>
<li>很多的第三方库都包含异常。</li>
<li>很多测试框架都使用异常，这样能更好的使用单元测试等进行白盒的测试。 </li>
<li>部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理。比如T&amp;operator这样的函数，如果pos越界了只能使用异常或者终止程序处理，没办法通过返回值表示错误。 </li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>异常会导致程序的执行流乱跳，并且非常的混乱，并且是运行时出错抛异常就会乱跳。会导致踪调试时以及分析程序时比较困难。 </li>
<li>异常会有一些性能的开销。但是在现代硬件速度很快的情况下，这个影响基本忽略不计。 </li>
<li>C++没有垃圾回收机制，资源需要自己管理，有了异常非常容易导致内存泄漏、死锁等异常安全问题，需要使用RAII来处理资源的管理问题。</li>
<li>C++标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱。 </li>
<li>异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func()、throw();的方式规范化。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中基本的内存管理</title>
    <url>/2020/05/20200530.html</url>
    <content><![CDATA[<h1 id="C-C-内存分布"><a href="#C-C-内存分布" class="headerlink" title="C/C++内存分布"></a>C/C++内存分布</h1><ol>
<li>栈：非静态局部变量，函数参数，返回值等，栈是向下增长的</li>
<li>内存映射段：装载一个共享的动态内存库</li>
<li>堆：用于程序运行时动态内存分配，可以向上增长</li>
<li>数据段：存储全局变量和静态数据</li>
<li>代码段：可执行的代码、只读常量</li>
</ol>
<span id="more"></span>
<h2 id="C语言中内存管理方式"><a href="#C语言中内存管理方式" class="headerlink" title="C语言中内存管理方式"></a>C语言中内存管理方式</h2><p>malloc（申请空间）、calloc（申请空间并进行零初始化）、realloc（调整空间大小，原地调整大小或重开空间，拷贝内容，释放原空间）</p>
<p>free（释放空间）</p>
<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><h2 id="new-delete-操作内置类型"><a href="#new-delete-操作内置类型" class="headerlink" title="new / delete 操作内置类型"></a>new / delete 操作内置类型</h2><p>申请空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr1 = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//动态申请一个int类型的空间</span></span><br><span class="line"><span class="type">int</span>* ptr2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//动态申请一个int类型的空间并初始化为10</span></span><br><span class="line"><span class="type">int</span>* ptr3 = <span class="keyword">new</span>[<span class="number">10</span>];<span class="comment">//动态申请10个int类型的空间</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>单个类型的空间：new + 类型</p>
</li>
<li><p>连续空间：new + 类型[个数]</p>
</li>
<li><p>单个类型空间申请 + 初始化：new + 类型（初始值）</p>
</li>
</ul>
<p>释放空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr1;</span><br><span class="line"><span class="keyword">delete</span> ptr2;</span><br><span class="line"><span class="keyword">delete</span>[] ptr3;</span><br></pre></td></tr></table></figure>
<ul>
<li>单个空间delete 指针</li>
<li>连续空间：delete[ ] 指针</li>
</ul>
<h2 id="new-delete操作自定义类型"><a href="#new-delete操作自定义类型" class="headerlink" title="new / delete操作自定义类型"></a>new / delete操作自定义类型</h2><p>动态创建自定义类型的对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> year)</span><br><span class="line">  &#123;</span><br><span class="line">    _year = year;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//new：动态开空间 + 调用构造函数初始化</span></span><br><span class="line">  Date* pd1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>);</span><br><span class="line">  Date* pd2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>);<span class="comment">//调用默认构造：无参构造，全缺省构造</span></span><br><span class="line">  Date* pd3 = <span class="keyword">new</span> Date[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>申请单个空间：new 自定义类型（参数列表），<strong>调用构造函数初始化</strong></li>
<li>申请连续空间：new 自定义类型[个数] ， <strong>自动调用默认构造进行初始化</strong>，如果没有则编译器报错</li>
</ul>
<p>释放自定义类型的空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pd1;<span class="comment">//调用一次析构 + 释放空间</span></span><br><span class="line"><span class="keyword">delete</span> pd2;<span class="comment">//调用一次析构 + 释放空间</span></span><br><span class="line"><span class="keyword">delete</span>[] pd3;<span class="comment">//调用十次析构，因为Date[10] + 释放空间</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>调用析构函数清理资源</strong> + 释放空间</li>
</ul>
<h1 id="operator-new-与-operator-delete函数"><a href="#operator-new-与-operator-delete函数" class="headerlink" title="operator new 与 operator delete函数"></a>operator new 与 operator delete函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>不是运算符重载函数，而是一个全局函数</p>
</li>
<li><p>使用方式和malloc类似</p>
</li>
<li><p>封装malloc + 异常处理机制</p>
</li>
</ul>
<blockquote>
<p>申请失败会抛出bad_alloc类型异常</p>
</blockquote>
<p>执行过程：operator new --&gt; malloc --&gt; 构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>不是运算符重载函数</li>
<li>使用方式和free类似</li>
<li>封装free</li>
</ul>
<p>_只有自定义类型才会调用构造函数和析构函数_</p>
<h2 id="operator-new-与-operator-delete的类专属重载"><a href="#operator-new-与-operator-delete的类专属重载" class="headerlink" title="operator new 与 operator delete的类专属重载"></a>operator new 与 operator delete的类专属重载</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Node</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">    p = <span class="built_in">allocator</span>&lt;Node&gt;().<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mem pool allocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(Node* ptr)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">allocator</span>&lt;Node&gt;().<span class="built_in">deallocate</span>((Node*)ptr, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mem pool deallocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _data;</span><br><span class="line">  Node* _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Node* np1 = <span class="keyword">new</span> Node;</span><br><span class="line">  Node* np2 = <span class="keyword">new</span> Node[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> np1;</span><br><span class="line">  <span class="keyword">delete</span>[] np2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="new-delete-原理"><a href="#new-delete-原理" class="headerlink" title="new / delete 原理"></a>new / delete 原理</h1><p>内置类型：</p>
<ul>
<li><p>new ： operator new --&gt; malloc 失败抛异常</p>
</li>
<li><p>delete ： operator delete --&gt; free</p>
</li>
<li><p>new [] : operator new[] --&gt; operator new --&gt; malloc</p>
</li>
<li><p>delete [] : operator delete[] – &gt; operator delete --&gt; free</p>
</li>
<li><p>和malloc区别：new空间申请失败抛异常，malloc空间申请失败返回空指针</p>
</li>
<li><p>和free区别：没有本质区别，delete封装了free操作</p>
</li>
</ul>
<p>自定义类型：</p>
<ul>
<li><p>new ： operator new --&gt; malloc --&gt; 构造函数 失败抛异常</p>
</li>
<li><p>delete ： 析构函数 --&gt; operator delete --&gt; free</p>
</li>
<li><p>new [] : operator new[] --&gt; operator new --&gt; malloc --&gt; N此构造函数</p>
</li>
<li><p>delete [] : N次析构函数 --&gt; operator delete[] – &gt; operator delete --&gt; free</p>
</li>
<li><p>和malloc区别：new空间申请失败抛异常，malloc空间申请失败返回空指针，new会调用自定义类型的构造函数，完成初始化，malloc不会</p>
</li>
<li><p>和free区别：delete会调用自定义类型的析构函数，完成资源清理的工作，free不会</p>
</li>
</ul>
<blockquote>
<p>new定位表达式：new（地址）类型（参数列表）</p>
<p> ：在已经开好的空间上显示调用构造函数</p>
<p>new（pd）Date（2030）；</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Date* pd = (Date*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Date));</span><br><span class="line"><span class="keyword">new</span> (pd)<span class="built_in">Date</span>(<span class="number">2030</span>);</span><br><span class="line">Date* pd2 = (Date*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Date));</span><br><span class="line"><span class="keyword">new</span> (pd2)Date;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的继承</title>
    <url>/2020/06/20200626.html</url>
    <content><![CDATA[<h1 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h1><p>类级别的代码复用</p>
<ol>
<li>继承方式：public、protected、private</li>
<li>protectde访问权限/private访问权限：<ul>
<li>protected —-&gt; 在当前类和子类中可见，在其他地方不可见</li>
<li>private —-&gt; 在当前类中可见，在其他地方不可见</li>
</ul>
</li>
<li>父类成员在子类中的访问权限：min { 成员在父类中的原始访问权限，继承方式 }</li>
<li>一般都是public继承，protected/private继承很少使用/几乎不用</li>
<li>默认继承方式：<ul>
<li>class定义的类默认继承方式是private</li>
<li>struct定义的类默认继承方式public</li>
</ul>
</li>
</ol>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>/<span class="keyword">struct</span> 类名 : 需要继承的类</span><br><span class="line">  				子类/派生类  父类/基类</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nema:&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//类外不可见，内部和子类可见</span></span><br><span class="line">  string _name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">int</span> _age = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  	<span class="type">int</span> _num = <span class="number">2020</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>子类继承方式为protected/private，从父类继承下来的所用成员的最低访问权限为protected/private，所以在子类外不可见</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类成员/继承方式</th>
<th>public继承</th>
<th>protected继承</th>
<th>private继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>基类的public成员</td>
<td>派生类的public成员</td>
<td>派生类的protected成员</td>
<td>派生类的private成员</td>
</tr>
<tr>
<td>基类的protected成员</td>
<td>派生类的protected成员</td>
<td>派生类的protected成员</td>
<td>派生类的private成员</td>
</tr>
<tr>
<td>基类的private成员</td>
<td>派生类不可见</td>
<td>在派生类不可见</td>
<td>派生类不可见</td>
</tr>
</tbody>
</table>
</div>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>子类对象，指针，引用可以直接赋值给父类对象，指针，引用，<strong>此处不是隐式类型转换</strong></p>
<p>父类对象不能赋值给子类对象</p>
<p>父类指针、引用不能直接赋值给子类指针、引用。可以通过强制类型转换进行赋值，但是强制转换类型不安全，可能会导致越界，一般不使用强制类型转换，而是动态类型转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person p;</span><br><span class="line">Student st;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line">p = st;</span><br><span class="line">Person&amp; rs = st;</span><br><span class="line">Person* ptrrs = &amp;st;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不可行</span></span><br><span class="line">st = p;</span><br><span class="line">Student&amp; rp = p;</span><br><span class="line">Student* ptrp = &amp;p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不安全，可能会访问越界</span></span><br><span class="line">Student&amp; rp = (Student&amp;)p;</span><br><span class="line">Student* ptrp = (Student*)&amp;p;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 子类对应类型赋值给父类对应类型 —-&gt; 切片：<strong>安全</strong>，不是隐式类型转换</p>
<p> 父类（指针/引用）赋值给子类（指针/引用） —-&gt; 强制类型转换：<strong>不安全</strong>，存在访问越界的风险</p>
</blockquote>
<h1 id="同名隐藏"><a href="#同名隐藏" class="headerlink" title="同名隐藏"></a>同名隐藏</h1><p>父类和子类中有同名的成员，子类只能直接看到自己的成员，如果需要访问父类同名的成员，需要加父类作用域，不同的作用域下，含有同名成员，当前作用域下的成员就会隐藏其他作用域下的成员，<em>不是继承体系独有的</em>。</p>
<ul>
<li>成员变量隐藏：成员变量的名称相同</li>
<li>函数隐藏：函数名字相同，就会构成函数隐藏，与参数无关 —-&gt; 这种情况是发生在父类和子类汇总，不在同一个作用域；函数重载：在同一个作用域，函数名相同，参数不同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> _num)</span></span></span><br><span class="line"><span class="function">  </span>&#123; _num = _num; &#125;<span class="comment">//就近原则，此时为局部域，局部变量</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  	<span class="type">int</span> _num = <span class="number">2020</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student st;</span><br><span class="line">cout &lt;&lt; st._num &lt;&lt; endl;</span><br><span class="line">st.<span class="built_in">setNum</span>(<span class="number">1999</span>);</span><br><span class="line">cout &lt;&lt; st._num &lt;&lt; endl;<span class="comment">//2020</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>同名隐藏：父类中的同名成员被子类中的同名成员隐藏</p>
</blockquote>
<p>父类、子类的作用域都是独立的，不同的作用域中可以有同名的成员，只要函数名相同，就会构成同名隐藏，不是函数重载</p>
<h1 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h1><blockquote>
<p> 编译器自动生成的默认构造自动调用父类的默认构造</p>
<p>显示定义的构造函数也自动调用父类的默认构造，在初始化列表中调用父类构造</p>
<p>父类成员必须要由父类的构造函数完成初始化</p>
</blockquote>
<p><strong>子类构造函数：</strong></p>
<ol>
<li>一定会调用父类的构造函数<ol>
<li>如果不显示调用，自动调用父类的默认构造</li>
<li>如果显示调用，则调用显示指定的父类构造</li>
</ol>
</li>
<li>继承自父类的成员变量，一定要通过父类的构造函数完成初始化，在子类的初始化列表中只能显示的初始化子类新增的成员变量</li>
<li>初始化顺序：一定是首先初始化父类成员，再去初始化子类成员</li>
<li>创建子类对象时，首先调用子类的构造函数，在子类构造函数的初始化列表中调用父类的构造函数，先执行父类的构造逻辑，然后再执行子类本身的构造逻辑</li>
</ol>
<blockquote>
<p>编译器自动生成的拷贝构造自动调用父类的拷贝构造</p>
<p>显示定义的拷贝构造，自动调用父类的默认构造，不是父类的拷贝构造</p>
<p>调用父类拷贝构造会有有切片操作</p>
</blockquote>
<p><strong>子类的拷贝构造：</strong></p>
<ol>
<li>默认行为（没有显示定义子类的拷贝构造）：父类的拷贝构造</li>
<li>显示定义子类拷贝构造默认行为（没有显示调用父类的拷贝构造）：父类的默认构造</li>
<li>在子类的拷贝构造中可以指定调用哪一个父类的构造函数，不一定是拷贝构造</li>
</ol>
<blockquote>
<p>编译器自动生成的赋值运算符重载函数自动调用父类的赋值运算符重载函数</p>
<p>子类赋值运算符和父类赋值运算符构成同名隐藏</p>
</blockquote>
<p><strong>子类的赋值运算符：</strong></p>
<ol>
<li>默认行为：调用父类的赋值运算符</li>
<li>显示定义：和父类的赋值运算符构成同名隐藏，如果需要调用父类的赋值运算符，需要指定父类的作用域</li>
<li>建议调用父类的赋值运算符：达到代码复用的目的</li>
</ol>
<blockquote>
<p>父类析构不需要显示调用，可能会导致资源二次释放的问题</p>
</blockquote>
<p><strong>子类析构函数：</strong></p>
<ol>
<li>编译器自动生成的析构函数自动调用父类的析构函数</li>
<li>显示定义的子类析构函数也会自动调用父类的析构函数</li>
<li>无论子类析构是否显示调用父类析构，编译器都会自动调用一次父类析构</li>
<li>子类析构和父类析构底层函数名相同，构成函数隐藏</li>
</ol>
<h1 id="继承与友元、静态成员"><a href="#继承与友元、静态成员" class="headerlink" title="继承与友元、静态成员"></a>继承与友元、静态成员</h1><p>友元关系不能继承，基类的友元不能访问子类的私有和保护成员</p>
<p>基类定义了static静态成员，则继承体系中只有一个这样的成员，无论派生出多少个子类，都只有一个static成员实例</p>
<h1 id="复杂继承"><a href="#复杂继承" class="headerlink" title="复杂继承"></a>复杂继承</h1><p><strong>单继承：</strong>一个子类只有一个直接父类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>多继承：</strong>一个子类有两个或以上直接父类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>菱形继承：</strong>多继承的一种特殊情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>菱形继承存在数据冗余和二义性的问题</p>
</blockquote>
<h2 id="菱形虚拟继承"><a href="#菱形虚拟继承" class="headerlink" title="菱形虚拟继承"></a>菱形虚拟继承</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>通过虚基表指针和虚基表，虚基表存放公共部分的偏移量，虚基表指针指向虚基表</p>
<p>虚基表</p>
<ol>
<li>相对于当前位置的偏移量</li>
<li>相对于公共部分偏移量</li>
</ol>
<p>菱形虚拟继承可以解决数据冗余和二义性</p>
<ol>
<li>通过虚基表指针和虚基表实现</li>
<li>如果需要访问公共成员：首先通过虚基表指针找到虚基表，读取偏移量，当前位置偏移指定的偏移量，找到公共部分成员，<strong>切片操作的过程</strong></li>
<li>通过指针大小，换取重复成员的大小</li>
<li>时间换空间的语法</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>-类与对象 -C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的类与this指针</title>
    <url>/2020/05/20200523.html</url>
    <content><![CDATA[<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p>C++ struct：可以定义数据以及函数，一般使用class</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    _id = id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;<span class="comment">//成员函数</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//共有成员在任何地方可用</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    _id = id</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:<span class="comment">//私有的成员在类外不可见</span></span><br><span class="line">  <span class="comment">//成员变量，属性</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> _id;</span><br><span class="line"> <span class="keyword">protected</span>:<span class="comment">//保护的成员在类外不可见</span></span><br><span class="line">  <span class="type">char</span> major[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="类的限定符以及封装"><a href="#类的限定符以及封装" class="headerlink" title="类的限定符以及封装"></a>类的限定符以及封装</h1><blockquote>
<p>访问限定符：public，protected， private</p>
</blockquote>
<p><strong>限定符表示范围，从当前限定符开始，到下一个限定符结束</strong>，只限制成员在类外的访问，类内访问不受限制</p>
<blockquote>
<p>class 定义成员默认访问权限为私有<br>struct 定义的成员默认访问权限是共有</p>
</blockquote>
<p><strong>建议显式的写出来，以增加可读性</strong><br><strong>类的封装</strong>：将数据和操作数据的方法有机结合，隐藏属性和实现的细节，仅对外公开接口来和对象进行交互</p>
<h1 id="类的作用域："><a href="#类的作用域：" class="headerlink" title="类的作用域："></a>类的作用域：</h1><p> 类定义了一个新的作用域，所有类的成员都在类的作用域中。在类体外定义成员，需要使用：：作为域解析符，指明成员属于哪个类域</p>
<h1 id="类的实例化："><a href="#类的实例化：" class="headerlink" title="类的实例化："></a>类的实例化：</h1><p> 变量：对象 -—-&gt;自定义类型的变量一般习惯称为对象</p>
<p>类只是一个模型一样的东西，限定了类有哪些成员，定义一个<strong>没有分配实际的内存空间</strong>来存储它</p>
<p>一个类可以实例化多个对象，实例化出的对象，占用实际的物理空间，存储类成员变量</p>
<h1 id="类对象模型（大小）"><a href="#类对象模型（大小）" class="headerlink" title="类对象模型（大小）"></a>类对象模型（大小）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  <span class="comment">//4字节</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>  <span class="comment">//4字节</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> _b;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>  <span class="comment">//1字节</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>  <span class="comment">//1字节</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象模型中只存放普通的成员变量，不存放成员函数，成员函数存放在公共代码段</p>
<p>空类占一个字节（起到标记作用）</p>
</blockquote>
<p>类的大小遵循<strong>内存对齐</strong>规则</p>
<ol>
<li><strong>第一个成员在与结构体偏移量为0的地址处。</strong></li>
<li><strong>其他成员变量要对齐到某个数字（对齐数）的整数倍地址处。</strong> _（对齐数 = 编译器默认对齐数与该成员大小的较小值，VS默认为 8 ，Linux和当前字段sizeof值一样）_</li>
<li><strong>结构体总大小为：最大对齐数（所有变量类型的最大者与默认对齐数取最小）的整数倍。</strong></li>
<li><strong>如果存在嵌套，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍处。</strong></li>
</ol>
<p><strong>！！！！如果嵌套的结构体只有定义，那么算大小的时候不算它！！！！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  <span class="comment">//48 字节</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> _a;</span><br><span class="line">	<span class="type">double</span> _b;</span><br><span class="line">	<span class="type">int</span> _c;</span><br><span class="line">	<span class="type">char</span> _d;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> _a;</span><br><span class="line">		<span class="type">char</span> _b;</span><br><span class="line">		<span class="type">int</span> _c;</span><br><span class="line">		<span class="type">char</span> _d;</span><br><span class="line">	&#125;;</span><br><span class="line">	B b;<span class="comment">//关键点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  <span class="comment">//24字节</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> _a;</span><br><span class="line">	<span class="type">double</span> _b;</span><br><span class="line">	<span class="type">int</span> _c;</span><br><span class="line">	<span class="type">char</span> _d;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> _a;</span><br><span class="line">		<span class="type">char</span> _b;</span><br><span class="line">		<span class="type">int</span> _c;</span><br><span class="line">		<span class="type">char</span> _d;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么要内存对齐？</p>
<p>答：提高访问效率，CPU读取内存是按块读取的，内存对齐可以提高访问效率，方便一些硬件（如嵌入式）读取数据</p>
<p>如何修改内存对齐数：#pargma pack()</p>
</blockquote>
<h1 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h1><p>C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该 指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。<br>this 指针类型：类类型* const</p>
<p>this指针只存在于成员函数中</p>
<p>this指针始终作为成员函数的第一个行参</p>
<blockquote>
<p>this不是类的成员，只是一个函数行参，一般存在于栈上，一般会做优化，存在寄存器中</p>
</blockquote>
<p><strong>有解引用的情况下this指针不能为空！</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础语法</title>
    <url>/2020/05/20200521.html</url>
    <content><![CDATA[<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">namespacs dog<span class="comment">//命名空间为dog</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d \n&quot;</span>, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;<span class="comment">//可定义变量，也可定义函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">namespace</span> big_dog<span class="comment">//可以嵌套</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">      <span class="type">int</span> a;</span><br><span class="line">      <span class="type">int</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dog<span class="comment">//可以分段写，最后会整合在一起</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a = <span class="number">10</span>;<span class="comment">//局部域</span></span><br><span class="line">  dog::a = <span class="number">20</span>;<span class="comment">//命名空间域</span></span><br><span class="line">  dog::big_dog::a = <span class="number">30</span>;<span class="comment">//命名空间域</span></span><br><span class="line">  ::a = <span class="number">40</span>;<span class="comment">//全局作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">fun3</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<ol>
<li>命名空间+：：+成员</li>
<li>引入成员using + 命名空间 + ：：+成员，后边使用时不用加作用域，成员暴露在全局域中，如果全局域中有同名成员，会导致命名冲突</li>
<li>展开命名空间 using 命名空间，命名空间所有成员暴漏在全局域中</li>
</ol>
<h1 id="输入输出方式"><a href="#输入输出方式" class="headerlink" title="输入输出方式"></a>输入输出方式</h1><p>头文件 + std命名空间</p>
<p>输出 cout \&lt;\&lt; a \&lt;\&lt; “\\n”; 输出a\\n</p>
<p>输入 cin &gt;&gt; b; 输入b</p>
<p>支持连续的输入输出</p>
<p>字符串指针输出内容</p>
<p>非字符串指针输出地址</p>
<h1 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h1><p>给参数定义一个默认值，实际使用时，如果没有传参，对应的行参使用默认值，参数传递一个用一个（<strong>必须从第一个参数开始传递，参数要连续的传递</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span><span class="comment">//全缺省</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span><span class="comment">//半缺省，必须从右到左连续无间断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c)</span><span class="comment">//非法</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun4</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b, <span class="type">int</span> c = <span class="number">3</span>)</span><span class="comment">//非法</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//错误写法，缺省值只能出现在声明或定义的地方，不能同时出现</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun5</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span></span>;<span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun5</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>, <span class="type">int</span> b = <span class="number">200</span>, <span class="type">int</span> c = <span class="number">300</span>)</span><span class="comment">//定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>同一个作用域内声明几个功能类似的同名函数，这些同名函数的行参列表（<strong>参数个数或类型 或顺序</strong>）必须不同， 常用于处理实现功能类似数据类型不同的问题。</p>
<p><strong>仅仅返回值不同，不能构成重载。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">char</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">Add</span>((<span class="type">float</span>)<span class="number">1.5</span>, (<span class="type">float</span>)<span class="number">1.6</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="函数重载如何实现的"><a href="#函数重载如何实现的" class="headerlink" title="函数重载如何实现的"></a>函数重载如何实现的</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>编译器编译之后的底层函数名称：</p>
<ul>
<li>VS：C编译器 ：无法解析的外部符号 _Add</li>
<li>VS：C++编译器：无法解析的外部符号 ？Add\@\@YAHH\@Z</li>
<li>g++编译器：_Z3Addii</li>
<li>_Z：规定的前缀，3：函数名字的字数，Add：函数名，ii：有两个int类型参数</li>
</ul>
<p>函数名修饰规则：</p>
<ul>
<li>C编译器：函数名中不包含参数信息</li>
<li>C++编译器：函数名中包含参数信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//C编译器均为：_Add</span></span></span><br><span class="line"><span class="function"><span class="comment">//g++编译器：_Z3Addii</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//_Z3Addff</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"><span class="comment">//_Z3Addiii</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">char</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//_Z3Addci</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//_Z3Addic</span></span></span><br></pre></td></tr></table></figure>
<h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><p>按照C语言规则编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>不是新定义一个变量，而是给已存在的变量去了一个别名，编译器不会为引用变量开辟内从空间，它和它的引用的变量公用同一块内存空间。</p>
<ul>
<li>类型 + \&amp; + 引用名称</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ra = a;</span><br><span class="line"><span class="type">int</span>&amp; ra2 = a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rb = a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//引用类型和引用实体必须是相同类型</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">2.0</span>;</span><br><span class="line"><span class="type">double</span>&amp; rd = d;</span><br><span class="line"><span class="type">int</span> c = d;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rd2 = d;</span><br><span class="line"><span class="comment">//d隐式类型转换，生成一个临时int变量，rd2此时指向为此临时变量，而临时变量具有常性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; ra, <span class="type">int</span>&amp; rb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = ra;</span><br><span class="line">	ra = rb;</span><br><span class="line">	rb = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Add2</span><span class="params">(<span class="type">int</span>&amp; ra)</span><span class="comment">//int&amp; Add3(int a),引用做返回值，注意返回值的周期一定要大于函数生命周期</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ++ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">	<span class="type">int</span>&amp; c = <span class="built_in">Add2</span>(a);</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>底层实现：引用通过指针实现，定义一个引用类型的变量相当于定义一个指针类型的变量。</strong></p>
<p><strong>语法：引用是别名，不是指针，没有发生拷贝。</strong></p>
<blockquote>
<p>目前可以认为引用是指针的一层封装，更加简单化的指针</p>
</blockquote>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键字 ：“inline”</p>
</blockquote>
<p>内联函数：编译器编译时，会进行函数指令展开，没有栈帧的开销，提高代码效率</p>
<blockquote>
<p>替代宏函数的使用</p>
</blockquote>
<p>inline只是一个建议，编译器会根据实际情况进行判断，如果代码简单，直接展开，代码复杂，不会展开</p>
<p><strong>inline不支持分离定义</strong></p>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>自动类型推导，不代表具体类型，编译时根据初始化表达式自动推导</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>auto定义的变量必须初始化</p>
<p>auto可以定义多个变量，每一个表达式的类型要一致</p>
<p>auto定义指针时，加不加 * 没有区别，定义引用类型时，<strong>必须加 \&amp;</strong></p>
</blockquote>
<p><strong>函数参数类型不能使用auto， 定义数组不能使用auto</strong></p>
<h1 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h1><blockquote>
<p>范围内用于迭代的变量 ： 被迭代的范围</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i - <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : array)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用场景：数据范围确定</p>
</blockquote>
<h1 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h1><ol>
<li>其作为关键字，不需要包含头文件</li>
<li>sizeof（nullptr） == sizeof ((void*) 0 )</li>
<li>为了提高代码健壮性，尽量使用nullptr表示指针空值</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多态的基本原理及使用</title>
    <url>/2020/06/20200628.html</url>
    <content><![CDATA[<h1 id="多态的概念、定义以及实现"><a href="#多态的概念、定义以及实现" class="headerlink" title="多态的概念、定义以及实现"></a>多态的概念、定义以及实现</h1><p>多种形态，当不同的对象去执行同一种行为时，产生的不同表现形态</p>
<p><strong>构成条件：</strong>在不同的继承关系的类对象，去调用同一函数，产生了不同的行为</p>
<ol>
<li>继承关系</li>
<li>必须通过基类的指针或者引用调用的虚函数，一般都是用父类指针/引用指向父类以及子类实体，即都为切片行为</li>
<li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</li>
</ol>
<span id="more"></span>
<blockquote>
<p>必须同时满足以上条件，缺一不可</p>
</blockquote>
<p><strong>虚函数的重写：</strong>重写函数逻辑</p>
<p>构成虚函数重写条件：子类含有和父类接口完全相同的函数（返回值，函数名，参数完全相同），例外：协变，析构函数重写，如果不满足所有条件，但是函数名相同，则构成函数隐藏</p>
<blockquote>
<p>协变：返回值类型可以不同，但是返回值类型必须是父子关系</p>
</blockquote>
<p>注意：如果父类函数加了<code>virtual</code>声明，则子类接口完全一致的函数即使不加<code>virtual</code>也具有虚函数的属性，但是反过来不成立，建议一般对于所有的虚函数都加上<code>virtual</code></p>
<blockquote>
<p>非多态：看类型</p>
<p>多态：看实际指向的实体</p>
</blockquote>
<p><strong>析构函数重写：</strong></p>
<ol>
<li><p>只要父类的析构函数是虚函数，则子类的析构函数和父类的析构函数构成重写</p>
<p> 原因：编译器对继承关系下的所有类的析构函数的名字做了统一处理，保证了继承关系下所有的析构函数同名，一般把析构函数的名称统一处理成<code>destructor</code></p>
</li>
</ol>
<p><code>final</code>和<code>override</code>关键字：</p>
<ol>
<li><code>final</code>：修饰虚函数，表示该虚函数不能再被继承，其定义的函数不能被重写，体现实现继承</li>
<li><code>override</code>：检查派生类虚函数是否重写了某个虚函数，如果没有重写则编译报错，强制子类重写父类的某一个虚函数</li>
</ol>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类：包含纯函数的类，抽象类不能实例化对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//纯虚函数：没有函数体的虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//无法执行以下代码</span></span><br><span class="line">  <span class="comment">//A a;</span></span><br><span class="line">  <span class="comment">//a.fun();</span></span><br><span class="line">  </span><br><span class="line">  B b;</span><br><span class="line">  A* pb = &amp;b;</span><br><span class="line">  b.<span class="built_in">fun</span>();</span><br><span class="line">  pb-&gt;<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类存在意义，实现多态，其体现出接口继承</p>
<h1 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h1><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//包含隐藏成员变量，虚函数表指针</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>包含虚函数的类：</strong>类中包含一个隐含的成员变量，即虚表指针</p>
<p><strong>虚表指针：</strong>指向虚表的首地址，类型为二级指针，函数指针的指针</p>
<p><strong>虚表：</strong>存放虚函数指针的数组，类型为指针数组</p>
<ol>
<li>只存放虚函数的指针</li>
<li>普通函数不会存入虚表</li>
<li>如果子类重写了父类的虚函数，则子类虚表中对应位置使用子类虚函数指针覆盖</li>
<li>如果子类没有重写父类的任何虚函数，则子类完全继承父类虚表，不做任何修改</li>
<li>虚函数指针在虚表中的存放顺序和其声明/定义的顺序一致</li>
<li>子类新定义的虚函数，其虚函数指针按照声明/定义的顺序依次加入虚表的末尾</li>
<li>虚表一般以<code>nullptr</code>结束</li>
</ol>
<blockquote>
<p>只要类中包含虚函数，就会有虚表指针和虚表</p>
</blockquote>
<ul>
<li>虚表指针存在对象当中</li>
<li>虚表存放在代码段</li>
<li>虚函数存放在代码段</li>
</ul>
<p><strong>多态：看实际指向的实体</strong></p>
<p>多态原理：如果访问的为虚函数，则通过指针/引用找到实际指向的实体，获取实体中的虚表指针，通过虚表指针访问虚表，在虚表中找到需要执行的虚函数指针，通过虚函数指针执行具体函数行为</p>
<h2 id="继承下的虚表"><a href="#继承下的虚表" class="headerlink" title="继承下的虚表"></a>继承下的虚表</h2><p><strong>单继承虚表</strong>：</p>
<ol>
<li>子类继承父类虚表</li>
<li>用重写的虚函数指针覆盖子类对应的虚函数指针</li>
<li>子类新定义的虚函数，其指针按照声明/定义顺序存入虚表的末尾</li>
</ol>
<p><strong>多继承虚表：</strong></p>
<ol>
<li>虚表个数：等同于直接父类的个数</li>
<li>子类继承父类所有的虚表</li>
<li>用重写的虚函数指针覆盖对应父类的虚函数指针</li>
<li>子类新定义的虚函数，其函数指针按照声明/定义的顺序存入第一个直接父类虚表的末尾</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake语法小结</title>
    <url>/2023/03/20230318.html</url>
    <content><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h3><p><code>PROJECT(name)</code>指定工程名称， 默认支持所有语言</p>
<p><code>PROJECT(name CXX)</code>指定工程名称， 支持C++</p>
<p>会隐式定义两个变量</p>
<ul>
<li>${name}_BINARY_DIR</li>
<li>${name}_SOURCE_DIR</li>
</ul>
<p>修改工程名时会将这两个变量修改，可通过预定义两个变量<code>PROJECT_BINARY_DIR</code>以及<code>PROJECT_SOURCE_DIR</code>解决该问题</p>
<h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h3><p>设定值，<code>SET(SRC_LIST main.cpp a.cpp b.cpp)</code>，即设定了<code>SEC_LIST</code>的值</p>
<h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h3><p>输出自定义的信息，主要有三种</p>
<ul>
<li>SEND_ERROR，产生错误生成过程被跳过</li>
<li>STAUS，显示普通的消息</li>
<li>FATAL_ERROR，终止cmake过程</li>
</ul>
<span id="more"></span>
<h3 id="ADD-EXECUTABLE"><a href="#ADD-EXECUTABLE" class="headerlink" title="ADD_EXECUTABLE"></a>ADD_EXECUTABLE</h3><p>生成可执行文件<code>ADD_EXECUTABLE(target src)</code></p>
<h3 id="ADD-SUBDIRECTORY"><a href="#ADD-SUBDIRECTORY" class="headerlink" title="ADD_SUBDIRECTORY"></a>ADD_SUBDIRECTORY</h3><ul>
<li>添加存放源文件的子目录，并可指定中间二进制与目标二进制的存放位置</li>
<li><code>EXECULDE_FORM_ALL</code>可将参数从编译中排除</li>
<li><code>ADD_SUBDIRECTORY(src bin)</code><ul>
<li>将src目录加入工程并指定编译输出（包含中间结果）路径为bin目录</li>
<li>如果不进行 bin 目录指定， 那编译结果（包含中间文件）将会存放在指定的 执行cmake命令目录下的src</li>
</ul>
</li>
</ul>
<h3 id="关于更改二进制保存路径"><a href="#关于更改二进制保存路径" class="headerlink" title="关于更改二进制保存路径"></a>关于更改二进制保存路径</h3><ul>
<li><code>SET(EXECUTABLE_OUTPUT_PATH $(PROJECT_BINARY_DIR)/bin)</code></li>
<li><code>SET(LIBRARY_OUTPUT_PATH $(PROJECT_BINARY_DIR)/lib)</code></li>
</ul>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>变量使用<code>$&#123;&#125;</code>取值，<strong>但在 IF 语句中直接使用变量名</strong></li>
<li>指令中的参数需使用<code>()</code>括起来，参数之间使用空格或分号分隔</li>
<li>指令大小写无关</li>
<li>如果参数中包含空格，则需要将参数使用双引号包括</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>INSTALL：安装指令，包括二进制，动态库，静态库以及文件，目录，脚本等</p>
<p>CMAKE_INSTALL_PREFIX：—prefix</p>
</blockquote>
<ul>
<li>安装文件：<code>INSTALL(FILES file1 file2 DESTINATION dst_dir)</code>，将<code>file1</code>以及<code>file2</code>安装到<code>dest_dir</code>中，其中<code>FILES</code>为文件，<code>DESTINATION</code>一般为：<ul>
<li>绝对路径</li>
<li>相对路径，即为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;DESTINATION&#125;</code>，<code>CMAKE_INSTALL_PREFIX</code>一般默认为<code>/usr/local/</code>，可使用<code>cmake -DCMAKE_INSTALL_PREFIX=/usr</code>指定该变量的值</li>
</ul>
</li>
<li>安装脚本：<code>INSTALL(PROGRAMS abc.sh bin)</code>，<code>PROGRAMS</code> 为非目标文件的可执行程序安装</li>
<li>安装目录：<ul>
<li>直接在需要安装的目录内创建CMakeList.txt，在其内写INSTALL file</li>
<li><code>INSTALL(DIRECTORY dir/ DESTINATION dst_dir)</code>：若为<code>dir/</code>则表示将<code>dir</code>目录下所有内容安装到<code>dst_dir</code>下，若为<code>dir</code>则表示将<code>dir</code>目录本身安装到<code>dst_dir</code></li>
</ul>
</li>
<li>安装库文件：<code>INSTALL(TARGET bin_name lib_name_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</code>，安装二进制，静态或动态库均需要使用<code>TARGET</code>，<code>ARCHIVE</code>特指静态库，<code>LIBRARY</code>特指动态库，<code>RUNTIME</code>特指可执行的目标二进制</li>
</ul>
<h2 id="构建静态库与动态库"><a href="#构建静态库与动态库" class="headerlink" title="构建静态库与动态库"></a>构建静态库与动态库</h2><p><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></p>
<ul>
<li>lib_name：库名称</li>
<li>SHARED：表示生成动态库，STATIC表示生成静态库</li>
<li>LIB_SRC：源文件</li>
</ul>
<blockquote>
<p>同时构建静态库与动态库的方式：</p>
<ol>
<li><p>使用两个名字，例如</p>
<ul>
<li><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></li>
<li><code>ADD_LIBRARY(lib_name_static STATIC $&#123;LIB_SRC&#125;)</code></li>
</ul>
</li>
<li><p>使用<code>SET_TARGET_PROPERTIES</code>，设置输出名称</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIB_NAME_SRC lib_src.cpp)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name_static STATIC <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">//重命名lib_name_static为lib_name</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">//在构建新的目标时，会尝试清理掉其他使用使用这个名称的库，例如构建lib_name.so时会清除掉lib_name.a</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name SHARED <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="动态库版本号设定"><a href="#动态库版本号设定" class="headerlink" title="动态库版本号设定"></a>动态库版本号设定</h3><p><code>SET_TARGET_PROPERTIES(lib_name PROPERTIES VERSION 1.2 SOVERSION 1)</code>，其中：</p>
<ul>
<li>VERSION：动态库版本</li>
<li>SOVERSION：API版本</li>
</ul>
<h2 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h2><p><code>INCLUDE_DIRECTORIES(head_path)</code>，指定头文件路径</p>
<p><code>LINK_DIRECTORIES(lib_path)</code>，指定库路径</p>
<p><code>TARGET_LINK_LIBRARIES(bin_name lib_name)</code>，指定二进制<code>lib_name</code>要链接的库文件</p>
<h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><ul>
<li><code>CMAKE_INCLUDE_PATH</code>，头文件路径</li>
<li><code>CMAKE_LIBRARY_PATH</code>，库文件路径</li>
<li><code>CMAKE_BUILD_TYPE</code>，release or debug等</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中对于数组strlen和sizeof的各种情况及分析</title>
    <url>/2020/03/20200303.html</url>
    <content><![CDATA[<h3 id="strlen和sizeof本身的区别"><a href="#strlen和sizeof本身的区别" class="headerlink" title="strlen和sizeof本身的区别"></a>strlen和sizeof本身的区别</h3><p>szieof是一个运算操作符，在使用时无需声明头文件，它的参数可以是数据类型，数组，指针及函数等等<br>strlen是一个库函数，在使用前需要声明string.h头文件，它的参数必须是字符型指针（char* ）</p>
<span id="more"></span>
<h3 id="对于数组"><a href="#对于数组" class="headerlink" title="对于数组"></a>对于数组</h3><p>首先，数组和指针是两个不相干的概念，然而，C语言中很多情况下数组都能隐式转化为指针，指针也能当作数组一样使用（用[ ]来取下标）</p>
<p><strong>_32位系统下，一个指针大小为四个字节_</strong></p>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));</span><br><span class="line">	<span class="comment">//由于数组中没有‘\0’所以会产生内存非法访问		</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr + <span class="number">0</span>));	</span><br><span class="line">	<span class="comment">//同上</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr)); </span><br><span class="line">	<span class="comment">//*arr得到的是字符‘a’，类型是char，而strlen函数要求的参数是</span></span><br><span class="line">	<span class="comment">//char*，但是存在隐式转换，将char转化为char*，使得编译可以</span></span><br><span class="line">	<span class="comment">//进行（会有警告），但是实际运行时程序会崩溃，</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));	</span><br><span class="line">	<span class="comment">//同上	</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));</span><br><span class="line">	<span class="comment">//&amp;arr =&gt; 类型为char(*)[6]，类型与strlen函数要求参数类型不同</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line">    <span class="comment">//发生隐式转换，指针所占字节数为4个字节</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">	<span class="comment">//值为7，求字符串所占内存大小，包含&#x27;\0&#x27;		</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr + <span class="number">0</span>));	</span><br><span class="line">	<span class="comment">//发生了隐式转换，(arr + 0)类型为char* 指针，大小为四个字节</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line">	<span class="comment">//*arr即为字符&#x27;a&#x27;,它所占内存空间为一个字节		</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));	</span><br><span class="line">	<span class="comment">//arr[1]即为字符&#x27;b&#x27;，占一个字节	</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line">	<span class="comment">//发生隐式转化，转换为char(*)[7],为指针，占四个字节	</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr + <span class="number">1</span>));	</span><br><span class="line">	<span class="comment">//同上</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));	</span><br><span class="line">	<span class="comment">//同上，此处类型为char*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));</span><br><span class="line">	<span class="comment">//6  求字符串长度不包含&#x27;\0&#x27;	</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr + <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));</span><br><span class="line">	<span class="comment">//*arr类型为char，与strlen函数要求的参数类型不同</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">//同上</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));	</span><br><span class="line">	<span class="comment">//&amp;arr类型为char(*)[7]，但恰好&amp;arr和arr得到的地址是相同的</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr + <span class="number">1</span>));	</span><br><span class="line">	<span class="comment">//&amp;arr + 1跳过了整个数组，此时运行程序会发生非法访问内存</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));	</span><br><span class="line">	<span class="comment">//&amp;arr[0]类型为char* ，指向字符串第一个字符，加一之后跳过第一个字符，结果是5</span></span><br></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p));	</span><br><span class="line"><span class="comment">//p是指针，32位系统下占四个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//(p + 1)还是指针，同上	</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));	</span><br><span class="line"><span class="comment">//*p =&gt; &#x27;a&#x27;,char类型，一个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">1</span>]));</span><br><span class="line"><span class="comment">//p[1] =&gt; b，char类型，一个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));	</span><br><span class="line"><span class="comment">//&amp;p还是指针，类型为char**，四个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line">   <span class="comment">//类型为char* ，指针，32位系统下四个字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p));</span><br><span class="line"><span class="comment">//6，指针p指向字符串&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//(p + 1),跳过一个元素求字符串字节数，5	</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line"><span class="comment">//*p 类型为char，类型不匹配</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p[<span class="number">1</span>]));</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p));</span><br><span class="line"><span class="comment">//&amp;p类型为char**，类型不匹配</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p[<span class="number">0</span>] + <span class="number">1</span>));	</span><br><span class="line"><span class="comment">//原理和（p + 1）一样</span></span><br></pre></td></tr></table></figure>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = </span><br><span class="line">   &#123;</span><br><span class="line">	&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">	&#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">	&#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));	</span><br><span class="line"><span class="comment">//数组中有12 个int类型的元素，48个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//a[0][0]类型为int，四个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>])); </span><br><span class="line"><span class="comment">//类型为int[4]，一个int[4]是16个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//a[0] + 1 类型为int* ，指针，32位系统下4个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="comment">//a[0] + 1 类型为int* ,解引用后得到int类型，占四个字节（等价于a[0][1]）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)); </span><br><span class="line"><span class="comment">//&amp;a[0]类型为int(*)[4]，加一之后还是数组指针，32位系统下占四个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="comment">//&amp;a[0]类型为int(*)[4]，加一之后还是数组指针，解引用后类型为int[4]，大小为16个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="comment">//*a类型为int[4],16个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">100</span>]));</span><br><span class="line"><span class="comment">//16，编译器编译时根据arr[100]的除了它的类型是int[4]，在运行的时候直接打印的是sizeof的计算结果，即 16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对于sizeof和strlen来说，要时刻注意输入参数的类型，有时候多一个符号或少一个符号就会发生隐式转换，sizeof来者不拒，各种类型都能算，但是strlen不一样，它的输入参数只能是char* （它就是一个求字符串长度的库函数，不要太为难它了）。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>题目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的文件操作</title>
    <url>/2020/03/20200322.html</url>
    <content><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul>
<li>文件一般存储在外存（硬盘、光盘、U盘等）当中，而非内存中，文件可以分为文本文件以及二进制文件，其中文本文件保存的内容是字符串，而二进制文件保存的内容是二进制数据，每个文件末尾都有一个结束符，称之为<strong>EOF</strong>。</li>
<li>文件是通过操作系统进行管理的，每个文件都有一个独一无二的名字，文件的完整路径可分为绝对路径和相对路径。绝对路径是指从盘符开始一直到文件所在位置的目录的集合，而相对路径则以当前工作目录为基准，找到一个对应文件，想要用代码操作文件，需要先知道文件的路径。</li>
</ul>
<span id="more"></span>
<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><p>缓冲区就是一个内存区域，由于CPU读取内存的速度较快，而读取外存速度较慢，为了提高效率，就应尽量减少访问外存的次数，由此设立了缓冲区。在读取数据时，先将外存中的数据拷贝至内存（缓冲区），然后程序再由缓冲区进行数据读取，反之，将数据放入缓冲区，然后再写入外存。缓冲区在文件操作的过程中起到了至关重要的作用。</p>
<h1 id="文件的打开和关闭（fopen、fclose）"><a href="#文件的打开和关闭（fopen、fclose）" class="headerlink" title="文件的打开和关闭（fopen、fclose）"></a>文件的打开和关闭（fopen、fclose）</h1><p>文件在读写之前应该先<strong>打开文件</strong>，在使用结束之后应该<strong>关闭文件</strong>，在打开文件的同时，会返回一个FILE* 的指针变量指向该文件，也相当于建立了指针和文件的关系。fopen函数和fclose函数在打开或关闭文件失败时，都会返回一个空指针NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIlE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE* stream)</span>;</span><br><span class="line"><span class="comment">//fopen函数和fclose函数</span></span><br></pre></td></tr></table></figure>
<p>对于fopen函数，它的第一个参数是文件名，在传参时应输入文件的绝对路径或相对路径，第二个参数是文件的使用方式，具体如下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件使用方式</th>
<th>含义</th>
<th>如果指定文件不存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>“r”（只读）</td>
<td>为了输入数据，打开一个已经存在的文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w”（只写）</td>
<td>为了输出数据，打开一个文本文件</td>
<td>建立一个新的文件</td>
</tr>
<tr>
<td>“a”（追加）</td>
<td>向文本文件尾添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“rb”（只读）</td>
<td>为了输入数据，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb”（只写）</td>
<td>为了输出数据，打开一个二进制文件</td>
<td>建立一个新的文件</td>
</tr>
<tr>
<td>“ab”（追加）</td>
<td>向一个二进制文件尾添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“r+”（读写）</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w+”（读写）</td>
<td>为了读和写，建议一个新的文件</td>
<td>建立一个新的文件</td>
</tr>
<tr>
<td>“a+”（读写）</td>
<td>打开一个文件，在文件尾进行读写</td>
<td>建立一个新的文件</td>
</tr>
<tr>
<td>“rb+”（读写）</td>
<td>为了读和写打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb+”（读写）</td>
<td>为了读和写，新建一个新的二进制文件</td>
<td>建立一个新的文件</td>
</tr>
<tr>
<td>“ab+”（读写）</td>
<td>打开一个二进制文件，在文件尾进行读和写</td>
<td>建立一个新的文件</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，<strong>在使用fopen和fclose函数是，需要对返回值进行判空，以避免文件打开失败却又继续运行程序的情况。</strong></p>
<h1 id="字符输入-输出函数（fgetc-fputc）"><a href="#字符输入-输出函数（fgetc-fputc）" class="headerlink" title="字符输入/输出函数（fgetc/fputc）"></a>字符输入/输出函数（fgetc/fputc）</h1><p>使用fgetc来读取一个字符，使用fputc来输出一个字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE* stream )</span>;</span><br><span class="line"><span class="comment">//字符输入函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE* stream )</span>;</span><br><span class="line"><span class="comment">//字符输出函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span>(c = fgetc(<span class="built_in">stdin</span>) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">    fputc(c, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当返回值为EOF时表示读取到文件结束符</span></span><br><span class="line"><span class="comment">//stdin:标准输入，从键盘输入到缓冲区</span></span><br><span class="line"><span class="comment">//stdout:标准输出，输出到屏幕</span></span><br></pre></td></tr></table></figure>
<h1 id="文本行输入-输出函数（fgets-fputs）"><a href="#文本行输入-输出函数（fgets-fputs）" class="headerlink" title="文本行输入/输出函数（fgets/fputs）"></a>文本行输入/输出函数（fgets/fputs）</h1><p>使用fgets读取一行内容，使用fputs写入一行内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">( <span class="type">char</span>* <span class="built_in">string</span>, <span class="type">int</span> n, FILE* stream )</span>;</span><br><span class="line"><span class="comment">//三个参数分别是读取之后存放的位置，读取多少个字节，文件指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>, FILE* stream )</span>;</span><br><span class="line"><span class="comment">//两个参数分别是缓冲区地址和文件指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, fp) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//把文件中的内容按行读取到buf中</span></span><br><span class="line"> <span class="comment">//减一是为了留出‘\0’的位置</span></span><br><span class="line"> <span class="comment">//当返回值为NULL时，表示读到了EOF</span></span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="格式化输入-输出函数（fscanf-fprintf）"><a href="#格式化输入-输出函数（fscanf-fprintf）" class="headerlink" title="格式化输入/输出函数（fscanf/fprintf）"></a>格式化输入/输出函数（fscanf/fprintf）</h1><p>格式化的读写方式，用法类似scanf和printf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format [, argument ]... )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format [, argument ]...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%S&quot;</span>, buf);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br></pre></td></tr></table></figure>
<h1 id="二进制输入-输出函数（fread-fwrite）"><a href="#二进制输入-输出函数（fread-fwrite）" class="headerlink" title="二进制输入/输出函数（fread/fwrite）"></a>二进制输入/输出函数（fread/fwrite）</h1><p>使用fread读取n个字节，使用fwrite写入n个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">( <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream )</span>;</span><br><span class="line"><span class="comment">//返回值为实际读取到的元素个数。实际读取到的元素个数如果比预期的少，说明文件读取完毕</span></span><br><span class="line"><span class="comment">//参数分别为，缓冲区地址，每次读取的字节数，要写入缓存区的最大字节数，文件指针</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">( <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream )</span>;</span><br><span class="line"><span class="comment">//参数含分别为缓冲区地址，每次写入的字节数，最大写入字节数，文件指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> n = fread(buf, <span class="number">1</span>, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, fp);</span><br><span class="line"><span class="comment">//减去一是为了留下‘\0’的位置</span></span><br><span class="line">fwrite(buf, <span class="number">1</span>, <span class="built_in">strlen</span>(buf), <span class="built_in">stdout</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在文件的操作这一方面，各种编程语言的操作方式都大同小异，需要先打开文件，进行读写，最后关闭文件，需要注意的就是在打开文件后记得要关闭，否则可能会导致文件出错。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的自定义类型（结构体、枚举及联合）</title>
    <url>/2020/03/20200313.html</url>
    <content><![CDATA[<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是一些值的集合，这些值被称为成员变量，结构的每个成员可以是不同类型的变量。</p>
<span id="more"></span>
<h3 id="结构体的声明"><a href="#结构体的声明" class="headerlink" title="结构体的声明"></a>结构体的声明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">piont</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;p1;<span class="comment">//声明结构体类型，同时定义变量p1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p2</span>;</span><span class="comment">//定义结构体变量p2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p3</span> =</span> &#123;x, y&#125;;<span class="comment">//初始化：定义变量同时赋值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>* <span class="title">p4</span>;</span><span class="comment">//定义结构体类型指针</span></span><br></pre></td></tr></table></figure>
<p>结构体在声明的时候可以省略结构体标签（tag），称之为匿名结构体，但很少会用到。<br>结构体可以使用 \{ \}初始化，但不能用它赋值。</p>
<h3 id="结构体的成员访问"><a href="#结构体的成员访问" class="headerlink" title="结构体的成员访问"></a>结构体的成员访问</h3><p>结构体变量访问成员，通过（.）操作符来访问。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p1.x = <span class="number">20</span>;</span><br><span class="line">p1.y = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>结构体指针访问指向变量的成员,使用( -&gt; )操作符来访问<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, p4-&gt;x, p4-&gt;y);</span><br></pre></td></tr></table></figure>
<p>结构体可以自引用，但是只能通过包含自身类型的指针这种方式来自引用。</p>
<h2 id="结构体的内存对齐"><a href="#结构体的内存对齐" class="headerlink" title="结构体的内存对齐"></a>结构体的内存对齐</h2><p><strong>结构体的内存对齐规则：</strong></p>
<ol>
<li>第一个成员在与结构体变量偏移量为 0 的地址处。</li>
<li>其他成员变量要对齐到某个数字（称之为对齐数）的整数倍地址处。</li>
<li>结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。</li>
<li>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍</li>
</ol>
<blockquote>
<p><strong>对齐数：</strong> 编译器默认的一个对齐数，与该成员大小的 <strong>较小值</strong></p>
<hr>
<ul>
<li>VS中默认的对齐数值为8。</li>
<li>Linux没有默认对齐数，它的默认对齐数等于当前字段的sizeof值。</li>
<li>可以用 #pragma pack ( )来修改默认对齐数，如果括号内不填写数字，则 还原成默认对齐数。</li>
</ul>
</blockquote>
<p>_<strong>举例一：</strong>_<br>（VS2013下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> a;<span class="comment">//1 字节</span></span><br><span class="line">	<span class="type">int</span> b;<span class="comment">//4 字节</span></span><br><span class="line">	<span class="type">double</span> c;<span class="comment">//8 字节</span></span><br><span class="line">	<span class="type">char</span> d;<span class="comment">//1 字节</span></span><br><span class="line">	<span class="type">short</span> e;<span class="comment">//2 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于该结构体类型来说，它占据内存空间大小的计算方法是：</p>
<ol>
<li>根据第一条规则，对第一个成员变量，它在与结构体变量偏移量为0的地址处，此时算上一个字节。</li>
<li>根据第二条规则，对第二个成员，它是int类型变量，4个字节，与最大对齐数8相比，4更小，所以该成员的对齐数是4，要放在4的整数倍地址处，此时第一个成员占据的第一个字节之后的三个字节被开辟，在距离结构体变量偏移为4的地址处算四个字节，此时结构体变量有八个字节。<br><img src="https://img-blog.csdnimg.cn/20200313153047129.png" alt="前两个成员"></li>
</ol>
<blockquote>
<p>前两个成员</p>
</blockquote>
<ol>
<li>根据第二条规则，对于第三个成员，double类型，八个字节，与默认对齐数相等，所以对齐数取8，它放在8的整数倍地址上，即放在距离结构体变量偏移为8的地址处，此时结构体变量有16个字节。<br><img src="https://img-blog.csdnimg.cn/20200313153700911.png" alt="前三个成员"></li>
</ol>
<blockquote>
<p>前三个成员</p>
</blockquote>
<ol>
<li>根据第二条规则，第四个成员，char类型，一个字节，同上，它的对齐数是 1，所以直接放置即可，此时结构体变量有17个字节</li>
<li>根据第二条规则，第五个成员，类型是short，两个字节，同上，它的对齐数是2，放在地址是二的整数倍处,即第18个字节处，此时结构体变量为20个字节<br><img src="https://img-blog.csdnimg.cn/20200313155450248.png" alt="所有成员"></li>
</ol>
<blockquote>
<p>所有的五个成员</p>
</blockquote>
<ol>
<li>根据第三条规则：结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍，这个结构体的最大对齐数是8，那么它占据的内存应该是八的整数倍，此时20个字节，补齐到24个字节即为八的整数倍<br><img src="https://img-blog.csdnimg.cn/20200313155958775.png" alt="结构体全貌"></li>
</ol>
<p>所以，在举例一种，该结构体的大小为24个字节。</p>
<p>_<strong>举例二：</strong>_<br>求此时struct s2 结构体类型的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">double</span> c;</span><br><span class="line">	<span class="type">char</span> d;</span><br><span class="line">	<span class="type">short</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s</span> <span class="title">b</span>;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据第一条规则，对第一个成员变量，它在与结构体变量偏移量为0的地址处，此时算上一个字节。</li>
<li>根据第四条规则，如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍，结构体s中的最大对齐数是8，那么就要对齐到八的整数倍地址处，此时第一个字节往后开辟七个字节之后，来存放该结构体类型变量，这个结构体类型变量的大小在举例一中计算过，24个字节，所以此时s2为32个字节。<br><img src="https://img-blog.csdnimg.cn/20200313161457391.png" alt="前两个成员"></li>
</ol>
<blockquote>
<p>前两个成员</p>
</blockquote>
<ol>
<li>根据第二条规则，第三成员是char类型，1个字节，对齐数为1，所以此时结构体s2为33个字节。</li>
<li>根据第二条规则，第四成员为int类型，四个字节，对齐数为4，对齐到4的整数倍地址处，即第36个字节处，此时结构体大小为40字节。</li>
<li>根据第三条规则，该结构体各个成员中最大对齐数是八，所以它占据的内存应为八的整数倍，而40正好是八的整数倍，所以不用补齐</li>
</ol>
<p>所以举例二中结构体类型的大小应为40字节。</p>
<h2 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h2><p>位段的声明和结构体类似，但是位段的成员必须是int 、unsigned int或signed int，位段的成员后有一个冒号和一个数字。冒号后的数字是几，就说明前边的成员变量占几个<strong>比特位</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a : <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b : <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> c : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>将可能的取值一一列举，即为枚举</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	spring,</span><br><span class="line">	summer,</span><br><span class="line">	autumn,</span><br><span class="line">	winter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举常量的值默认由0开始依次递增，除非在声明中赋值</p>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>该类型定义的变量包含一系列成员，但是这些成员都公用同一块内存空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以用它的特性来判断大小端字节序，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">s</span>;</span></span><br><span class="line">	s.a = <span class="number">0x11223344</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, s.b);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//输出为44，当前机器为小端字节序。</span></span><br></pre></td></tr></table></figure>
<p><strong>联合的大小：</strong></p>
<ul>
<li>联合的大小至少是最大成员的大小</li>
<li>当最大成员的大小不是最大对齐数的整数倍时，要对齐到最大对齐数的整数倍上。</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言实现一个简单的通讯录程序</title>
    <url>/2020/03/20200328.html</url>
    <content><![CDATA[<p>一个合格的通讯录，应该支持增、删、查、改这四个基本操作，同时，我在这个通讯录中也运用了内存的动态管理与文件操作的知识，同时这个通讯录可以支持按照联系人姓名进行排序。</p>
<span id="more"></span>
<p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/%E9%80%9A%E8%AE%AF%E5%BD%95">GitHub链接</a></p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PersonalInfo</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//单个联系人的信息</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> age[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> phone[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">char</span> address[<span class="number">1024</span>];</span><br><span class="line">&#125;PersonalInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AddressBook</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//通讯录</span></span><br><span class="line">	PersonalInfo* persons;</span><br><span class="line">	<span class="type">int</span> size;<span class="comment">//通讯录当前的大小</span></span><br><span class="line">	<span class="type">int</span> nums;<span class="comment">//通讯录的上限</span></span><br><span class="line">&#125;AddressBook;</span><br><span class="line"></span><br><span class="line">AddressBook address_book;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relloc_Per</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//扩容</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span>;<span class="comment">//菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add_Person_Info</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//增加联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Del_Person_Info</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//删除联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Find_Person_Info</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//查找联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Modify_Person_Info</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//修改联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print_Person_Info</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//打印通讯录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear_Person_Info</span><span class="params">(AddressBook* addr)</span>;<span class="comment">//清空通讯录</span></span><br></pre></td></tr></table></figure>
<h2 id="通讯录main函数部分"><a href="#通讯录main函数部分" class="headerlink" title="通讯录main函数部分"></a>通讯录main函数部分</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;AddressBook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Open</span><span class="params">(AddressBook* addr)</span><span class="comment">//从本地中打开通讯录</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* addbook = fopen(<span class="string">&quot;C:book.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (addbook == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;文件打开失败！&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PersonalInfo buf = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (fread(&amp;buf, <span class="keyword">sizeof</span>(PersonalInfo), <span class="number">1</span>, addbook))</span><br><span class="line">	&#123;</span><br><span class="line">		addr-&gt;persons[addr-&gt;size] = buf;</span><br><span class="line">		addr-&gt;size++;</span><br><span class="line">		<span class="keyword">if</span> (addr-&gt;size &gt;= addr-&gt;nums)</span><br><span class="line">		&#123;</span><br><span class="line">			Relloc_Per(addr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(addbook);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Close</span><span class="params">(AddressBook* addr)</span><span class="comment">//关闭程序时保存通讯录</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* addbook = fopen(<span class="string">&quot;C:book.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (addbook == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;文件打开失败！&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; addr-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fwrite((addr-&gt;persons + i), <span class="keyword">sizeof</span>(PersonalInfo), <span class="number">1</span>, addbook);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(addbook);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Init(&amp;address_book);<span class="comment">//初始化通讯录</span></span><br><span class="line">	Open(&amp;address_book);<span class="comment">//打开本地文件</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*Func)</span><span class="params">(AddressBook*)</span>;<span class="comment">//函数指针</span></span><br><span class="line">	Func function[] = <span class="comment">//函数指针数组</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="literal">NULL</span>,<span class="comment">//此处为了和menu的返回值匹配，将function[0]的内容写成NULL</span></span><br><span class="line">		Add_Person_Info,</span><br><span class="line">		Del_Person_Info,</span><br><span class="line">		Find_Person_Info,</span><br><span class="line">		Modify_Person_Info,</span><br><span class="line">		Print_Person_Info,</span><br><span class="line">		Clear_Person_Info</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> choice = menu();</span><br><span class="line">		<span class="keyword">if</span> (choice == <span class="number">0</span>)</span><br><span class="line">		&#123;<span class="comment">//退出</span></span><br><span class="line">			Close(&amp;address_book);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;bye!\n\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (choice &lt; <span class="number">0</span> || choice &gt;= <span class="keyword">sizeof</span>(function) / <span class="keyword">sizeof</span>(function[<span class="number">0</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入错误！\n\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		function[choice](&amp;address_book);<span class="comment">//实现具体功能</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="功能函数部分"><a href="#功能函数部分" class="headerlink" title="功能函数部分"></a>功能函数部分</h2><h3 id="初始化以及菜单函数"><a href="#初始化以及菜单函数" class="headerlink" title="初始化以及菜单函数"></a>初始化以及菜单函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(AddressBook* addr)</span><span class="comment">//初始化通讯录</span></span><br><span class="line">&#123;</span><br><span class="line">	addr-&gt;size = <span class="number">0</span>;</span><br><span class="line">	addr-&gt;nums = <span class="number">20</span>;</span><br><span class="line">	addr-&gt;persons = (PersonalInfo*)<span class="built_in">malloc</span>((addr-&gt;nums) * <span class="keyword">sizeof</span>(PersonalInfo));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; addr-&gt;nums; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].name , <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].phone , <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].address  , <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].sex , <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].age, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span><span class="comment">//主菜单</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;============================\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  1.新建联系人\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  2.删除联系人\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  3.查询联系人\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  4.修改联系人\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  5.显示所有联系人\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  6.清空通讯录\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  0.退出\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;============================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序以及扩容部分"><a href="#排序以及扩容部分" class="headerlink" title="排序以及扩容部分"></a>排序以及扩容部分</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cmp</span><span class="params">(AddressBook* addr)</span> <span class="comment">//排序</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	PersonalInfo tmp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr-&gt;size - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; addr-&gt;size - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(addr-&gt;persons[j].name , addr-&gt;persons[j+<span class="number">1</span>].name) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;<span class="comment">//冒泡排序</span></span><br><span class="line">				tmp = addr-&gt;persons[j];</span><br><span class="line">				addr-&gt;persons[j] = addr-&gt;persons[j + <span class="number">1</span>];</span><br><span class="line">				addr-&gt;persons[j + <span class="number">1</span>] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Relloc_Per</span><span class="params">(AddressBook* addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	addr-&gt;nums += <span class="number">20</span>;</span><br><span class="line">	addr-&gt;persons = <span class="built_in">realloc</span>(addr-&gt;persons, (addr-&gt;nums) * <span class="keyword">sizeof</span>(PersonalInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增删查改联系人"><a href="#增删查改联系人" class="headerlink" title="增删查改联系人"></a>增删查改联系人</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Add_Person_Info</span><span class="params">(AddressBook* addr)</span><span class="comment">//新增联系人</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;size &gt;= addr-&gt;nums)</span><br><span class="line">	&#123;</span><br><span class="line">		Relloc_Per(addr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PersonalInfo* info = &amp;addr-&gt;persons[addr-&gt;size];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增联系人！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入联系人姓名：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, info-&gt;name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入联系人电话：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, info-&gt;phone);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入联系人性别：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, info-&gt;sex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入联系人年龄：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, info-&gt;age);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入联系人住址：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, info-&gt;address);</span><br><span class="line"></span><br><span class="line">	addr-&gt;size++;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增联系人成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;size &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cmp(addr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Del_Person_Info</span><span class="params">(AddressBook* addr)</span><span class="comment">//删除联系人</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;size &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;通讯录为空！无法执行删除！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;删除联系人！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的联系人序号：&quot;</span>);</span><br><span class="line">	<span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">	<span class="keyword">if</span> (input &lt; <span class="number">0</span> || input &gt;= addr-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;非法输入！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PersonalInfo* last_info = &amp;addr-&gt;persons[addr-&gt;size - <span class="number">1</span>];</span><br><span class="line">	PersonalInfo* to_delt = &amp;addr-&gt;persons[input];</span><br><span class="line">	*to_delt = *last_info;</span><br><span class="line">	addr-&gt;size--;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;联系人成功删除！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;size &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cmp(addr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Find_Person_Info</span><span class="params">(AddressBook* addr)</span><span class="comment">//查找联系人</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> find[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;查找联系人！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入想要查找的姓名或联系方式：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;find);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; addr-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		PersonalInfo* findinfo = &amp;addr-&gt;persons[i];</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(find, findinfo-&gt;name) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;找到了！该联系人编号为：%d\n&quot;</span>, i);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(find, findinfo-&gt;phone) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n找到了！该联系人为：[%d]  姓名：%s   联系方式：%s\n&quot;</span>, i,findinfo-&gt;name,findinfo-&gt;phone);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;查无此人！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Modify_Person_Info</span><span class="params">(AddressBook* addr)</span><span class="comment">//修改联系人信息</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;size &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;通讯录为空！无法执行！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> age[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> phone[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">char</span> address[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;修改联系人信息！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的联系人编号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;addr-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入非法！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PersonalInfo* info = &amp;addr-&gt;persons[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%d]  姓名：%s   联系方式：%s \n     性别： %s  年龄： %s\n     住址：%s\n\n&quot;</span>, i, info-&gt;name, info-&gt;phone, info-&gt;sex, info-&gt;age, info-&gt;address);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的姓名（输入 * 表示不进行修改）：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name , <span class="string">&quot;*&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].name, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的性别（输入 * 表示不进行修改）：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, sex);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(sex, <span class="string">&quot;*&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].sex, sex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的年龄（输入 * 表示不进行修改）：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, age);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(age, <span class="string">&quot;*&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].age, age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的联系方式（输入 * 表示不进行修改）：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, phone);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(phone, <span class="string">&quot;*&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].phone, phone);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的地址（输入 * 表示不进行修改）：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, address);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(address, <span class="string">&quot;*&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(addr-&gt;persons[i].address, address);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;修改成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;size &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cmp(addr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印以及清空"><a href="#打印以及清空" class="headerlink" title="打印以及清空"></a>打印以及清空</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Print_Person_Info</span><span class="params">(AddressBook* addr)</span><span class="comment">//输出联系人（全部）</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;显示所有联系人：\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; addr-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		PersonalInfo* info = &amp;addr-&gt;persons[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d]  姓名：%s   联系方式：%s \n     性别： %s  年龄： %s\n     住址：%s\n\n&quot;</span>, i,info-&gt;name ,info-&gt;phone,info-&gt;sex,info-&gt;age,info-&gt;address );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n到底了...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear_Person_Info</span><span class="params">(AddressBook* addr)</span><span class="comment">//一键清空</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> clear[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n清空通讯录！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请确认是否清空  (Y/N)\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, clear);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(clear, <span class="string">&quot;Y&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(clear, <span class="string">&quot;y&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//addr-&gt;size = 0;</span></span><br><span class="line">		Init(addr);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成功清空通讯录！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;放弃清空\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，一个简单的通讯录就可以实现啦。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>小作品</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言关于指针的几道面试题（烧脑预警）</title>
    <url>/2020/03/20200306.html</url>
    <content><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* ptr = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这道题中，* (a + 1)即相当于a[ 1 ]，此时a即为首地址元素<br>\&amp;a则取到一个类型为inr( * )[5]的指针，此时再用（int*）强制转化成int *指针所以此时指针 ptr 指向数组a最后一个元素之后的一个int类型元素的地址。在输出的时候，解引用（a+1）即为a[1] = 2，解引用（ptr-1）即为a[4]=5。</p>
<span id="more"></span>
<h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> Num;</span><br><span class="line">	<span class="type">char</span> *pcName;</span><br><span class="line">	<span class="type">short</span> sDate;</span><br><span class="line">	<span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line">	<span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> Test*)<span class="number">0x100000</span>;</span><br><span class="line">	<span class="comment">//声明一个指针p，它指向内存中0x100000这个地址，它的类型是（struct Test*）</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这道题中需要注意的是结构体struct Test大小为20字节<br>第一个输出中p + 0x1即为p指向的地址跳过一个结构体struct Test的字节大小（20个字节）而\%p是打印当前指针指向的地址，即按照16位进制输出，所以结果为00100014<br>第二个输出中（unsigned long）则将p由指针强制转换成了一个整数，此时再加0x1并按16位进制输出，结果为00100001<br>第三个输出中（unsigned int* ）将p强制转换成unsigned int* 类型的指针，此时加0x1，跳过四个字节，所以输出为00100004</p>
<h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> *ptr2 = (<span class="type">int</span> *)((<span class="type">int</span>)a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x&quot;</span>, ptr1[<span class="number">-1</span>], *ptr2);</span><br><span class="line">	<span class="comment">//%x是按照16进制输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这道题中ptr[-1]即为*（ptr - 1），\&amp;a取到一个类型为int（*）[4]的指针，随后强制转换成int *指针此时减一再解引用即为数组a[3]处的元素，为4。<br>（int *）（（int）a + 1）的理解比较有难度，我们知道 a 在此处表示的是数组元素的首地址，在上式中已经隐式转换成一个int * 类型的指针，此时强制转换成int类型再加一，相当于整数加一，接着再强制转换成int *类型，所以 ptr2 实际指向的位置是数组第一个元素的后三个字节加上第二个元素的第一个字节（int类型数组中一个元素四个字节，转换成整数加一后只跳过了一个字节）假设机器为32为系统，小端字节序，那么数组前两个元素在内存中的排布为 a [0]：01 00 00 00、a[1]：02 00 00 00，那么ptr2实际指向的元素在内存中的排列是 00 00 00 02，解引用后按照16进制输出即为<br>2 00 00 00。</p>
<h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>) &#125;;</span><br><span class="line">	<span class="comment">//由于逗号表达式的作用，实际上数组只输入了1，3，5三个数字</span></span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	p = a[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于二维数组a[ 3 ][ 2 ]来说，a[ 0 ]取到了包含两个元素的一维数组的首地址它包含的元素是1，3。另指针p指向它，再输出p[ 0 ]，即为输出一维数组a[0]的首元素也就是二维数组a的首元素，也就是数字 1。</p>
<h1 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];	<span class="comment">// 二维数组</span></span><br><span class="line">	<span class="type">int</span>(*p)[<span class="number">4</span>];		<span class="comment">// 数组指针</span></span><br><span class="line">	p = a;  <span class="comment">//类型不匹配，严格来说编译不会通过，然而。。。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p,%d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">//%p用来打印地址，此处意为输出16进制数字</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p是一个int（*）[4]类型的指针，p = a之后，每一个p指针指向数组a中的四个元素，可以看成两个每一个格子都错开，但整体上看又对齐的尺子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a[0][0]</th>
<th>a[0][1]</th>
<th>a[0][2]</th>
<th>a[0][3]</th>
<th>a[0][4]</th>
</tr>
</thead>
<tbody>
<tr>
<td>p[0][0]</td>
<td>p[0][1]</td>
<td>p[0][2]</td>
<td>p[0][3]</td>
<td>p[1][0]</td>
</tr>
</tbody>
</table>
</div>
<p>类似以上表格形式<br>那么p[4][2]指向内存中的元素就是a[ 3 ] [ 2 ]，在输出中，二者同时取地址再相减，实际上算出来的是他们之间相隔几个int 类型元素（此时二者已经隐式转换成了int* 类型的指针），二者之间相隔-4个int类型元素，所以最终输出结果是FFFFFFFC，-4</p>
<h1 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> aa[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">	<span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;aa + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> *ptr2 = (<span class="type">int</span> *)(*(aa + <span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, *(ptr1 - <span class="number">1</span>), *(ptr2 - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>\&amp;aa是一个类型为int（*）[2][5]类型的数组指针，指向整个数组，此时加一，跳过整个数组，再（int *）强制转换成int *类型指针，它此时指向数组a的最后一个元素的后边四个字节。输出的时候减去一再解引用，也就是输出数组a的最后一个元素，10 。<br>*（aa + 1）等价于aa[ 1 ]，此处被隐式转换成一个int（ * ）[5]的指针，接着（int *）将它强制转换成一个int *类型指针，其指向数组中下标为【1】【0】的元素，也就是6，输出的时候减一再解引用，输出的就是6之前的一个元素，也就是5。</p>
<h1 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* a[] = &#123; <span class="string">&quot;work&quot;</span>, <span class="string">&quot;at&quot;</span>, <span class="string">&quot;alibaba&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//表示有一个数组，其中的元素都是指且指向char类型的数据</span></span><br><span class="line">	<span class="type">char</span>** pa = a;</span><br><span class="line">	pa++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *pa);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pa是一个二级指针，它指向了一个指针数组a的首元素（这个首元素是一个指针，它指向位于常量区的“work\\0”的首地址），在pa进行自加运算后，pa指向了数组a中的第二个元素，而第二个元素也是指针，指向位于常量区的字符串“at\\0”的首地址，对pa解引用之后，得到了字符串“at\\0”的首元素地址，用\%s进行输出（\%s从当前地址开始输出字符直到遇到\\0），所以最终输出结果是 at</p>
<h1 id="最终题"><a href="#最终题" class="headerlink" title="最终题"></a>最终题</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* c[] = &#123; <span class="string">&quot;ENTER&quot;</span>, <span class="string">&quot;NEW&quot;</span>, <span class="string">&quot;POINT&quot;</span>, <span class="string">&quot;FIRST&quot;</span> &#125;;</span><br><span class="line">	<span class="comment">//c是一个数组，其中每个元素都是指针，分别指向四个字符串的首地址</span></span><br><span class="line">	<span class="type">char</span>** cp[] = &#123; c + <span class="number">3</span>, c + <span class="number">2</span>, c + <span class="number">1</span>, c &#125;;</span><br><span class="line">	<span class="comment">//cp是一个数组，它的首元素（每个元素都是二级指针）指向数组c中指向字符</span></span><br><span class="line">	<span class="comment">//串“FIRST”首地址的指针元素，它的最后一个元素则指向数组c中的首元素</span></span><br><span class="line">	<span class="comment">//依此类推（也就是颠倒数组c）</span></span><br><span class="line">	<span class="type">char</span>*** cpp = cp;</span><br><span class="line">	<span class="comment">//cpp是一个三级指针，它指向数组cp的首元素地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp + <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>] + <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第一个输出"><a href="#第一个输出" class="headerlink" title="第一个输出"></a>第一个输出</h2><p>单目运算符运算顺序从右到左，cpp本来指向cp中的第一个元素，再进行自加之后指向的是cp中的第二个元素（指针自加直接跳过一个元素），第一次解引用得到 c + 2，它是一个指针指向数组c中的第三个元素，而数组c中的第三个元素是一个指向位于常量区字符串“POINT\\0”的指针，再次解引用之后进行输出，即输出了该字符串，最终输出结果是 POINT。</p>
<h2 id="第二个输出"><a href="#第二个输出" class="headerlink" title="第二个输出"></a>第二个输出</h2><p>++ 在上一个输出中cpp已经自加了一次，此时再进行自加，它指向了数组cp中的第三个元素，也就是 c + 1</p>
<p>第一个 * 在cpp解引用之后得到了指针 c + 1，它指向了数组c中的第二个元素，也就是指向字符串“NEW\\0”的那个指针</p>
<p>在自减运算之后，此刻得到了一个指向数组c中第一个元素的指针，这里不用管数组cp是怎么排列的，上一步运算中我们得到了指向数组c中第二个元素地址的指针，自减后自然得到的是数组c中指向第一个元素的指针。</p>
<p>第二次解引用之后，得到了数组c中第一个元素的内容，是一个指向字符串“ENTER\\0”的指针</p>
<p>+3 此时的加三意味着跳过三个char类型的数据，也就是“ER\\0”，所以最后的输出结果是ER。</p>
<h2 id="第三个输出"><a href="#第三个输出" class="headerlink" title="第三个输出"></a>第三个输出</h2><p>cpp[-2]即为*（cpp - 2），在这一步操作之后，得到了数组cp中的第一个元素（此前cpp指向数组cp中的第三个元素），它是一个指针，指向数组c中的最后一个元素</p>
<p>再对cpp[-2]解引用操作之后，得到了数组c中的最后一个元素，这个元素是一个指针，指向字符串“FIRST\\0”的首地址</p>
<p>+3 之后，跳过三个char类型元素，进行输出，最后结果是 ST</p>
<h2 id="第四个输出"><a href="#第四个输出" class="headerlink" title="第四个输出"></a>第四个输出</h2><p>cpp[ -1 ][ -1 ]即为*（*（cpp -1）-1）</p>
<p>cpp - 1再解引用得到了数组cp中的第二个元素c+2（此前cpp指向数组cp中的第三个元素），他是一个指针，指向数组 c 中的第三个元素</p>
<p>再次减一并解引用 上一步操作中已经得到了指向数组 c 第三个元素的指针，在减一之后，得到了指向数组c中第二个元素的指针，解引用之后得到了数组c中第二个元素的内容</p>
<p>加一即跳过一个char型元素，所以最终输出结果是EW</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>指针是一个比较容易搞混淆的概念，在感到困惑的时候，不妨画张图来表示内存与指针，搞清楚指针的指向和内容，这样结果会更加清晰明了</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>题目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现三子棋游戏(也实现N子棋)</title>
    <url>/2019/12/20191228.html</url>
    <content><![CDATA[<h3 id="这是我作为一个初学者第一次尝试搞出来的东西，它不但可以实现三子棋游戏，通过修改-define的定义，还可以实现N子棋游戏。"><a href="#这是我作为一个初学者第一次尝试搞出来的东西，它不但可以实现三子棋游戏，通过修改-define的定义，还可以实现N子棋游戏。" class="headerlink" title="这是我作为一个初学者第一次尝试搞出来的东西，它不但可以实现三子棋游戏，通过修改#define的定义，还可以实现N子棋游戏。"></a>这是我作为一个初学者第一次尝试搞出来的东西，它不但可以实现三子棋游戏，通过修改#define的定义，还可以实现N子棋游戏。</h3><h4 id="首先，分析该游戏需要的逻辑"><a href="#首先，分析该游戏需要的逻辑" class="headerlink" title="首先，分析该游戏需要的逻辑"></a>首先，分析该游戏需要的逻辑</h4><span id="more"></span>
<ol>
<li>作为一个游戏，它首先需要有一个用户菜单，让用户选择开始或选择退出游戏，故需使用一个do while循环（需要在程序的一开始就显示菜单，并且在正常游戏流程结束时再次让玩家选择继续或者退出）来显示菜单并接收用户的输入，以此判断玩家是否玩游戏。</li>
<li>在玩家选择退出游戏是跳出循环，若玩家选择开始游戏，则进入游戏函数（game）。</li>
<li>作为一个下棋游戏，应该先让其显示棋盘，接着让玩家选择棋子的坐标位置（这里需要一个二维数组），然后电脑方利用头文件stdlib.h头文件、srand以及rand函数来生成一个随机坐标值。</li>
<li>利用二维数组将对应的坐标位置填入玩家或电脑的棋子，并在每次填入后打印此时的棋盘供玩家观察。</li>
<li>此时已完成了怎么下棋的问题，我自己在做的时候觉得判断输赢是最难的部分，我利用了四个循环来判断连行、连列、左上至右下以及右上至左下。</li>
<li>此时游戏基本完成，只需将各个函数按顺序连接起来即可。</li>
</ol>
<h2 id="以下是代码部分"><a href="#以下是代码部分" class="headerlink" title="以下是代码部分"></a>以下是代码部分</h2><p>首先，在头文件中写入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 3<span class="comment">//修改此处可实现N子棋</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Player</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row ,<span class="type">int</span> col)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Computer</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">IsWin</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上均为函数声明，而游戏程序的主函数我也在以下写出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;game.h&quot;</span><span class="comment">//头文件名</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));<span class="comment">//随机数种子</span></span><br><span class="line">	menu();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上边，利用头文件stdlib.h，srand函数，rand函数生成随机数。<br>menu函数内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;****** 1.PLAY *****\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;****** 0.EXIT *****\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">		<span class="keyword">if</span> (input == <span class="number">1</span>)</span><br><span class="line">			game();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (input == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;退出游戏\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;非法输入\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行游戏则进入game函数，如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> board[ROW][COL] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> ret = <span class="number">0</span>;</span><br><span class="line">	InitBoard(board, ROW, COL);</span><br><span class="line">	PrintBoard(board, ROW, COL);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Player(board, ROW, COL);</span><br><span class="line">		PrintBoard(board, ROW, COL);</span><br><span class="line">		ret = IsWin(board, ROW, COL);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		Computer(board , ROW, COL);</span><br><span class="line">		PrintBoard(board, ROW, COL);</span><br><span class="line">		ret = IsWin(board, ROW, COL);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;玩家赢！\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;电脑赢！\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建棋盘函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			board[i][j] = <span class="string">&#x27; &#x27;</span>;<span class="comment">//在其中输入空格字符</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印棋盘函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; %c &quot;</span>, board[i][j]);</span><br><span class="line">			<span class="keyword">if</span> (j &lt; col - <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">		&#125;<span class="comment">//打印竖着的 “ | ”</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; row - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;___&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (j &lt; col - <span class="number">1</span>)</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">			&#125;<span class="comment">//打印 &quot;__&quot;</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图<br><img src="https://img-blog.csdnimg.cn/20191228115022235.png" alt="打印好的棋盘"><br>用于接收玩家坐标并下对应棋子的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Player</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;玩家走\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要走的坐标： &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= ROW &amp;&amp; y &lt;= COL &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (board[x - <span class="number">1</span>][y - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				board[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="string">&#x27;*&#x27;</span>;<span class="comment">//减去一是为了符合逻辑（大部分朋友会认为坐标是从1开始的，实际数组中是从零开始的）</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;坐标被占用！\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//需判断坐标是否存在或被占用</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;坐标非法！\n\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>电脑输入Computer函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Computer</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;电脑走： \n\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = rand() % row;</span><br><span class="line">		y = rand() % col;</span><br><span class="line">		<span class="keyword">if</span> (board[x][y] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			board[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断输赢函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">IsWin</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> Player = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> Computer = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> win = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= row)<span class="comment">//判断行</span></span><br><span class="line">	&#123;</span><br><span class="line">		Player = <span class="number">0</span>;</span><br><span class="line">		Computer = <span class="number">0</span>;</span><br><span class="line">		j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; (col - <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (board[i][j] == board[i][j + <span class="number">1</span>] &amp;&amp; board[i][j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">				Player++;</span><br><span class="line">			<span class="keyword">if</span> (board[i][j] == board[i][j + <span class="number">1</span>] &amp;&amp; board[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				Computer++;</span><br><span class="line">			<span class="keyword">if</span> (Player == (row - <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Computer == (row - <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">0</span>;</span><br><span class="line">	Player = <span class="number">0</span>;</span><br><span class="line">	Computer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= row)<span class="comment">//判断列</span></span><br><span class="line">	&#123;</span><br><span class="line">		Player = <span class="number">0</span>;</span><br><span class="line">		Computer = <span class="number">0</span>;</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; (col - <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (board[i][j] == board[i + <span class="number">1</span>][j] &amp;&amp; board[i][j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">				Player++;</span><br><span class="line">			<span class="keyword">if</span> (board[i][j] == board[i + <span class="number">1</span>][j] &amp;&amp; board[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				Computer++;</span><br><span class="line">			<span class="keyword">if</span> (Player == (row - <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Computer == (row - <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	Player = <span class="number">0</span>;</span><br><span class="line">	Computer = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*i = 0;</span></span><br><span class="line"><span class="comment">	j = 0;*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)<span class="comment">//斜左上至右下</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (board[i][i] == board[i + <span class="number">1</span>][i + <span class="number">1</span>] &amp;&amp; board[i][i] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">			Player++;</span><br><span class="line">		<span class="keyword">if</span> (board[i][i] == board[i + <span class="number">1</span>][i + <span class="number">1</span>] &amp;&amp; board[i][i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			Computer++;</span><br><span class="line">		<span class="keyword">if</span> (Player == (row - <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Computer == (row - <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Player = <span class="number">0</span>;</span><br><span class="line">	Computer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = (col - <span class="number">1</span>); i &lt; row, j &gt; <span class="number">0</span> ; i++ , j--)<span class="comment">//斜右上至左下</span></span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">if</span> (board[i][j] == board[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; board[i][j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">				Player++;</span><br><span class="line">			<span class="keyword">if</span> (board[i][j] == board[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; board[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				Computer++;</span><br><span class="line">			<span class="keyword">if</span> (Player == (row - <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Computer == (row - <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (board[i][j] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">				win++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (win == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">	    <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="至此程序已经基本完成，只需将各个函数有机的组合在一起即可，假如你想实现更多子棋，仅需将-define定义的行数列数修改即可。"><a href="#至此程序已经基本完成，只需将各个函数有机的组合在一起即可，假如你想实现更多子棋，仅需将-define定义的行数列数修改即可。" class="headerlink" title="至此程序已经基本完成，只需将各个函数有机的组合在一起即可，假如你想实现更多子棋，仅需将#define定义的行数列数修改即可。"></a>至此程序已经基本完成，只需将各个函数有机的组合在一起即可，假如你想实现更多子棋，仅需将#define定义的行数列数修改即可。</h4><h4 id="这里贴上工程文件"><a href="#这里贴上工程文件" class="headerlink" title="这里贴上工程文件"></a>这里贴上工程文件</h4><p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/%E4%B8%89%E5%AD%90%E6%A3%8B12_21">github 链接</a>.</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>小作品</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar消费者提交与消费机制小结</title>
    <url>/2025/05/20250505.html</url>
    <content><![CDATA[<h1 id="Pulsar消费者提交与消费机制小结"><a href="#Pulsar消费者提交与消费机制小结" class="headerlink" title="Pulsar消费者提交与消费机制小结"></a>Pulsar消费者提交与消费机制小结</h1><h2 id="消费偏移量与提交偏移量"><a href="#消费偏移量与提交偏移量" class="headerlink" title="消费偏移量与提交偏移量"></a>消费偏移量与提交偏移量</h2><p>Pulsar中消费者的消费偏移量（consumption offset）和提交偏移量（committed offset）并不是同一个概念。</p>
<ol>
<li>消费偏移量（Consumption Offset）<ul>
<li>消费偏移量指的是消费者当前正在消费的消息的偏移量。它表示消费者已经从消息流中读取到的位置。</li>
<li>消费偏移量是消费者在消费消息时记录的当前位置，但它并不一定意味着这些消息已经被处理完毕或确认。</li>
</ul>
</li>
<li>提交偏移量（Committed Offset）<ul>
<li>提交偏移量是消费者已经成功处理并确认的消息的偏移量。它表示消费者已经处理完这些消息，并且可以安全地认为这些消息不会被再次消费。</li>
<li>提交偏移量通常是通过消费者显式地调用提交偏移量的API来完成的，例如<code>acknowledge</code>或<code>commit</code>方法。</li>
</ul>
</li>
</ol>
<span id="more"></span>
<p><strong>区别：</strong></p>
<ul>
<li><strong>消费偏移量</strong>是消费者当前正在处理的消息的位置，而<strong>提交偏移量</strong>是消费者已经处理完毕并确认的消息的位置。</li>
<li>提交偏移量通常是消费偏移量的一个子集，表示已经处理完毕的消息。</li>
</ul>
<p><strong>在Pulsar默认情况下, 消费者进程不重启, 无论消费者以怎样的顺序提交消息, 都不会影响当前消费的偏移量</strong></p>
<h2 id="ackTimeout与DLQ"><a href="#ackTimeout与DLQ" class="headerlink" title="ackTimeout与DLQ"></a>ackTimeout与DLQ</h2><h3 id="1、ackTimeout-Pulsar消费者的配置项-默认情况下是关闭状态"><a href="#1、ackTimeout-Pulsar消费者的配置项-默认情况下是关闭状态" class="headerlink" title="1、ackTimeout - Pulsar消费者的配置项, 默认情况下是关闭状态"></a>1、ackTimeout - Pulsar消费者的配置项, <strong>默认情况下是关闭状态</strong></h3><ul>
<li><code>ackTimeout</code> 默认值为 <code>0</code><ul>
<li>如果 <code>ackTimeout</code> 未设置或设置为 <code>0</code>，Pulsar 不会自动重新投递未确认的消息。</li>
<li>这意味着，如果消费者消费了消息但没有提交确认（<code>ack</code>），这些消息会一直保留在消费者的未确认队列中，直到消费者显式地提交确认或重新投递。</li>
</ul>
</li>
<li>未确认消息的处理<ul>
<li>如果消费者一直不提交确认，未确认的消息会占用 Pulsar 的内存或磁盘资源（取决于 Pulsar 的存储模式）。</li>
<li>如果未确认的消息过多，可能会导致资源耗尽，影响系统性能。</li>
</ul>
</li>
</ul>
<p><strong>go语言的Pulsar客户端不支持该选项</strong></p>
<p>git Issues:</p>
<ul>
<li><a href="https://github.com/streamnative/pulsar-client-go/issues/44">https://github.com/streamnative/pulsar-client-go/issues/44</a></li>
<li><a href="https://github.com/apache/pulsar-client-go/pull/197">https://github.com/apache/pulsar-client-go/pull/197</a></li>
</ul>
<blockquote>
<ol>
<li><strong>Go客户端不支持ack timeout功能</strong>，这是有意为之的。</li>
<li><strong>negativeAck</strong>被认为是解决问题的首选方法，而<strong>ackTimeout</strong>被视为遗留功能。</li>
<li>未明确说明未来会支持该选项</li>
</ol>
</blockquote>
<h3 id="2、DLQ-Dead-Letter-Queue-死信队列"><a href="#2、DLQ-Dead-Letter-Queue-死信队列" class="headerlink" title="2、DLQ - Dead Letter Queue 死信队列"></a>2、DLQ - <strong>Dead Letter Queue</strong> 死信队列</h3><p>死信队列用于处理那些多次重试后仍然无法成功处理的消息。当消息的重试次数超过配置的最大重试次数时，Pulsar 会将这些消息发送到死信队列，避免无限重试。</p>
<p>go语言启用死信队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置死信队列策略</span></span><br><span class="line">deadLetterPolicy := pulsar.DeadLetterPolicy{</span><br><span class="line">    MaxRedeliverCount: <span class="number">3</span>, <span class="comment">// 最大重试次数, 如果消息的重试次数超过此值，Pulsar 会将消息发送到死信队列。</span></span><br><span class="line">    DeadLetterTopic:   <span class="string">"my-dead-letter-topic"</span>, <span class="comment">// 死信队列的 Topic, 如果未指定，Pulsar 会自动生成一个死信队列 Topic。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">consumer, err := client.Subscribe(pulsar.ConsumerOptions{</span><br><span class="line">    Topic:               <span class="string">"my-topic"</span>,</span><br><span class="line">    SubscriptionName:    <span class="string">"my-subscription"</span>,</span><br><span class="line">    Type:                pulsar.Shared,</span><br><span class="line">    DeadLetterPolicy:    &amp;deadLetterPolicy, <span class="comment">// 启用死信队列</span></span><br><span class="line">})</span><br></pre></td></tr></table></figure>
<p><strong>死信队列的工作流程</strong></p>
<ol>
<li>消息重试<ul>
<li>消费者消费消息后，如果处理失败，可以使用 <code>Nack</code> 或 <code>ackTimeout</code> 触发消息重试。</li>
<li>消息会被重新投递给消费者，直到达到 <code>MaxRedeliverCount</code> 指定的最大重试次数。</li>
</ul>
</li>
<li>发送到死信队列<ul>
<li>如果消息的重试次数超过 <code>MaxRedeliverCount</code>，Pulsar 会将消息发送到指定的死信队列 Topic。</li>
<li>死信队列中的消息可以被单独处理，例如记录日志、人工干预等。</li>
</ul>
</li>
<li>避免无限重试<ul>
<li>通过死信队列，可以避免消息无限重试，防止资源浪费。</li>
</ul>
</li>
</ol>
<blockquote>
<p>git Issues: <a href="https://github.com/streamnative/pulsar-client-go/issues/173">https://github.com/streamnative/pulsar-client-go/issues/173</a></p>
<p>go客户端与Java客户端对死信队列中 MaxRedeliverCount 配置存在差异：</p>
<p>在Pulsar的DLQPolicy中，<code>MaxDeliveries</code>属性的含义不明确，导致Java和Go客户端的实现和测试中存在差异。</p>
<p>关键点讨论：</p>
<ol>
<li><strong>Java客户端定义</strong>：<code>MaxDeliveries</code>表示消息在被发送到死信队列之前将重新传递的最大次数。</li>
<li><strong>Go客户端定义</strong>：<code>MaxDeliveries</code>表示消息在被发送到死信队列之前将传递的最大次数。</li>
<li>测试中的差异<ul>
<li>Java客户端测试中，<code>Nack</code>和<code>reconsumeLater</code>的预期结果不同，<code>Nack</code>测试期望得到<code>redelivery+1</code>条消息。</li>
<li>Go客户端测试中，<code>Nack</code>测试的预期结果是总传递次数，与Java客户端的<code>reconsumeLater</code>测试预期不同。</li>
</ul>
</li>
<li><strong>命名问题</strong>：Go客户端的命名可能存在问题，因为<code>MaxDeliveries</code>实际上用于提供最大重新传递次数。</li>
</ol>
<p>总结：<br><code>MaxDeliveries</code>属性的含义在不同客户端和测试中不一致，导致混淆。需要明确其定义并统一各客户端的实现和测试预期。</p>
<h4 id="Java客户端的例子"><a href="#Java客户端的例子" class="headerlink" title="Java客户端的例子"></a><strong>Java客户端的例子</strong></h4><p>假设我们设置<code>MaxDeliveries = 3</code>，即消息最多重新传递3次。</p>
<ol>
<li><strong>第一次传递</strong>：消息被传递给消费者。</li>
<li><strong>第一次重试</strong>：消费者<code>Nack</code>消息，消息被重新传递。</li>
<li><strong>第二次重试</strong>：消费者再次<code>Nack</code>消息，消息再次被重新传递。</li>
<li><strong>第三次重试</strong>：消费者再次<code>Nack</code>消息，消息再次被重新传递。</li>
<li><strong>第四次传递</strong>：如果消费者再次<code>Nack</code>消息，消息将被发送到死信队列（DLQ）。</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><code>MaxDeliveries = 3</code>表示消息最多被重新传递3次。</li>
<li>总共传递次数为4次（1次原始传递 + 3次重试）。</li>
</ul>
<hr>
<h4 id="Go客户端的例子"><a href="#Go客户端的例子" class="headerlink" title="Go客户端的例子"></a><strong>Go客户端的例子</strong></h4><p>同样设置<code>MaxDeliveries = 3</code>，即消息最多传递3次。</p>
<ol>
<li><strong>第一次传递</strong>：消息被传递给消费者。</li>
<li><strong>第二次传递</strong>：消费者<code>Nack</code>消息，消息被重新传递。</li>
<li><strong>第三次传递</strong>：消费者再次<code>Nack</code>消息，消息被重新传递。</li>
<li><strong>第四次传递</strong>：如果消费者再次<code>Nack</code>消息，消息将被发送到死信队列（DLQ）。</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><code>MaxDeliveries = 3</code>表示消息最多被传递3次。</li>
<li>总共传递次数为3次（1次原始传递 + 2次重试）。</li>
</ul>
<hr>
<h4 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a><strong>差异对比</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">客户端</th>
<th style="text-align:left"><code>MaxDeliveries</code> 含义</th>
<th style="text-align:left">总共传递次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left">重新传递次数</td>
<td style="text-align:left">4次</td>
</tr>
<tr>
<td style="text-align:left">Go</td>
<td style="text-align:left">总传递次数</td>
<td style="text-align:left">3次</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>Java客户端的<code>MaxDeliveries</code>表示“重新传递的次数”，而Go客户端的<code>MaxDeliveries</code>表示“总传递的次数”。这种差异导致了在测试和实际使用中的混淆。</p>
</blockquote>
<h2 id="消费者的消费行为"><a href="#消费者的消费行为" class="headerlink" title="消费者的消费行为"></a>消费者的消费行为</h2><h4 id="1、消费者的消费模式"><a href="#1、消费者的消费模式" class="headerlink" title="1、消费者的消费模式"></a>1、<strong>消费者的消费模式</strong></h4><p>在默认情况下，Pulsar 消费者的工作模式是基于 <strong>消息确认（Acknowledgment, Ack）</strong> 的。消费者的消费行为可以分为以下几个阶段：</p>
<ol>
<li><strong>消费消息</strong>：消费者从 Pulsar 的 Topic 中拉取消息。</li>
<li><strong>处理消息</strong>：消费者处理消息。</li>
<li><strong>确认消息</strong>：消费者调用 <code>Ack</code> 确认消息，表示消息已被成功处理。</li>
</ol>
<h4 id="2、消息确认机制"><a href="#2、消息确认机制" class="headerlink" title="2、消息确认机制"></a>2、<strong>消息确认机制</strong></h4><ul>
<li><strong>已确认的消息</strong>：消费者调用 <code>Ack</code> 的消息会被标记为已确认，Pulsar 会从消费者的未确认队列中移除这些消息。</li>
<li><strong>未确认的消息</strong>：消费者未调用 <code>Ack</code> 的消息会保留在未确认队列中。</li>
</ul>
<h4 id="3、-程序崩溃后的行为"><a href="#3、-程序崩溃后的行为" class="headerlink" title="3、 程序崩溃后的行为"></a>3、 <strong>程序崩溃后的行为</strong></h4><p>当消费者程序崩溃后重新启动时，Pulsar 消费者会从 <strong>未确认的消息</strong> 开始消费。</p>
<p>例如</p>
<ul>
<li>生产者生产了 <code>1, 2, 3, 4, 5</code>消费者全部消费成功, 但仅仅提交了 <code>1, 3, 4, 5</code>,</li>
<li>没有提交<code>2</code>的时候, 程序崩溃重启, 同时假设生产者在<code>5</code>之后并未生产消息</li>
<li>消费者重新启动之后消费的顺序将是<code>2</code>, 不会重新消费<code>3, 4, 5</code>, 因为他们是已经确认的消息</li>
</ul>
<p>或</p>
<ul>
<li>生产者生产了 <code>1, 2, 3, 4, 5</code>消费者全部消费成功, 但仅仅提交了 <code>1, 3, 4, 5</code>,</li>
<li>没有提交<code>2</code>的时候, 程序崩溃重启, 同时假设生产者在<code>5</code>之后生产了<code>6, 7, 8</code></li>
<li>消费者重新启动之后消费的顺序将是<code>2, 6, 7, 8</code>, 不会重新消费<code>3, 4, 5</code>, 因为他们是已经确认的消息</li>
</ul>
<p>可能会影响以上行为的配置项如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">配置项</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ackTimeout</code></td>
<td style="text-align:left">未确认消息的超时时间，触发自动重新投递。</td>
<td style="text-align:left">0</td>
<td style="text-align:left">如果设置为非零值，未确认的消息会在超时后自动重新投递。</td>
</tr>
<tr>
<td style="text-align:left"><code>ackTimeoutTickTime</code></td>
<td style="text-align:left">检查未确认消息的时间间隔。</td>
<td style="text-align:left">1 秒</td>
<td style="text-align:left">影响 <code>ackTimeout</code> 的检查频率。</td>
</tr>
<tr>
<td style="text-align:left"><code>negativeAckRedeliveryDelay</code></td>
<td style="text-align:left"><code>Nack</code> 触发重新投递的延迟时间。</td>
<td style="text-align:left">1 分钟</td>
<td style="text-align:left">影响 <code>Nack</code> 触发重新投递的时间。</td>
</tr>
<tr>
<td style="text-align:left"><code>replicateSubscriptionState</code></td>
<td style="text-align:left">是否将订阅状态复制到其他集群。</td>
<td style="text-align:left">false</td>
<td style="text-align:left">影响跨集群故障切换时的未确认消息处理。如果设置为 <code>false</code>，订阅状态不会复制，重启后只会从本地未确认的消息开始消费</td>
</tr>
<tr>
<td style="text-align:left"><code>maxUnackedMessagesPerConsumer</code></td>
<td style="text-align:left">每个消费者允许的最大未确认消息数量。</td>
<td style="text-align:left">50000</td>
<td style="text-align:left">影响消费者的未确认消息数量限制。</td>
</tr>
<tr>
<td style="text-align:left"><code>enableBatchIndexAcknowledgment</code></td>
<td style="text-align:left">是否启用批量消息的索引级别确认。</td>
<td style="text-align:left">false</td>
<td style="text-align:left">影响批量消息的确认粒度。如果设置为 <code>true</code>，消费者可以确认批量消息中的部分消息，而不是整个批量消息</td>
</tr>
<tr>
<td style="text-align:left"><code>autoUpdatePartitions</code></td>
<td style="text-align:left">是否自动更新分区信息。</td>
<td style="text-align:left">true</td>
<td style="text-align:left">影响消费者对新分区的订阅行为。如果设置为 <code>false</code>，消费者不会订阅新创建的分区，重启后可能会丢失新分区的消息。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>pulsar</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-变量、函数与控制流</title>
    <url>/2023/05/20230507.html</url>
    <content><![CDATA[<h1 id="从-hello-world-开始"><a href="#从-hello-world-开始" class="headerlink" title="从 hello world 开始"></a>从 hello world 开始</h1><p>创建一个 <code>main.rs</code> 文件，写入以下内容</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用以下命令进行编译运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<ul>
<li>也可使用<code>Cargo</code>工具进行构建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new  <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="comment">#这将会创建如下结构</span></span><br><span class="line"><span class="variable">$&#123;project_name&#125;</span></span><br><span class="line">	src/main.rs</span><br><span class="line">	Cargo.toml</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中，<code>toml</code>文件内容如下</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;project_name&quot;</span> <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#项目版本</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#Rust版本，当前为2015 2018 2021，默认为2015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> <span class="comment">#依赖的包</span></span><br></pre></td></tr></table></figure>
<p>在 <code>src/main.rs</code> 中写入内容， 使用<code>cargo build/cargo build --release</code> 进行构建，编译产物将会放在<code>target/debug/$&#123;project_name&#125; or target/release/$&#123;project_name&#125;</code>下，也可使用<code>cargo run</code>直接编译运行，也可使用<code>cargo check</code>来进行编译检查</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>变量与可变性</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">//不可变</span></span><br><span class="line">x = <span class="number">6</span>; <span class="comment">//编译失败</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">6</span>; <span class="comment">//可变</span></span><br><span class="line">y = <span class="number">6</span>; <span class="comment">//正确的，没问题的</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SOME_VALUE: <span class="type">u32</span> = <span class="number">1001</span></span><br></pre></td></tr></table></figure>
<p>常量使用<code>const</code>关键字进行声明，常量可以在任何作用域中声明，并且声明常量时<strong>必须注明值的类型</strong></p>
<ul>
<li>隐藏</li>
</ul>
<p>当定义多个同名的变量时，只有之前的变量都会被最后一次定义的变量隐藏，直到最后一次定义的变量作用于结束</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码，首先将<code>x</code>绑定到值<code>5</code>上， 接着通过<code>let x =</code>创建了新的变量<code>x</code>，获取初始值并加一，此时<code>x</code>的值变为<code>6</code>，接着在花括号创建的作用于内，<code>x</code>又被隐藏了一次，此时<code>x</code>的值为12，在作用于结束时，隐藏也结束了，<code>x</code>又变回6，因此以上程序输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.31s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>
<p>隐藏实际上是创建了一个新的同名变量，可以改变变量值类型，并复用这个名字，而<code>mut</code>关键字无法做到这一点，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二次为数字类型，使用隐藏可以做到这一点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二句则尝试讲一个数字类型赋值给一个字符串类型的变量，此时编译会失败</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每一个值都属于某一个数据类型，这将高速Rust编译器它被指定为何种数据，一遍明确数据处理方式，存在两类数据源类型子集：<em>标量</em>与<em>复合</em></p>
<p>通常编译器可以自动推导数据类型，不过某些情况下需要显示的指定数据类型，例如数据类型可能有多种情况时，例如将字符串转为数字</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number !&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>代表单独一个值，Rust中有四种基本标量类型：整形、浮点型、布尔型以及字符串类型</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>默认类型为<code>i32</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
</div>
<p>而对于数字面值，允许使用类型后缀，例如<code>64u8</code>为<code>u8</code>类型的64，也允许使用<code>_</code>下划线作为分隔符，例如<code>1_000</code>等价于<code>1000</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decimal (十进制)</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>Hex (十六进制)</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>Octal (八进制)</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>Binary (二进制)</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>Byte (单字节字符)(仅限于<code>u8</code>)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>关于整型溢出，Debug模式下构建的二进制，在发生溢出时会panic，Release模式下构建的二进制会进行二进制补码操作，来绕回最小值，如256+1 = 0</p>
<p>对于整型溢出，可采用以下方式显示处理</p>
<ul>
<li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li>
<li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li>
<li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li>
<li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li>
</ul>
</blockquote>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p><code>f32</code>与<code>f64</code>，分别占32位于64位，默认为<code>f64</code>，浮点型数据都是有符号的</p>
<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>关键字为<code>char</code>，类型大小为4个字节，并代表了一个Unicode标量值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>可将多个值组合成一个类型，存在两种原生的复合类型：元组与数组</p>
<h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><p>将多个其他类型的值组合仅一个复合类型，元组长度固定，一旦声明，其长度不会变化</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>当想从元组中获取单个值时， 可以使用模式匹配来结构元组值，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="comment">//创建了 x, y, z 来将 tup 分成了三个变量，</span></span><br></pre></td></tr></table></figure>
<p>也可使用<code>.</code>来进行访问，例如<code>tup.0</code>即为第一个值<code>500</code></p>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。<strong>如果表达式不返回任何其他值，则会隐式返回单元值。</strong></p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组中的每个元素类型必须相同，且数组的长度是固定的，数组在栈上分配空间</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">array2</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">//5个i32类型数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = [<span class="number">3</span>; <span class="number">5</span>];<span class="comment">//标识数组中有 5 个 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = array[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;number is &#123;one&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="函数与控制流"><a href="#函数与控制流" class="headerlink" title="函数与控制流"></a>函数与控制流</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用关键字<code>fun</code>声明，函数名与变量名使用Unix风格，小写字母，并使用下换线分割单词</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。</strong></p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数必须声明参数类型，多个参数使用逗号分割</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><ul>
<li><strong>语句</strong> 执行一些操作但不返回值的指令，以分号结尾</li>
<li><strong>表达式</strong> 计算并产生一个值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>; <span class="comment">//语句不会返回任何值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = (<span class="keyword">let</span> <span class="variable">c</span> = <span class="number">2</span>);<span class="comment">//编译会失败 let c = 2 不会返回值</span></span><br></pre></td></tr></table></figure>
<p>在rust中，函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">1</span>;</span><br><span class="line">    b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时 a = 4</span></span><br></pre></td></tr></table></figure>
<h3 id="具有返回值的函数"><a href="#具有返回值的函数" class="headerlink" title="具有返回值的函数"></a>具有返回值的函数</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ret</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">ret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a><code>if</code>表达式</h3><p><strong><code>if</code>表达式使用的值必须为<code>bool</code>类型</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">5</span> &#123;</span><br><span class="line">   	<span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &#123; <span class="comment">//不能这样使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if</code>也可在<code>let</code>中使用，但是需要每个分支都必须是相同的类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">flag</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="number">1</span>&#125;; <span class="comment">//可以</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num2</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;one&quot;</span>&#125; <span class="comment">//不行</span></span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h4><p>无条件的循环，可以使用<code>break</code>从循环跳出，同时可以返回一个值，也可以使用<code>continue</code>跳过循环</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;loopping !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> cnt * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res = 200</span></span><br></pre></td></tr></table></figure>
<p><code>break</code>和<code>continue</code>仅能控制当前的循环，对于嵌套的循环，可以配合标签一起使用来控制循环</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">&#x27;loop_start</span>&#x27;: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cnt = &#123;cnt&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;loop_start</span>&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;End cnt = &#123;cnt&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="while条件循环"><a href="#while条件循环" class="headerlink" title="while条件循环"></a><code>while</code>条件循环</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> num != <span class="number">0</span> &#123;</span><br><span class="line">	num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for遍历集合"><a href="#for遍历集合" class="headerlink" title="for遍历集合"></a><code>for</code>遍历集合</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">one</span> <span class="keyword">in</span> a &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;one&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-所有权、引用与Slice</title>
    <url>/2023/05/20230508.html</url>
    <content><![CDATA[<p>Rust 通过所有权系统管理内存，编译器在编译时会根据一系列规则进行检查，如果违反了这些规则，程序不能通过编译。在运行时，所有权系统的任何功能都不会减缓程序的运行</p>
<h1 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h1><blockquote>
<ol>
<li>Rust 中的每一个值都有一个<strong>所有者</strong></li>
<li>值在任意时刻有且仅有一个所有者</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃</li>
</ol>
</blockquote>
<span id="more"></span>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>同C语言，以 Rust 中的<code>String</code>类型举例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当变量<code>str</code>离开作用域时，会自动调用一个名为<code>drop</code>的函数，类似C++中的<code>RAII</code></p>
<h2 id="变量与数据交互的方式：移动"><a href="#变量与数据交互的方式：移动" class="headerlink" title="变量与数据交互的方式：移动"></a>变量与数据交互的方式：移动</h2><p>对于以下代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>
<p>其将5绑定到<code>x</code>，接着生成一个<code>x</code>的拷贝并绑定到<code>y</code>，两个变量都在栈上</p>
<p>而对于以下代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>
<p>变量<code>s1</code>实际内容是存放在堆中，<code>String</code>对象由指向字符串内容的指针，一个长度与一个容量组成，这一部分数据是在栈上的，此处的操作类似于C++11中的<code>std::move()</code>操作，将<code>s1</code>中长度与容量赋值给<code>s2</code>，将<code>s2</code>的指针指向<code>s1</code>所指向的字符串内容，在C++11中，<code>std::move()</code>这一操作一般是对将亡值使用，在Rust中并无这一限制，但是在Rust中一旦使用这样的<strong>移动</strong>，则移动前的变量将不再有效，不能使用，这样就避免了变量离开作用域时的多次释放导致的未定义行为</p>
<p>简单来说，以上的操作是直接将<code>s1</code>认定为将亡值并使用移动语义将其内容转义到<code>s2</code>中</p>
<h2 id="变量与数据的交互方式：克隆"><a href="#变量与数据的交互方式：克隆" class="headerlink" title="变量与数据的交互方式：克隆"></a>变量与数据的交互方式：克隆</h2><p>如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure>
<p>类似C++中的拷贝构造</p>
<h3 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a>只在栈上的数据：拷贝</h3><p>如果数据本身大小已知，且整个存储在栈上，则在赋值时会进行拷贝操作，Rust 中存在一个 <code>Copy</code>traitde的特殊注解，可以用在类似整型这样存储在栈上的类型上，一个类型如果实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。同时，<strong>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。</strong>如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。</p>
<p>一下是一些实现了 <code>Copy</code> trait 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li>
</ul>
<h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数与给变量赋值类似，可能会移动或赋值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">                                    <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处（没有调用drop析构）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h2><p>返回值也可以转移所有权</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 转移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中，</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 会将</span></span><br><span class="line">                                             <span class="comment">// 返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域。</span></span><br><span class="line">    </span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string </span></span><br><span class="line">                                             <span class="comment">// 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用可以不获取所有权就可以使用值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tets&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">get_str_len</span>(&amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_str_len</span>(<span class="type">str</span>: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&amp;s1</code>语法可以创建一个指向值<code>s1</code>的引用，但不拥有它，这种行为被称为<strong>借用，借用的变量不能进行修改</strong></p>
<h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在增加了<code>mut</code>关键字后，可以对引用值进行修改，但需要注意的是，如果<strong>拥有一个对该变量的可变引用，那就不能再对该变量创建引用</strong>，不能同一时间多次将一个值作为可变变量借用，这样的限制可以避免数据竞争，数据竞争主要由以下三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>当然，可以使用花括号来划分不同的作用域来实现同意值得多次借用，但在同一个作用域内，这样的行为不被允许。<strong>而可变引用与不可变引用也不能在同一个作用域中出现，但不可变引用可以在同一作用域出现多个</strong>，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p3</span> = &amp;<span class="keyword">mut</span> <span class="type">str</span>;<span class="comment">//有毛病</span></span><br></pre></td></tr></table></figure>
<p>不过，<strong>一个引用的作用域是从声明的地方到最后一次使用位置</strong>，所以可以进行如下改造</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p3</span> = &amp;<span class="keyword">mut</span> <span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p3);</span><br></pre></td></tr></table></figure>
<h2 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h2><p>我习惯称为野引用，指被借用的值的生命周期小于引用，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">str</span> = <span class="title function_ invoke__">get_str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_str</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul>
<li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<h1 id="Slice类型"><a href="#Slice类型" class="headerlink" title="Slice类型"></a>Slice类型</h1><p><code>slice</code>允许引用集合中一段连续的元素序列，而不是引用整个集合，它是一类引用，所以没有所有权。</p>
<p>现在假设一个场景，在一个以空格为分隔符的字符串中，找到第一个子串并返回，如果没有空格则返回其本身，在不使用<code>slice</code>的情况下，我们没有办法真正获取<strong>部分</strong>字符串，但可以返回索引，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s); <span class="comment">// word 的值为 5</span></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 这清空了字符串，使其等于 &quot;&quot;</span></span><br><span class="line">    <span class="comment">// word 在此处的值仍然是 5，</span></span><br><span class="line">    <span class="comment">// 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会引发一个问题，索引和字符串本身没什么关系，但凡字符串有改动，那么拿到的索引就会失效</p>
<h2 id="字符串slice"><a href="#字符串slice" class="headerlink" title="字符串slice"></a>字符串<code>slice</code></h2><p>字符串<code>slice</code>是<code>String</code>中一部分值的引用，写法如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure>
<p>不同于<code>String</code>的引用，通过切片，将其分为了两个引用，分别是从第0个元素到第5个元素前，第6个元素到第11个元素前，形式为<code>[start_idx..end_idx]</code>，如果<code>start_idx</code>的值为0，那么也可以简写为<code>[..end_idx]</code>，如果<code>end_idx</code>的值为最后一个元素的位置，那么也可写作<code>[start_idx..]</code>，若要获取整个元素的切片，可以写作<code>[..]</code></p>
<p>现在，试着使用切片重写获取第一个子串的函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误！</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行编译是，会发现<code>sclear()</code>会引发编译错误，这是因为<code>clear</code>想要清空字符串，需要获取一个可变的引用，而其下一句<code>println!</code>则使用了字符串中的不可变引用，rust中，可变引用和不可变引用不能同时存在，可变引用的最后一次使用应该位于不可变引用最后一次使用前</p>
<h2 id="字符串面值也是slice"><a href="#字符串面值也是slice" class="headerlink" title="字符串面值也是slice"></a>字符串面值也是<code>slice</code></h2><p>例如<code>let s = &quot;hello world&quot;;</code>此处<code>s</code>的类型是<code>&amp;str</code>，其是指向二进制程序特定位置的<code>slice</code>（静态区），所以<code>&amp;str</code>是一个不可变引用</p>
<h2 id="字符串slice做参数"><a href="#字符串slice做参数" class="headerlink" title="字符串slice做参数"></a>字符串<code>slice</code>做参数</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于以下函数定义</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line"><span class="comment">//也可写作</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>
<p>对第二种写法，如果有一个字符串<code>slice</code>，可以传递，如果有一个<code>String</code>，则可以传递整个<code>String</code>的引用或对<code>String</code>的引用，即这里会进行一次隐式类型转换，在使用时可如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// first_word 适用于String（的 slice），部分或全部</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line"><span class="comment">// first_word 也适用于 String 的引用，</span></span><br><span class="line"><span class="comment">// 这等价于整个 String 的 slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first_word 适用于字符串字面值，部分或全部</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为字符串字面值已经是字符串 slice 了，</span></span><br><span class="line"><span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br></pre></td></tr></table></figure>
<h2 id="其他类型slice"><a href="#其他类型slice" class="headerlink" title="其他类型slice"></a>其他类型<code>slice</code></h2><p>跟<code>string</code>差裘不多</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-结构体</title>
    <url>/2023/05/20230509.html</url>
    <content><![CDATA[<h1 id="结构体的定义与实例化"><a href="#结构体的定义与实例化" class="headerlink" title="结构体的定义与实例化"></a>结构体的定义与实例化</h1><p>举例如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	active: <span class="type">bool</span>,</span><br><span class="line">	username: <span class="type">String</span>,</span><br><span class="line">	email: <span class="type">String</span>,</span><br><span class="line">	sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">	active: <span class="literal">true</span>,</span><br><span class="line">	username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">	email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;email@email.com&quot;</span>),</span><br><span class="line">	sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//若要使用值，则同C/C++</span></span><br><span class="line"><span class="comment">//若要修改值，则示例需是可变的，如下</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user2</span> = User &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">user2.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>作为函数返回值如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果函数参数和字段名相同，则可以使用简化写法</strong>如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用结构体更新语法从其他实例创建"><a href="#使用结构体更新语法从其他实例创建" class="headerlink" title="使用结构体更新语法从其他实例创建"></a>使用结构体更新语法从其他实例创建</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    active: user1.active,</span><br><span class="line">    username: user1.username,</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可使用简化写法，使用<code>..</code>来指定剩余没有变化的值，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><code>..user1</code>必须放在最后</strong></p>
<blockquote>
<p>请注意，转移与克隆的规则在此处仍然适用，例如用<code>user1</code>的<code>username</code>与<code>email</code>字段更新<code>user2</code>之后，这两个字段被转移到<code>user2</code>中，其余值则拷贝了一份，此时<code>user1</code>不能再使用。</p>
<p>而如果<code>user2</code>的那两个字段使用<code>String::from()</code>来进行赋值，其余从<code>user1</code>更新，那二者都可使用</p>
</blockquote>
<h2 id="元组结构体-匿名结构体"><a href="#元组结构体-匿名结构体" class="headerlink" title="元组结构体/匿名结构体"></a>元组结构体/匿名结构体</h2><p>类似如下形式，使用时同元组，使用下标</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="没有字段名称的类单元结构体"><a href="#没有字段名称的类单元结构体" class="headerlink" title="没有字段名称的类单元结构体"></a>没有字段名称的类单元结构体</h2><p>即元组类型中的<code>unit</code>类型，类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。形式如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h2><p>在上面的示例中，<code>User</code>结构体中的字符串类型使用了<code>String</code>而非<code>&amp;str</code>，这是因为想要这个结构体拥有它所有的数据，由此，只要整个结构体是有效的，那其中的数据也一定有效。</p>
<p>也可以是结构体存储被其他对象拥有的数据的引用（切片类型），不过需要用上生命周期标识符。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的</p>
<h1 id="结构体的示例程序"><a href="#结构体的示例程序" class="headerlink" title="结构体的示例程序"></a>结构体的示例程序</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rectangle: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过派生trait增加实用功能"><a href="#通过派生trait增加实用功能" class="headerlink" title="通过派生trait增加实用功能"></a>通过派生<code>trait</code>增加实用功能</h2><p>在上面实现的结构体，无法直接通过<code>println!</code>，但可通过以下方式进行</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">//定义外部属性</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">    dbg!(&amp;rect1); <span class="comment">//另一种方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法语句"><a href="#方法语句" class="headerlink" title="方法语句"></a>方法语句</h1><p>关键字为<code>impl</code>，<code>impl</code>块中所有内容都将与结构体类型相关联，如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数<code>area</code>中，<code>&amp;self</code>实际上是<code>self: &amp;self</code>的缩写，他会借用调用对象的值，而不获取他的所有权</p>
<h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>所有在<code>impl</code>块中定义的函数被称为 <strong>关联函数</strong> （静态成员函数），因为其与<code>impl</code>后面命名的类型先关。可以定义不以<code>self</code>为第一参数的关联函数，因此他不是方法，不是方法的关联函数通常会被用作返回一个结构体新实例的构造函数，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sq</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>::</code>来使用结构体的关联函数，<code>::</code>语法用于关联函数和模块创建的命名空间</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-枚举与模式匹配</title>
    <url>/2023/05/20230512.html</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>结构体将字段与数据聚合，而枚举可以将同一类型的东西（同时你可以将它可能的情况列举出来）作为一个集合，使用IP地址举例如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">	v4,</span><br><span class="line">	v6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>可使用<code>::</code>访问枚举值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ipv4</span> = IpAddrKind::v4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ipv6</span> = IpAddrKind::v6;</span><br></pre></td></tr></table></figure>
<p>也可将其传入函数，如<code>func(IpAddrKind::v4)</code></p>
<span id="more"></span>
<p>也可结合结构体使用如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可直接指定枚举值类型如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>此时，<code>IpAddr::V4()</code>实际上为一个获取<code>String</code>参数并返回<code>IpAddr</code>类型示例的函数调用，而这些构造函数会被自动定义，枚举可以为每个值指定不同的数据类型，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将任意类型的数据放入枚举成员中，例如字符串，数字或者结构体，甚至可以嵌套枚举</p>
</blockquote>
<p>以下为一个多种成员类型的枚举类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该枚举类型有四个成员，分别为：</p>
<ul>
<li><code>Quit</code> 没有关联任何数据。</li>
<li><code>Move</code> 类似结构体包含命名字段。</li>
<li><code>Write</code> 包含单独一个 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li>
</ul>
<p>如果使用结构体的话，他将会是这样，如果不能使用枚举类型的话，使用结构体需要定义四个不同的结构体类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QuitMessage</span>; <span class="comment">// 类单元结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MoveMessage</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteMessage</span>(<span class="type">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChangeColorMessage</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></table></figure>
<p>枚举同结构体一样可以使用<code>impl</code>来定义方法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure>
<h2 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a><code>Option</code>枚举</h2><p><code>Option</code>是标准库定义的另一个枚举，这个枚举可以表示一个空值，Rust没有<code>nil</code>，<code>nullptr</code>，<code>NULL</code>那样的空值，取而代之为如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="literal">None</span>,</span><br><span class="line">	<span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以不使用<code>Option::</code>前缀来直接使用<code>Some</code>与<code>None</code>，但即便如此<code>Option&lt;T&gt;</code>也是常规的枚举， <code>Some&lt;T&gt;</code>与<code>None</code>是其成员，以下是一些例子</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_num</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，<code>some_num</code>的类型是<code>Option&lt;i32&gt;</code>，<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>，对于<code>absent_num</code>则通过<code>: Option&lt;i32&gt;</code>显示的指明其类型</p>
<p>当有一个<code>Some</code>值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。这样做会比空值更好，因为<code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = x + y; <span class="comment">//这两个值不能相加，因为不是同一个类型</span></span><br></pre></td></tr></table></figure>
<h1 id="match控制流"><a href="#match控制流" class="headerlink" title="match控制流"></a><code>match</code>控制流</h1><p>允许讲一个值与一系列的模式相比较，并根据与相匹配的模式执行相应的代码。模式可以由字面值、变量以及通配符等其他内容构成，以下为一个案例，利用<code>match</code>语法获取对应衣服尺码的袖长</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ClothingSize</span> &#123;</span><br><span class="line">    Size_XS,</span><br><span class="line">    Szie_S,</span><br><span class="line">    Size_M,</span><br><span class="line">    Size_L,</span><br><span class="line">    Size_XL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_sleeve_len</span>(clothing_size: ClothingSize) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> clothing_size &#123;</span><br><span class="line">        ClothingSize::Size_XS =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;This is XS&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125; <span class="comment">//使用 &#123;&#125; 形式时 逗号可写可不写</span></span><br><span class="line">        ClothingSize::Szie_S =&gt; <span class="number">20</span>,</span><br><span class="line">        ClothingSize::Size_M =&gt; <span class="number">30</span>,</span><br><span class="line">        ClothingSize::Size_L =&gt; <span class="number">40</span>,</span><br><span class="line">        ClothingSize::Size_XL =&gt; <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h2><p>匹配分支的另一个功能是可以绑定匹配模式的部分值，这也就是如何从枚举成员中提取值的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    AAA,</span><br><span class="line">    BBB</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ClothingSize</span> &#123;</span><br><span class="line">    Size_XS,</span><br><span class="line">    Szie_S,</span><br><span class="line">    Size_M,</span><br><span class="line">    <span class="title function_ invoke__">Size_L</span>(Brand),</span><br><span class="line">    Size_XL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_sleeve_len</span>(clothing_size: ClothingSize) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> clothing_size &#123;</span><br><span class="line">        ClothingSize::Size_XS =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;This is XS&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125; <span class="comment">//使用 &#123;&#125; 形式时 逗号可写可不写</span></span><br><span class="line">        ClothingSize::Szie_S =&gt; <span class="number">20</span>,</span><br><span class="line">        ClothingSize::Size_M =&gt; <span class="number">30</span>,</span><br><span class="line">        ClothingSize::<span class="title function_ invoke__">Size_L</span>(brand) =&gt; &#123;</span><br><span class="line">        	<span class="built_in">println!</span>(<span class="string">&quot;clothing brand is &#123;:?&#125;&quot;</span>, brand);</span><br><span class="line">            <span class="number">40</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ClothingSize::Size_XL =&gt; <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上场景中，调用<code>get_sleeve_len(ClothingSize::Size_L(Brand::AAA))</code>，传入函数内部的<code>clothing_size</code>遇到<code>ClothingSize::Size_L(brand)</code>会匹配上，接着就可以直接使用<code>AAA</code>这个值</p>
<h2 id="匹配Option-lt-T-gt"><a href="#匹配Option-lt-T-gt" class="headerlink" title="匹配Option&lt;T&gt;"></a>匹配<code>Option&lt;T&gt;</code></h2><p><code>Option&lt;T&gt;</code>也可以被用作<code>match</code>匹配，例如一个函数，接受一个类型为<code>Option&lt;T&gt;</code>的参数，如果其中有值，则将其加一，如果没有则不进行操作</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<h2 id="匹配的穷尽性，通配模式与占位符"><a href="#匹配的穷尽性，通配模式与占位符" class="headerlink" title="匹配的穷尽性，通配模式与占位符_"></a>匹配的穷尽性，通配模式与占位符<code>_</code></h2><p>匹配需要列出所有的可能，所有可能出现的值都必须能匹配到，在<code>Rust</code>中可以使用通配模式与<code>_</code>占位符来实现穷尽例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">rand</span>();</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">deal_seven</span>(),</span><br><span class="line">    <span class="number">9</span> =&gt; <span class="title function_ invoke__">deal_nine</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">deal_other</span>(other),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_seven</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_nine</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_other</span>(num: <span class="type">u8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于前两个分支，匹配模式是字面值 <code>7</code> 和 <code>9</code>，最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 <code>other</code> 的一个变量。<code>other</code> 分支的代码通过将其传递给 <code>deal_other</code> 函数来使用这个变量。</p>
<blockquote>
<p>通配模式应该放在最后一位，因为<code>match</code>是按照分支顺序依次匹配的</p>
</blockquote>
<p>如果不想使用通配模式获取的值，使用<code>_</code>来替代，其可以匹配任意值而不绑定到该值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">rand</span>();</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">deal_seven</span>(),</span><br><span class="line">    <span class="number">9</span> =&gt; <span class="title function_ invoke__">deal_nine</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">deal_other</span>(),</span><br><span class="line">    <span class="comment">// 如果不想做任何事，可以使用以下写法，返回一个空的元组</span></span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_seven</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_nine</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_other</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="if-let简洁控制流"><a href="#if-let简洁控制流" class="headerlink" title="if let简洁控制流"></a><code>if let</code>简洁控制流</h1><p>如果有以下类似的逻辑</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅关心<code>Some</code>得值，其余不做任何操作，可使用<code>if let</code>来简写</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>benthos中SetStructured和SetBytes差异</title>
    <url>/2025/05/20250507.html</url>
    <content><![CDATA[<h1 id="benthos中SetStructured和SetBytes差异"><a href="#benthos中SetStructured和SetBytes差异" class="headerlink" title="benthos中SetStructured和SetBytes差异"></a>benthos中SetStructured和SetBytes差异</h1><p>在 Benthos 中，<code>message.SetStructured()</code> 和 <code>message.SetBytes()</code> 是两种不同的消息内容设置方式，它们会影响消息的内部表示形式以及后续处理器的行为。以下是它们的区别和 Benthos 的处理方式：</p>
<blockquote>
<p>在 Benthos 的 <code>message</code> 实现中，<strong>不能同时有效保存 <code>SetBytes</code> 和 <code>SetStructured</code> 的内容</strong>。两种设置方式会互相覆盖，最终生效的是最后一次调用的方法。</p>
<ul>
<li><strong>最后调用的方法决定当前有效形式</strong><br>  无论先调用哪个方法，​<strong>​只有最后一次设置的内容会生效​</strong>​，另一种形式会被隐式转换或丢弃。</li>
<li><strong>自动转换逻辑</strong><br>  当访问另一种形式时，Benthos 会按需触发转换</li>
</ul>
</blockquote>
<span id="more"></span>
<hr>
<h4 id="1-SetBytes-：原始字节数据"><a href="#1-SetBytes-：原始字节数据" class="headerlink" title="1. SetBytes()：原始字节数据"></a><strong>1. <code>SetBytes()</code>：原始字节数据</strong></h4><h5 id="行为特点："><a href="#行为特点：" class="headerlink" title="行为特点："></a>行为特点：</h5><ul>
<li><strong>直接设置消息的原始字节内容</strong>，适用于非结构化数据（如纯文本、二进制数据、未解析的 JSON 等）。</li>
<li>消息会被标记为 <code>part.ContentIsBytes()</code>，Benthos 将其视为<strong>不透明的二进制数据</strong>。</li>
<li>后续处理器如果需要结构化访问（如 JSON 解析、字段提取），会<strong>隐式尝试解析</strong>（如自动解析 JSON）。</li>
</ul>
<h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置原始 JSON 字符串（未解析）</span></span><br><span class="line">err := msg.SetBytes([]<span class="type">byte</span>(<span class="string">`{"foo":"bar"}`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置纯文本</span></span><br><span class="line">err := msg.SetBytes([]<span class="type">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置二进制数据（如 Protobuf）</span></span><br><span class="line">err := msg.SetBytes(binaryData)</span><br></pre></td></tr></table></figure>
<h5 id="Benthos-处理："><a href="#Benthos-处理：" class="headerlink" title="Benthos 处理："></a>Benthos 处理：</h5><ul>
<li>如果后续处理器需要结构化数据（如 <code>jmespath</code> 或 <code>mapping</code> 处理器），Benthos 会<strong>临时解析字节内容</strong>（如将 JSON 字符串转为 <code>interface{}</code>）。</li>
<li>每次访问结构化内容时都会触发解析，可能带来少量性能开销。</li>
</ul>
<hr>
<h4 id="2-SetStructured-：结构化数据"><a href="#2-SetStructured-：结构化数据" class="headerlink" title="2. SetStructured()：结构化数据"></a><strong>2. <code>SetStructured()</code>：结构化数据</strong></h4><h5 id="行为特点：-1"><a href="#行为特点：-1" class="headerlink" title="行为特点："></a>行为特点：</h5><ul>
<li><strong>直接设置消息的结构化对象</strong>（如 <code>map[string]interface{}</code>、<code>[]interface{}</code> 等），跳过字节解析步骤。</li>
<li>消息会被标记为 <code>part.ContentIsStructured()</code>，Benthos 直接使用该结构，<strong>无需反复解析</strong>。</li>
<li>如果后续操作需要原始字节（如输出到文件/Kafka），Benthos 会<strong>按需序列化</strong>（如转为 JSON 字符串）。</li>
</ul>
<h5 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置结构化对象（如已解析的 JSON）</span></span><br><span class="line">data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"foo"</span>: <span class="string">"bar"</span>}</span><br><span class="line">err := msg.SetStructured(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数组</span></span><br><span class="line">err := msg.SetStructured([]<span class="keyword">interface</span>{}{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>})</span><br></pre></td></tr></table></figure>
<h5 id="Benthos-处理：-1"><a href="#Benthos-处理：-1" class="headerlink" title="Benthos 处理："></a>Benthos 处理：</h5><ul>
<li><p>结构化数据在处理器间传递时<strong>保持为对象</strong>，避免解析/序列化开销。</p>
</li>
<li><p>对结构化数据的操作（如字段修改）更高效：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接修改字段（无需解析）</span></span><br><span class="line">structured, _ := msg.AsStructured()</span><br><span class="line">structured.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{})[<span class="string">"foo"</span>] = <span class="string">"new_value"</span></span><br><span class="line">msg.SetStructured(structured)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="3-关键区别总结"><a href="#3-关键区别总结" class="headerlink" title="3. 关键区别总结"></a><strong>3. 关键区别总结</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center"><code>SetBytes()</code></th>
<th style="text-align:center"><code>SetStructured()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>内部存储形式</strong></td>
<td style="text-align:center">原始字节（<code>[]byte</code>）</td>
<td style="text-align:center">结构化对象（<code>interface{}</code>）</td>
</tr>
<tr>
<td style="text-align:center"><strong>解析开销</strong></td>
<td style="text-align:center">按需触发解析（可能多次）</td>
<td style="text-align:center">无解析（直接使用对象）</td>
</tr>
<tr>
<td style="text-align:center"><strong>序列化开销</strong></td>
<td style="text-align:center">无（已是字节）</td>
<td style="text-align:center">按需序列化（如输出时转 JSON）</td>
</tr>
<tr>
<td style="text-align:center"><strong>适用场景</strong></td>
<td style="text-align:center">原始数据、二进制协议</td>
<td style="text-align:center">已解析的 JSON/结构化数据</td>
</tr>
<tr>
<td style="text-align:center"><strong>性能优化</strong></td>
<td style="text-align:center">适合一次性处理</td>
<td style="text-align:center">适合多次操作结构化内容</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="4-Benthos-的隐式转换逻辑"><a href="#4-Benthos-的隐式转换逻辑" class="headerlink" title="4. Benthos 的隐式转换逻辑"></a><strong>4. Benthos 的隐式转换逻辑</strong></h4><p>当消息在处理器间传递时，Benthos 会自动处理两种形式的转换：</p>
<ol>
<li><p><strong><code>SetBytes</code> → 结构化访问</strong><br> 如果调用 <code>msg.AsStructured()</code>，Benthos 会尝试解析字节（如 JSON 解码）并缓存结果。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg.SetBytes([]<span class="type">byte</span>(<span class="string">`{"foo":"bar"}`</span>))</span><br><span class="line">structured, _ := msg.AsStructured() <span class="comment">// 触发 JSON 解析</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>SetStructured</code> → 字节访问</strong><br> 如果调用 <code>msg.AsBytes()</code>，Benthos 会序列化结构化数据（如 JSON 编码）。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg.SetStructured(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"foo"</span>: <span class="string">"bar"</span>})</span><br><span class="line">bytes, _ := msg.AsBytes() <span class="comment">// 触发 JSON 序列化</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h4 id="5-最佳实践建议"><a href="#5-最佳实践建议" class="headerlink" title="5. 最佳实践建议"></a><strong>5. 最佳实践建议</strong></h4><ol>
<li><p><strong>优先用 <code>SetStructured</code> 如果：</strong></p>
<ul>
<li>数据已经是结构化对象（如从 <code>json</code> 处理器解析后的结果）。</li>
<li>需要多次操作字段（避免重复解析）。</li>
</ul>
</li>
<li><p><strong>优先用 <code>SetBytes</code> 如果：</strong></p>
<ul>
<li>数据是原始字节且后续无需修改（如直接转发）。</li>
<li>处理非 JSON 数据（如 CSV、二进制协议）。</li>
</ul>
</li>
<li><p><strong>避免混用导致的性能问题：</strong></p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例：频繁切换会触发序列化/解析</span></span><br><span class="line">msg.SetBytes(...)</span><br><span class="line">msg.AsStructured() <span class="comment">// 解析</span></span><br><span class="line">msg.SetStructured(...)</span><br><span class="line">msg.AsBytes()      <span class="comment">// 序列化</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h4 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a><strong>示例场景</strong></h4><h5 id="场景-1：修改-JSON-字段"><a href="#场景-1：修改-JSON-字段" class="headerlink" title="场景 1：修改 JSON 字段"></a>场景 1：修改 JSON 字段</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高效做法（直接操作结构化数据）</span></span><br><span class="line">structured, _ := msg.AsStructured()</span><br><span class="line">structured.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{})[<span class="string">"foo"</span>] = <span class="string">"new_value"</span></span><br><span class="line">msg.SetStructured(structured) <span class="comment">// 无需序列化直到最终输出</span></span><br></pre></td></tr></table></figure>
<h5 id="场景-2：直接转发原始数据"><a href="#场景-2：直接转发原始数据" class="headerlink" title="场景 2：直接转发原始数据"></a>场景 2：直接转发原始数据</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无需解析时，保持为字节</span></span><br><span class="line">msg.SetBytes(rawData)</span><br><span class="line"><span class="comment">// ...直接传递给输出（如 Kafka）</span></span><br></pre></td></tr></table></figure>
<p>通过合理选择这两种方法，可以显著优化 Benthos 流程的性能。</p>
]]></content>
      <categories>
        <category>benthos</category>
      </categories>
      <tags>
        <tag>benthos</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>list的基本使用以及模拟实现</title>
    <url>/2020/06/20200615.html</url>
    <content><![CDATA[<h1 id="list的基本使用"><a href="#list的基本使用" class="headerlink" title="list的基本使用"></a>list的基本使用</h1><p>本质为双向带头循环列表</p>
<ol>
<li>list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。 </li>
<li>list的底层是双向带头循环链表，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。 </li>
<li>与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。 </li>
<li>与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素)<span id="more"></span>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"><span class="function">list&lt;<span class="type">char</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;<span class="comment">//五个a</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">char</span>&gt; <span class="title">lst3</span><span class="params">(str, str + <span class="number">5</span>)</span></span>;<span class="comment">//12345</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst4</span><span class="params">(list2.begin(), list2.end())</span></span>;<span class="comment">//aaaaa</span></span><br><span class="line"><span class="function">list&lt;<span class="type">char</span>&gt; <span class="title">copy</span><span class="params">(lst3)</span></span>;<span class="comment">//12345</span></span><br><span class="line">list&lt;<span class="type">char</span>&gt;::iterator it = lst3.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>( it != lst3.<span class="built_in">end</span>() )</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  it++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst5</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it2 = lst5.<span class="built_in">brgin</span>();</span><br><span class="line"><span class="keyword">while</span>(it2 != lst5.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  it++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>list迭代器在插入元素之后==不会失效==</p>
</li>
<li><p>删除元素会导致迭代器失效，调用删除接口之后，需要重新更新迭代器</p>
<ul>
<li>获取erase返回值，其指向下一个元素的位置</li>
<li>调用迭代器接口</li>
</ul>
</li>
</ul>
<p><code>remove</code>：删除指定值，如果有多个，全部删除，如果没有，不做操作</p>
<p><code>splice</code>：拼接，拼接时，被拼接的元素直接存入第一个list，第二个list中不再保留被拼接的元素</p>
<p><code>unique</code>：去重，使用之前需要lst元素有序，先调sort，再unique，如果自定义类型需要排序，则自定义类型需要支持比较运算</p>
<h1 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h1><p>list迭代器不是原生态指针实现的，一般通过封装节点，定义一个自定义类型，通过运算符重载函数完成迭代器规定的操作，例如：</p>
<ul>
<li><code>*iterator</code>：<code>operator*( )</code>—-&gt; _node-&gt;_val</li>
<li><code>++iterator</code>：<code>operator++( )</code> —-&gt; _node = _node-&gt;_next</li>
<li><code>iterator-&gt;</code>：<code>operator-&gt;( )</code>—-&gt; &amp;_node-&gt;_val</li>
<li><code>!=iterator</code>：<code>operator!=( )</code>—-&gt; _node != iterator2._node;</li>
</ul>
<p>即list迭代器不是一个指针，而是一个对象，以下为一个模拟实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;<span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;T&gt;* PNode;</span><br><span class="line">	<span class="keyword">typedef</span> ListIterator&lt;T, Ref, Ptr&gt; Self;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ListIterator</span>(PNode pNode = <span class="literal">nullptr</span>)</span><br><span class="line">		: _pNode(pNode)</span><br><span class="line">	&#123; &#125;</span><br><span class="line">	<span class="built_in">ListIterator</span>(<span class="type">const</span> Self&amp; ls)</span><br><span class="line">		: _pNode(ls._pNode)</span><br><span class="line">	&#123; &#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _pNode-&gt;_val;</span><br><span class="line">	&#125;	</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		_pNode = _pNode-&gt;_pNext;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_pNode = _pNode-&gt;_pNext;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	Self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		_pNode = _pNode-&gt;_pPre;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_pNode = _pNode-&gt;_pPre;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _pNode != l._pNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _pNode == l._pNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PNode _pNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="list与vector的差异"><a href="#list与vector的差异" class="headerlink" title="list与vector的差异"></a>list与vector的差异</h1><ol>
<li>list底层结构为带头双向循环链表，vector则为顺序表</li>
<li>由第一条，vector支持随机访问，访问某个元素效率为O(1)，而list则不支持，访问某个元素效率为O(n)</li>
<li>在插入或删除时，vector的效率为O(n)，并且可能涉及搬移元素、增容的问题，而list插入删除不需要搬移元素或增容等，效率为O(1)</li>
<li>由于vector低层为顺序表，所以内存上是连续空间，不容易造成内存碎片，缓存利用率低，list恰恰相反</li>
<li>vector的迭代器是原生态指针实现，而list则对原生态指针进行了封装</li>
<li>对于vector来说，插入元素时，要给所有迭代器重新赋值，因为插入元素可能导致增容，使原来的迭代器失效，删除时，当前迭代器需要重新赋值，否则会失效；对于list来说，插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响</li>
<li>使用场景：vector适合需要高效存储，随机访问，不关心插入删除效率；list适合需要大量插入删除操作，不进行随机访问的场景</li>
</ol>
<h1 id="list的模拟实现"><a href="#list的模拟实现" class="headerlink" title="list的模拟实现"></a>list的模拟实现</h1><p><a href="[https://github.com/Latsummer/FinishedProducts/tree/master/List%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0](https://github.com/Latsummer/FinishedProducts/tree/master/List模拟实现">list的模拟实现</a>)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>map和set的模拟实现</title>
    <url>/2020/07/20200717.html</url>
    <content><![CDATA[<h1 id="改造红黑树"><a href="#改造红黑树" class="headerlink" title="改造红黑树"></a>改造红黑树</h1><p>关联式容器存储的是K， V键值对，故在改造红黑树时，K为key类型，对于V来说，如果是set，则其为K类型，如果是map则为</p>
<p><code>pair&lt;K, V&gt;</code>，类型，除此之外，还需要一个仿函数类KeyOfValue来兼容map与set的大小比较，其迭代器也需要封装指针为一个类，迭代器的自加自减相当于红黑树的中序遍历</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTIterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> RBNode&lt;V&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> RBTIterator&lt;V&gt; Self;</span><br><span class="line">	<span class="built_in">RBTIterator</span>(Node* node);</span><br><span class="line">  </span><br><span class="line">	V&amp; <span class="keyword">operator</span>*();</span><br><span class="line"></span><br><span class="line">	V* <span class="keyword">operator</span>-&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; it);</span><br><span class="line"></span><br><span class="line">	Self&amp; <span class="keyword">operator</span>++();</span><br><span class="line"></span><br><span class="line">	Self <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	Self&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">	Self <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">	Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> RBNode&lt;V&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> RBTIterator&lt;V&gt; iterator;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RBTree</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> V&amp; val)</span></span>;</span><br><span class="line">  </span><br><span class="line">	<span class="function">iterator <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; data)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Node* <span class="title">leftMost</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">	<span class="function">Node* <span class="title">rightMost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="map和set的实现"><a href="#map和set的实现" class="headerlink" title="map和set的实现"></a>map和set的实现</h1><p>通过封装红黑树类，传入仿函数类和具体类型，修改等操作调用红黑树的接口，遍历操作通过迭代器完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MapKeyOfValue</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value.first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfValue&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">end</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt-&gt;<span class="built_in">empty</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">insert</span>(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">	&#123;</span><br><span class="line">		pair&lt;iterator, <span class="type">bool</span>&gt; ret = _rbt.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line">		<span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">Find</span>(<span class="built_in">pair</span>&lt;K, V&gt;(key, <span class="built_in">V</span>()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SetKeyOfValue</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> key;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfValue&gt;::iterator iterator;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">end</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">empty</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">Find</span>(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _rbt.<span class="built_in">insert</span>(key);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	RBTree&lt;K, K, SetKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="GitHub链接"><a href="#GitHub链接" class="headerlink" title="GitHub链接"></a>GitHub链接</h1><p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/map%E5%92%8Cset%E5%AE%9E%E7%8E%B0">map和set的实现-GitHub</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>set与map的基本使用及特性</title>
    <url>/2020/07/20200712.html</url>
    <content><![CDATA[<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><ol>
<li>实现—-&gt;目前使用搜索树实现（红黑树）</li>
<li>底层是一个存放KV结构的搜索树，但是此处K、V相同</li>
<li>set中只需要存放value</li>
<li>set中不能存放重复的元素</li>
<li>set中的元素不能修改，不支持修改的操作</li>
<li><strong>set默认比较是小于</strong>，可以通过修改仿函数，修改比较逻辑</li>
<li>迭代器遍历有序：底层顺序是二叉搜索树的中序遍历</li>
<li>迭代器只能读取内容，不能修改内容</li>
<li>插入：如果用迭代器指定插入位置，最终实际的插入位置可能不是指定的位置，此处的位置只是一个建议，新的元素的插入位置必须符合搜索树的性质</li>
<li>删除会导致当前删除位置的迭代器失效，但是不影响其他位置的迭代器</li>
<li>find：找到返回元素的迭代器，未找到返回end迭代器</li>
<li>count：获取指定元素在set中的个数，根据性质4，只用两个值，1或0</li>
</ol>
<span id="more"></span>
<h2 id="基本使用与遍历"><a href="#基本使用与遍历" class="headerlink" title="基本使用与遍历"></a>基本使用与遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span> &#125;;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">copy</span><span class="params">(s2)</span></span>;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = s2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != s2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  it++;</span><br><span class="line">&#125;<span class="comment">//2,3,8,10,11</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::const_iterator cit = s2.<span class="built_in">cbegin</span>();</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::reverse_iterator rit = s2.<span class="built_in">rbegin</span>();<span class="comment">//11， 10， 8， 3， 2</span></span><br></pre></td></tr></table></figure>
<p>set元素不能被修改</p>
<p>遍历有序：搜索树的中序遍历</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span> &#125;;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,8,10,11</span></span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,6,8,10,11</span></span><br><span class="line">s2.<span class="built_in">insert</span>(s2.<span class="built_in">begin</span>(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">//itreator只是一个建议，新插入的元素不一定是指定位置，最终插入位置需要遵循搜索树的性质</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,6,8,10,11,15</span></span><br><span class="line"><span class="type">int</span> arr2[] = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">0</span> &#125;;</span><br><span class="line">s2.<span class="built_in">insert</span>(arr2, arr2 + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//0,2,3,6,7,8,9,10,11,15,20</span></span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//set不会插入重复元素</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//0,2,3,6,7,8,9,10,11,15,20</span></span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除时候传入的位置必须有效</span></span><br><span class="line">s2.<span class="built_in">erase</span>(<span class="number">10</span>);<span class="comment">//删除10</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//0,2,3,6,7,8,9,11,15,20</span></span><br><span class="line">s2.<span class="built_in">erase</span>(s2.<span class="built_in">begin</span>());<span class="comment">//删除最左节点</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,6,7,8,9,10,11,15,20</span></span><br><span class="line"><span class="comment">//s2.erase(s2.end());//end指向最后一个元素的下一个位置，此时运行会报错</span></span><br><span class="line"><span class="comment">//PrntSet(s2);</span></span><br><span class="line">s2.<span class="built_in">erase</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);</span><br></pre></td></tr></table></figure>
<p>删除操作会导致当前位置的迭代器失效，不影响其他位置</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span> &#125;;</span><br><span class="line">	<span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator it = s2.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (it != s2.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NONE&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator it2 = s2.<span class="built_in">find</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">if</span> (it2 != s2.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; *it2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NONE&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//count返回：元素个数，存在返回1，否则0</span></span><br><span class="line">	cout &lt;&lt; s2.<span class="built_in">count</span>(<span class="number">11</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s2.<span class="built_in">count</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ol>
<li>实现：通过二叉搜索树实现（红黑树）</li>
<li>底层结构为存放kv键值对的搜索树，k和v不一定相同</li>
<li>map存放kv键值对，即pair数据</li>
<li>key不能重复，value可以重复</li>
<li>key不允许修改，value可以修改</li>
<li><strong>map默认比较是小于</strong>，按照key进行比较，可以通过修改仿函数，修改比较逻辑</li>
<li>迭代器遍历顺序：底层顺序是二叉搜索树的中序遍历，但是按照key的中序遍历进行</li>
<li>迭代器可以修改value，不能修改key</li>
<li>插入：如果用迭代器指定插入位置，最终实际的插入位置可能不是指定的位置，此处的位置只是一个建议，新的元素的插入位置必须符合搜索树的性质</li>
<li>删除会导致当前删除位置的迭代器失效，但是不影响其他位置的迭代器</li>
<li>find：找到返回元素的迭代器，未找到返回end迭代器，==按照key查找==</li>
<li>count：获取指定元素在set中的个数，根据性质4，只用两个值，1或0， ==按照key查找==</li>
<li>operator[ ]：可读可写可插入</li>
<li>at：如果key不存在，抛异常</li>
</ol>
<h2 id="基本使用以及遍历"><a href="#基本使用以及遍历" class="headerlink" title="基本使用以及遍历"></a>基本使用以及遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; m;<span class="comment">//key：字符串，value：数值</span></span><br><span class="line">  vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">((string)<span class="string">&quot;abc&quot;</span> + (<span class="type">char</span>)(i + <span class="string">&#x27;0&#x27;</span>), <span class="number">5</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(p);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;((string)<span class="string">&quot;zzl&quot;</span>+ (<span class="type">char</span>)(i + <span class="string">&#x27;0&#x27;</span>), <span class="number">14</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>((string)<span class="string">&quot;xyz&quot;</span>+ (<span class="type">char</span>)(i + <span class="string">&#x27;0&#x27;</span>), <span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">  <span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">copy</span><span class="params">(m2)</span></span>;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; m2.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//30</span></span><br><span class="line">  </span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt;::iterator it = m2.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span>(it != m2.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    it++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt;::iterator it = m2.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span>(it != m2.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    it-&gt;second = <span class="number">100</span>;<span class="comment">//map的非const迭代器支持修改value，但不支持修改key</span></span><br><span class="line">    it++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mm;</span><br><span class="line">  cout &lt;&lt; mm.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">//key不存在，抛异常</span></span><br><span class="line">  cout &lt;&lt; mm[<span class="number">2</span>] &lt;&lt; endl;<span class="comment">//key不存在，插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>map中key不能重复，但是value可以</li>
<li>迭代器解引用类型：pair</li>
<li>迭代器遍历顺序：key的递增顺序</li>
<li>非const迭代器支持value修改，不支持key修改</li>
<li>at：key不存在，抛异常</li>
<li>operator[]：key不存在，插入</li>
</ul>
<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">pair&lt;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ret = m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">3</span>));<span class="comment">//插入成功</span></span><br><span class="line">cout &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;<span class="comment">//3---&gt;3</span></span><br><span class="line">cout &lt;&lt; ret.second &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">ret = m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">10</span>));<span class="comment">//key重复，插入失败</span></span><br><span class="line">cout &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;<span class="comment">//3---&gt;3</span></span><br><span class="line">cout &lt;&lt; ret.second &lt;&lt; endl;<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p><code>pair&lt;iterator, bool&gt;</code>iterator</p>
<ul>
<li>map中kv键值对 对应的迭代器，bool：插入是否成功</li>
</ul>
<p>插入成功：iterator表示新插入的kv键值对的迭代器</p>
<p>插入失败：iterator表示已经存在的某个kv键值对的迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="type">int</span>, <span class="type">int</span>) m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1---&gt;1</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span>;<span class="comment">//2---&gt;2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//3---&gt;3</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">4</span>;<span class="comment">//4---&gt;4</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p><code>value&amp; operator[](key)</code></p>
<p><code>(*((this-&gt;insert(make_pair(k, mapped_type())).first)).second</code></p>
<ol>
<li>创建一个kv键值对：key value 默认值</li>
<li>执行插入操作，插入第一步创建的kv键值对</li>
<li>获取插入接口返回值的第一个迭代器成员<ol>
<li><code>prir&lt;iterator,bool&gt;.first</code> —-&gt; iterator —-&gt; 指向map中的一个键值对</li>
<li>插入成功：返回新的kv键值对的迭代器</li>
<li>插入失败：返回已经存在的键值key的kv键值对的迭代器</li>
</ol>
</li>
<li>解引用第三步拿到的迭代器</li>
<li>获取迭代器指向的kv键值对的value</li>
</ol>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="type">int</span>, <span class="type">int</span>) m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1---&gt;1</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span>;<span class="comment">//2---&gt;2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//3---&gt;3</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">4</span>;<span class="comment">//4---&gt;4</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">m.<span class="built_in">erase</span>(it);</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<span class="comment">//删除会导致指向当前位置的迭代器失效</span></span><br></pre></td></tr></table></figure>
<h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="type">int</span>, <span class="type">int</span>) m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1---&gt;1</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span>;<span class="comment">//2---&gt;2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//3---&gt;3</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">4</span>;<span class="comment">//4---&gt;4</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line">it = m.<span class="built_in">find</span>(<span class="number">3</span>);<span class="comment">//按照key查找，存在返回指向目标的迭代器，否则返回end迭代器</span></span><br><span class="line">it = m.<span class="built_in">find</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">//按照key值查找，存在返回1，否则返回0</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">count</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="multiset和multimap"><a href="#multiset和multimap" class="headerlink" title="multiset和multimap"></a>multiset和multimap</h1><p>与set及map最大的区别是其元素可以重复</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">-1</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">18</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : s)</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//multimap不提供[]操作符重载，at函数</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : m)</span><br><span class="line">		cout &lt;&lt; e.first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; e.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pair&lt;multimap&lt;int, int&gt;::iterator, multimap&lt;int, int&gt;::iterator&gt; p = m.equal_range(1);</span></span><br><span class="line">	<span class="keyword">auto</span> p = m.<span class="built_in">equal_range</span>(<span class="number">1</span>);</span><br><span class="line">	multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = p.first;</span><br><span class="line">	<span class="keyword">while</span> (it != p.second)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>stack、queue及priority_queue</title>
    <url>/2020/06/20200617.html</url>
    <content><![CDATA[<h1 id="stack的基本使用"><a href="#stack的基本使用" class="headerlink" title="stack的基本使用"></a>stack的基本使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="queue的基本使用"><a href="#queue的基本使用" class="headerlink" title="queue的基本使用"></a>queue的基本使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>();</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">15</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">19</span>);</span><br><span class="line"><span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>优先级队列存放自定义类型，自定义类型需要支持大小比较运算</p>
<ul>
<li><p>建大堆需要提供小于比较的仿函数类</p>
</li>
<li><p>建小堆需要提供大于比较的仿函数类</p>
</li>
</ul>
<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><p>STL组件：使用方式类似于函数的类 —-&gt; 重载圆括号 “( )” 的运算符重载函数</p>
<p>仿函数对象：由仿函数类创建的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仿函数类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Less</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; c1, <span class="type">const</span> T&amp; c2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1 &lt; c2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Less&lt;C&gt; lc;</span><br><span class="line">  <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">C <span class="title">c2</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="type">bool</span> ret = lc.<span class="built_in">operator</span>()(c1, c2);</span><br><span class="line">  ret = <span class="built_in">lc</span>(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>STL组件，stack，queue，priority_queue</p>
<p>通过适配器的设计模式定义的新的数据结构</p>
<p>适配器：把一种接口转化为另一种接口的方法</p>
<ol>
<li><p>stack：<code>template&lt; class T, class Container = deque&lt;T&gt; &gt; class stack</code></p>
<p> 实现：vector，list，deque  ==默认实现：deque==</p>
<p> stack实现规范：只要包含以下接口，都可以作为stack低层容器</p>
</li>
</ol>
<ul>
<li><p>Push_back —-&gt; push</p>
</li>
<li><p>Pop_back —-&gt;pop</p>
</li>
<li><p>front —-&gt; top</p>
</li>
<li><p>size —-&gt; size</p>
</li>
<li><p>Empty —-&gt; empty</p>
</li>
</ul>
<ol>
<li><p>Queue实现：list， deque   ==默认实现：deque==</p>
<p> queue实现规范：只要包含以下接口，都可以作为queue低层容器</p>
</li>
</ol>
<ul>
<li>Push_back —-&gt; push</li>
<li>Pop_back —-&gt; pop</li>
<li>front —-&gt; front</li>
<li>back —-&gt; back</li>
<li>size —-&gt; size</li>
<li>empty —-&gt; empty</li>
</ul>
<p>vector不能实现queue，因为它不提供pop_front接口</p>
<ol>
<li><p>Priority_queue实现：vector  deque，==默认实现：vector==</p>
<p> 实现规范：只要包含以下接口，其容器本身支持随机访问，都可以作为priority_queue的低层容器</p>
</li>
</ol>
<ul>
<li>Push_back —-&gt; push</li>
<li>Pop_back —-&gt; pop</li>
<li>Front —-&gt; top</li>
<li>Size —-&gt; size</li>
<li>Empty —-&gt; empty</li>
</ul>
<p>list不能实现priority_queue，因为其不支持随机访问</p>
<h1 id="duque-双端队列"><a href="#duque-双端队列" class="headerlink" title="duque 双端队列"></a>duque 双端队列</h1><p>逻辑连续，物理上不完全连续的线性表</p>
<p>实现：指针数组 + buffer —-&gt; 动态二维数组</p>
<ol>
<li>头插、头删、尾插、尾删时间复杂度都为O(1)，不需要移动元素</li>
<li>支持随机访问，但是随机访问的效率低于vector，需要进行位置换算</li>
<li>增容代价小，不需要拷贝所有元素内容。增容过程：开一个更大的指针数组，拷贝原始指针数组中的内容（指针），开新的buffer，buffer首地址存入新的指针数组，新的buffer存放新元素。原始存放元素的空间不需要更改</li>
<li>在中间位置插入数组，时间复杂度O(n)。</li>
</ol>
<p>stack：默认实现deque，deque实现stack的优势</p>
<ol>
<li>stack不需要随机访问。</li>
<li>vector增容代价比较大</li>
<li>list容易造成内存碎片，空间利用率低</li>
</ol>
<p>queue：默认实现deque，deque实现queue优势</p>
<ol>
<li>list容易造成内存碎片，空间利用率低</li>
</ol>
<p>priority_queue：默认实现vector，vector实现priority_queue的优势</p>
<ol>
<li>deque随机访问效率比较低，因为list不支持随机访问，所以不能用其实现</li>
</ol>
<ul>
<li><p>关于模拟实现<code>template&lt;T, Container, Compare&gt;</code></p>
<ul>
<li><p>模版参数：Compare：</p>
<ol>
<li>执行大小比较的逻辑 —-&gt; 通过仿函数实现</li>
<li>提供的仿函数不同，可以产生不同的堆结构。不需要修改源代码，极大的增加了代码的灵活性及通用性</li>
<li>如果是自定义类型数据，需要重载<code>&gt;</code> <code>&lt;</code>运算符</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h1><p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/stack.queue.pqm模拟实现">stack、queue及priority_queue的模拟实现—GitHub</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>-stakc -queue</tag>
      </tags>
  </entry>
  <entry>
    <title>string类的基本使用及常用接口</title>
    <url>/2020/06/20200607.html</url>
    <content><![CDATA[<h1 id="string类基本使用"><a href="#string类基本使用" class="headerlink" title="string类基本使用"></a>string类基本使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str;<span class="comment">//&quot;&quot;</span></span><br><span class="line">  <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;<span class="comment">//&quot;123&quot;</span></span><br><span class="line">  string str3 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//&quot;abc&quot;</span></span><br><span class="line">  <span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>, <span class="number">5</span>)</span></span>;<span class="comment">//&quot;01234&quot;</span></span><br><span class="line">  <span class="function">string <span class="title">cpy</span><span class="params">(str3)</span></span>;<span class="comment">//&quot;abc&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function">string <span class="title">str5</span><span class="params">(str4, <span class="number">2</span>, <span class="number">2</span>)</span></span>;<span class="comment">//&quot;23&quot; 从str4的第2个位置拿两个字符创建一个字符串</span></span><br><span class="line">  <span class="function">string <span class="title">str6</span><span class="params">(<span class="number">10</span>, a)</span></span>;<span class="comment">//&quot;aaaaaaaaaa&quot;</span></span><br><span class="line">  </span><br><span class="line">  str6 = str5;<span class="comment">//操作符重载</span></span><br><span class="line">  str6 = <span class="string">&quot;321&quot;</span>;</span><br><span class="line">  str6 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>访问容器的一种通用方式， 所有支持迭代器的容器，其迭代器的使用方式完全相同</p>
<p>迭代器的使用方式：类似于指针的使用方式，可以通过解引用获取元素内容，可以通过<code>++， --</code>进行位置移动</p>
<ul>
<li>begin迭代器：第一个元素的位置</li>
<li>end迭代器：最后一个元素的==下一个位置==</li>
<li>迭代器的范围，左闭右开<code>[begin, end)</code></li>
<li>迭代器是一个可读可写的接口</li>
</ul>
<blockquote>
<p>正向迭代器</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">  <span class="comment">//迭代器的遍历方式</span></span><br><span class="line">  string::iterator it = str.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span>(it != str.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//迭代器的解引用</span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//迭代器可读可写</span></span><br><span class="line">    *it = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="comment">//迭代器向后移动</span></span><br><span class="line">  	++it;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//#include&lt;vector&gt;</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt;::iterator vit = vec.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span>(vit != vec.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++vit;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反向迭代器</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;</span><br><span class="line">  string::reverse_iterator rit = str.<span class="built_in">rbegin</span>();</span><br><span class="line">  <span class="keyword">while</span>(rit != str.<span class="built_in">rend</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; *rit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//反向迭代器向前移动</span></span><br><span class="line">    ++rit;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正向const迭代器</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string::const_iterator cit = str.<span class="built_in">begin</span>();</span><br><span class="line">string::const_iterator cit2 = str.<span class="built_in">cbegin</span>();</span><br><span class="line"><span class="comment">//const迭代器建议使用const接口获取：c...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cit != str.<span class="built_in">cend</span>())</span><br><span class="line">&#123;<span class="comment">//const迭代器不支持写操作，其为只读迭代器</span></span><br><span class="line">  cout &lt;&lt; *cit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  ++cit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const创建的对象只能使用const接口</li>
</ul>
<p><strong>小结：</strong></p>
<ul>
<li>可读可写的迭代器<code>iterator, reverse_iterator</code></li>
<li>只读迭代器<code>const_iterator, const_reverse_iterator</code></li>
<li><code>begin();</code><ul>
<li><code>iterator begin()</code> —-&gt; 非const对象调用</li>
<li><code>const_iterator begin() const</code> —-&gt; const对象调用</li>
</ul>
</li>
<li><code>end();</code><ul>
<li><code>iterator end()</code> —-&gt; 非const对象调用</li>
<li><code>const_iterator end() const</code> —-&gt; const对象调用</li>
</ul>
</li>
<li><code>rbegin, rend</code>  同上，也有两个接口</li>
<li><code>cbegin, cend, crbegin, crend</code>  —-&gt; 都返回const迭代器</li>
</ul>
<h1 id="capacity等接口"><a href="#capacity等接口" class="headerlink" title="capacity等接口"></a>capacity等接口</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//size：返回有效字符的个数（常用）</span></span><br><span class="line">  <span class="type">int</span> ret = str.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//length：返回有效字符的个数</span></span><br><span class="line">  ret = str.<span class="built_in">length</span>();</span><br><span class="line">  <span class="comment">//capacity：可以存放的最大有效字符个数</span></span><br><span class="line">  ret = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> maxSize = str.<span class="built_in">max_size</span>();</span><br><span class="line">  </span><br><span class="line">  str.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">int</span> cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  str.<span class="built_in">resize</span>(<span class="number">20</span>);<span class="comment">//9之后用&#x27;\0&#x27;填充</span></span><br><span class="line">  size = str.<span class="built_in">size</span>();</span><br><span class="line">  cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  str.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">  size = str.<span class="built_in">size</span>();</span><br><span class="line">  cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  str.<span class="built_in">resize</span>(<span class="number">30</span>, <span class="string">&#x27;a&#x27;</span>);<span class="comment">//9之后用&#x27;a&#x27;填充</span></span><br><span class="line">  size = str.<span class="built_in">size</span>();</span><br><span class="line">  cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>n &gt; size &amp;&amp; n &gt; capacity ：增容（开新空间 + 拷贝 + 释放原有空间） + 新的位置赋值（如果没有给默认字符，默认是 ‘\0’ ）</li>
<li>n &lt; size：只修改size</li>
<li>当 n &gt; size &amp;&amp; n &lt; capacity：新的位置赋值（如果没有给赋值字符，默认赋值 ‘\0’  + 修改size  ）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">int</span> cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  str.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">  size = str.<span class="built_in">size</span>();</span><br><span class="line">  cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  str.<span class="built_in">reserve</span>(<span class="number">5</span>);</span><br><span class="line">  size = str.<span class="built_in">size</span>();</span><br><span class="line">  cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>reserve：调整容量大小：增加容量(原有基础上增加)，不修改size，==也可减少容量==，按需减小，如果要减小的容量小于size，不做任何操作，如果要减小的容量大于size，则进行减小操作。</p>
</li>
<li><p>PJ版string增容过程：如果为空字符串对象，初识容量大小为15，第一次增容为2倍，后续按照1.5倍增容。</p>
</li>
<li>可使用reserve提前开好空间，后续节省增容开销，提高代码效率</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string s;</span><br><span class="line">  </span><br><span class="line">  s.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="type">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">int</span> cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  s.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">  size = str.<span class="built_in">size</span>();</span><br><span class="line">  cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">  s.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">  size = str.<span class="built_in">size</span>();</span><br><span class="line">  cap = str.<span class="built_in">capacity</span>();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>shrink_to_fit()</code>缩小容量到合适范围</li>
</ul>
<h1 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h1><p><code>operator[]</code>可读可写接口，如<code>str[i]</code>，如果越界，非法访问</p>
<p><code>at</code>可读可写接口，如<code>str.at(i)</code>，但是代码可读性不强，如果越界，抛异常</p>
<p>范围for也可读可写，如果需要修改，则接收类型为引用类型，底层通过迭代器实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : str)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>back</code>返回最后一个字符</p>
<p><code>front</code>返回第一个字符</p>
<h1 id="string类对象的修改操作"><a href="#string类对象的修改操作" class="headerlink" title="string类对象的修改操作"></a>string类对象的修改操作</h1><ul>
<li><code>push_back</code> 尾插</li>
<li><code>append</code> 追加</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// a</span></span><br><span class="line">s.<span class="built_in">append</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// abb 追加两个b</span></span><br><span class="line">s.<span class="built_in">append</span>(<span class="string">&quot;cde&quot;</span>);<span class="comment">//  abbcde 追加cde</span></span><br><span class="line"></span><br><span class="line">string s2;</span><br><span class="line">s2.<span class="built_in">append</span>(s);<span class="comment">// 		abbcde 追加addcde</span></span><br><span class="line"></span><br><span class="line">string s3;</span><br><span class="line">s3.<span class="built_in">append</span>(s, <span class="number">3</span>, <span class="number">2</span>);<span class="comment">//	cd 从s的第三个位置追加两个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> strArr[] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">s3.<span class="built_in">append</span>(strArr, strArr + <span class="number">2</span>);<span class="comment">// cd34 //从strArr第二个位置之后追加到s3</span></span><br><span class="line">s3.<span class="built_in">append</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());<span class="comment">// cd34abbcde 通过迭代器追加</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>operator+=</code> +=操作符重载（==常用==）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s4;</span><br><span class="line">s4 += <span class="string">&#x27;1&#x27;</span>; <span class="comment">//1</span></span><br><span class="line">s4 += <span class="string">&#x27;234&#x27;</span>; <span class="comment">// 1234</span></span><br><span class="line">s4 += s;<span class="comment">// 1234abbcde</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>inster</code> 插入，除尾插之外插入效率较低O(n)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s4.<span class="built_in">inster</span>(<span class="number">0</span>, s3);<span class="comment">//cd1234abbcde</span></span><br><span class="line">s4.<span class="built_in">inster</span>(<span class="number">0</span>, s3, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">s4.<span class="built_in">inster</span>(s4.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">s4.<span class="built_in">inster</span>(s4.<span class="built_in">end</span>(), strArr + <span class="number">1</span>, strArr + <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>assign</code> 赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s4.<span class="built_in">assign</span>(<span class="string">&quot;11111&quot;</span>);<span class="comment">// 11111 效果和下面相同</span></span><br><span class="line">s4 = <span class="string">&quot;11111&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>erase</code> 删除</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s4.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">2</span>);<span class="comment">// 111</span></span><br><span class="line">s4.<span class="built_in">erase</span>(s4.<span class="built_in">begin</span>());<span class="comment">//11</span></span><br><span class="line">s4.<span class="built_in">erase</span>(s4.<span class="built_in">end</span>());<span class="comment">// 11 此时end迭代器位置非法，不做操作</span></span><br><span class="line">s4.<span class="built_in">erase</span>(s4.begin, s4.<span class="built_in">end</span>());<span class="comment">// &quot;&quot; 删完了</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>replace</code> 替换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">s.replace = (<span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;aa&quot;</span>);<span class="comment">// 12aa89 从第三个元素开始替换五个字符</span></span><br><span class="line">s.replace = (s.<span class="built_in">begin</span>() + <span class="number">1</span>, s.<span class="built_in">end</span>() - <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);<span class="comment">// 009 迭代器左闭右开，begin + 1第二个字符开始，end - 1指的是9</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>swap</code> 交换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2.<span class="built_in">swap</span>(s, s2);<span class="comment">//s2: 009, s: abc</span></span><br><span class="line"><span class="comment">//调用string成员函数交换</span></span><br><span class="line"><span class="built_in">swap</span>(s, s2);<span class="comment">//s2: abc, s: 009</span></span><br><span class="line"><span class="comment">//全局swap函数：内部调用string的成员函数swap完成交换</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="comment">//全局任何类型的swap函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>c_str</code>、<code>data</code>，返回C风格的字符串，即字符串首元素地址，返回值类型是<code>const char*</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr2 = s.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr2 = s.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>find</code>正向查找，<code>rfind</code>反向查找，找到第一个匹配的位置 就结束，返回值类型为<code>size_t</code><ul>
<li>找不到返回npos：<code>static const size_t npos = -1</code>， 可以通过与npos判断来确定是否找到</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;aaaaaaaaaa&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="type">size_t</span> pos2 = str.<span class="built_in">rfind</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>substr</code> 截取字符串</li>
<li><code>substr(pos, len)</code> 如果len大于从pos到结束位置的字符串长度，则把剩余字符串全部截取出来</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">string str2 = str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);<span class="comment">//01234 从索引为0开始截取五个字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>operator+</code>， 非成员函数，拼接字符串，返回一个string对象</p>
</li>
<li><p><code>operator&gt;</code>、<code>operator=</code>等关系运算符重载函数</p>
<ul>
<li>按照ASCII码值比较大小，与长度无关</li>
<li>从第一个字符开始，逐字符比较，直到遇到不相等的字符出现，或者同时结束，按照不相等的码值确定大小</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;9&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string s3 = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">bool</span> ret = s &gt; s2; <span class="comment">//true</span></span><br><span class="line">ret = s2 &gt; s3; <span class="comment">//false</span></span><br><span class="line">ret  = s &gt; s3; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>string支持<code>&gt;&gt;</code>和<code>&lt;&lt;</code><ul>
<li><code>cin</code>：遇到空格，结束内容读取，如果读取的内容有空格，可以使用<code>getline</code>接口，<code>getline(cin, s)</code>遇到换行结束。还可以指定结束的标记字符，标记字符不会存放在string对象当中<code>getline(cin, s, &#39;。&#39;)</code></li>
</ul>
</li>
</ul>
<h1 id="string常用接口"><a href="#string常用接口" class="headerlink" title="string常用接口"></a>string常用接口</h1><ol>
<li>遍历：<code>begin</code>,<code>end</code>，<code>operator[]</code></li>
<li>容量相关：<code>size</code>，<code>resize</code>，<code>reserve</code></li>
<li>修改：<code>+=</code>，<code>pop_back</code>，<code>swap</code></li>
<li>其他操作：<code>c_str</code>，<code>find</code>，<code>rfind</code>，<code>substr</code></li>
<li>非成员函数：比较，<code>&gt;&gt;</code>，<code>&lt;&lt;</code>，<code>getline</code></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>string类</tag>
      </tags>
  </entry>
  <entry>
    <title>一些库函数的模拟实现合辑（字符串+内存函数）</title>
    <url>/2020/03/20200310.html</url>
    <content><![CDATA[<h1 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h1><p>strlen函数是用来求字符串长度的，且包含 ‘ \\0 ’，它的参数是一个char* 类型的指针，返回值是一个int类型的整数</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">My_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> szie = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*a != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a++;</span><br><span class="line">		szie++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> szie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">25</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d 个字符（不包括休止符）\n&quot;</span>, My_strlen(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟函数思路是，指针（a）指向的内容不为 ‘ \\0 ’的时候，计数变量（size）自加，指针（a）自加指向下一个元素，直到遇到 ‘ \\0 ’，返回此时计数变量（szie）的值。</p>
<p>除了以上写法，还有一种递归写法，但是不经常使用，故不做过多介绍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">My_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*a != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span> + My_strlen(a + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h1><p>strcpy是字符串拷贝函数，拷贝当前字符串的内容至目标字符串，它的参数分别是两个char*类型的指针，其中一个为了安全起见使用const修饰，它指向字符串（被拷贝的字符串）的首元素地址，另一个则指向拷贝的字符串首元素地址，该函数的返回值类型是一个char *指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">My_strcpy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">char</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">NULL</span> || b == <span class="literal">NULL</span>)<span class="comment">//合法性检查</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (a[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	b[i] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//由于上面的循环没有加上‘\0’，此处手动添加</span></span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> b[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a);</span><br><span class="line">	My_strcpy(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a : %s\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b : %s\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的模拟实现思路也比较简单，利用 [ ]取下标的方式循环进行逐个赋值，最后给拷贝出的字符串手动添加休止符即可。</p>
<h1 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h1><p>字符串拼接函数，将两个字符串拼接起来的函数，它有两个参数，char*类型的指向被拼接字符串首元素地址的指针，和使用const修饰的char *类型的指向要拼接字符串首元素地址的指针。返回值是一个char *类型的指向拼接好的字符串首地址的指针。在使用的时候需要注意被拼接的字符串需要足够大的空间来存放拼接好的字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">My_strcat</span><span class="params">(<span class="type">char</span>* a,<span class="type">const</span> <span class="type">char</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">NULL</span> || b == <span class="literal">NULL</span>)<span class="comment">//合法性检查</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (a[end] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		end++;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a[end + i] = b[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	a[end + i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> b[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;b);</span><br><span class="line">	My_strcat(a, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\0&quot;</span>, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的实现思路是，先找到被拼接函数的休止符，并从此开始逐个将拼接字符串的值赋值进去，最后在末尾手动添加休止符。</p>
<h1 id="strcmp函数"><a href="#strcmp函数" class="headerlink" title="strcmp函数"></a>strcmp函数</h1><p>字符串比较函数，比较两个字符串的内容（按照字典序），参数是两个由const修饰的char*类型的分别指向两个字符串首地址的指针，返回值是一个int类型的整数。<br>如果两个字符串内容完全相同，则返回0<br>如果第一个字符串大于第二个字符串，返回一个大于0的整数，反之返回一个小于0的整数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">My_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(str1 != <span class="literal">NULL</span> &amp;&amp; str2 != <span class="literal">NULL</span>);<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="keyword">while</span> (*str1 != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *str2 != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;<span class="comment">//使用循环遍历</span></span><br><span class="line">		<span class="keyword">if</span> (*str1 &gt; *str2)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*str1 &lt; *str2)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="comment">//判断单个字符的ASCII码值大小</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;<span class="comment">//未比较出大小，指针指向元素后移</span></span><br><span class="line">			str1++;</span><br><span class="line">			str2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此时的情况是两个字符串同时结束或者其中有一个结束</span></span><br><span class="line">	<span class="keyword">if</span> (*str1 &gt; *str2)<span class="comment">//继续判断</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*str1 &lt; *str2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//同时结束，字符串内容相同</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str1[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> str2[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str1);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str2);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = My_strcmp(str1, str2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str1 = str2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str1 &gt; str2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str1 &lt; str2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数的模拟思路在注释中写出。</p>
<h1 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h1><p>这个函数（strstr（str1，str2））用于判断字符串str2是否为str1的子串，如果是则返回一个指向str2在str1中首次出现的指针，如果不是则返回NULL。由于仅仅是判断，所以两个char *类型的参数和char *类型的返回值均使用const修饰。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">My_strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(str1 != <span class="literal">NULL</span> &amp;&amp; str2 != <span class="literal">NULL</span>);<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="keyword">if</span> (*str2 == <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//如果str2为空字符串，则直接返回NULL</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* black = str1;</span><br><span class="line">	<span class="keyword">while</span>(*black != <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//遍历str1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* red = black;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* sub = str2;</span><br><span class="line">		<span class="keyword">while</span> (*red != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *sub != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; (*red == *sub))</span><br><span class="line">		&#123;<span class="comment">//从blakc指向的位置向后遍历</span></span><br><span class="line">		<span class="comment">//出现了str1和str2都没有结束并且red和sub指向的元素相同，进入循环</span></span><br><span class="line">			red++;</span><br><span class="line">			sub++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//此时有三种情况</span></span><br><span class="line">		<span class="comment">//1.sub指向了休止符</span></span><br><span class="line">		<span class="keyword">if</span> (*sub == <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//str2已经结束了，则说明str2一定是str1的子串</span></span><br><span class="line">			<span class="keyword">return</span> black;</span><br><span class="line">		<span class="comment">//此处先判断sub也是有考究的</span></span><br><span class="line">		<span class="comment">//假如两字符串同时结束，又能匹配成功</span></span><br><span class="line">		<span class="comment">//那么先判断red会直接返回NULL</span></span><br><span class="line">        <span class="comment">//2.red指向了休止符</span></span><br><span class="line">		<span class="keyword">if</span> (*red == <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//str1已经结束了，则说明str2一定不是str1的子串</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//3.出现了red和sub指向的元素不同</span></span><br><span class="line">		black++;<span class="comment">//str1和str2都没有结束，进度后移</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str1[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> str2[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str1);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str2);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* ret = My_strstr(str1, str2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p , %p&quot;</span>, str1, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数的模拟思路是：创建三个指针变量，black、red和sub<br>其中，black用来记录当前匹配的起始位置，red和sub用来匹配字符串1和字符串2是否相等，如果匹配成功则返回black，未成功则匹配起始位置后移，直到匹配成功或字符串1结束，返回NULL，具体细节在注释中写出。</p>
<h1 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h1><p>内存拷贝函数，将源内存（src）中的内容拷贝到目标内存（dest）中，为了考虑到函数的普适性，此处的dest，src以及返回值均使用void*类型的指针，只指向地址，不考虑所指向元素的大小，还要一个无符号整形的整数作为参数，来表示需要拷贝多少个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">My_memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">void</span>* src, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(dest != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>;<span class="comment">//限制单字节拷贝次数</span></span><br><span class="line">	<span class="type">void</span>* ret = dest;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;<span class="comment">//依次赋值</span></span><br><span class="line">		*(<span class="type">char</span>*)dest = *(<span class="type">char</span>*)src;<span class="comment">//强制转换成char*是为了单次后移一个字节</span></span><br><span class="line">		dest = (<span class="type">char</span>*)dest + <span class="number">1</span>;</span><br><span class="line">		src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> 	My_memcpy(b, a, <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体模拟思路在注释中给出，需要注意的是，它不能处理内存重叠的情况</p>
<h1 id="memmove函数"><a href="#memmove函数" class="headerlink" title="memmove函数"></a>memmove函数</h1><p>内存移动函数，将源内存（src）中的内容移动到目标内存（dest），它的功能同memcpy函数相同，但是它可以处理内存重叠的情况（从后往前拷贝）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">My_memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">void</span>* src, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(dest != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">void</span>* ret = dest;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		*(<span class="type">char</span>*)dest = *(<span class="type">char</span>*)src;</span><br><span class="line">		dest = (<span class="type">char</span>*)dest + <span class="number">1</span>;</span><br><span class="line">		src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">My_memmove</span><span class="params">(<span class="type">void</span>* dest, <span class="type">void</span>* src,<span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(dest != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="comment">//创建两个变量等于被强制转换成char*的dest和src</span></span><br><span class="line">	<span class="comment">//方便单个字节操作</span></span><br><span class="line">	<span class="type">char</span>* cdest = (<span class="type">char</span>*)dest;</span><br><span class="line">	<span class="type">char</span>* csrc = (<span class="type">char</span>*)src;</span><br><span class="line">	<span class="keyword">if</span> (csrc &lt; cdest &amp;&amp; cdest &lt; csrc + num)</span><br><span class="line">	&#123;<span class="comment">//判断是否重叠，若重叠则找到当前内存位置加上要移动的字节数减去一</span></span><br><span class="line">		<span class="type">char</span>* pdest = cdest + num - <span class="number">1</span>;</span><br><span class="line">		<span class="type">char</span>* psrc = csrc + num - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		&#123;<span class="comment">//从后往前依次赋值，对两块内存逐个操作</span></span><br><span class="line">			*pdest = *psrc;</span><br><span class="line">			pdest--;</span><br><span class="line">			psrc++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;<span class="comment">//不重叠直接调用memcpy函数（偷懒）</span></span><br><span class="line">		My_memcpy(dest, src, num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	My_memmove(b, a, <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的模拟思路在注释中写出。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的简单实现</title>
    <url>/2020/07/20200704.html</url>
    <content><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><ul>
<li>若左子树非空，则左子树上所有节点的值都小于根节点的值</li>
<li>若右子树非空，则右子树上所有节点的值都小根节点的值</li>
<li>左右子树也是二叉搜索树</li>
</ul>
<blockquote>
<p>上述条件反之亦可</p>
</blockquote>
<span id="more"></span>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>接近二分查找，最大查找次数为树的高度，平均查找次数Log<sub>2</sub> N</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line">  T _val;</span><br><span class="line">  BSTNode&lt;T&gt;* _left;</span><br><span class="line">  BSTNode&lt;T&gt;* _right;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">BSTNode</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">    :	_val(val)</span><br><span class="line">    , _left(<span class="literal">nullptr</span>)</span><br><span class="line">    , _right(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> BSTNode&lt;T&gt; Node;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(cur-&gt;_val == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur;        </span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &lt; val)&#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &gt; val)&#123;</span><br><span class="line">        cur = cur-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>如果树中已存在需要插入的数据，则不重复插入</p>
<p>插入位置为：叶子，子树不完全的非叶子结点，即度为0或者1的节点位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    _root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* cur = _root;</span><br><span class="line">  Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur)</span><br><span class="line">  &#123;</span><br><span class="line">    parent = ur;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_val == val)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &lt; val)</span><br><span class="line">      cur = cur-&gt;_right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cur = cur-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">  <span class="keyword">if</span>(parent-&gt;_val &lt; val)</span><br><span class="line">    parent-&gt;_right = Node;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    parent-&gt;_left = cur;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>有以下四种情况</p>
<pre><code>a. 要删除的结点无孩子结点
b. 要删除的结点只有左孩子结点
c. 要删除的结点只有右孩子结点
d. 要删除的结点有左、右孩子结点
</code></pre><ul>
<li><p>左子树：左子树的最右节点是所有左子树中最大的节点</p>
</li>
<li><p>右子树：右子树的最左节点是所有右子树中最小的节点</p>
</li>
</ul>
<p>删除度为2的节点：</p>
<ol>
<li>找到此节点中，左子树的最右节点或者右子树的最左节点</li>
<li>要删除的节点val替换为最左节点或者最右节点</li>
<li>真正要删除的是最左或者最右节点</li>
<li>此时问题转换为删除度为0或者度为1的节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  Node* cur = _root;</span><br><span class="line">  Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="keyword">if</span> (cur-&gt;_val == val) &#123;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &lt; val)&#123;</span><br><span class="line">		  parent = cur;</span><br><span class="line">		  cur = cur-&gt;_right;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">else</span> &#123;</span><br><span class="line">		  parent = cur;</span><br><span class="line">		  cur = cur-&gt;_left;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否找到需要删除的节点</span></span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//删除操作</span></span><br><span class="line">  <span class="comment">//1. 叶子</span></span><br><span class="line">  <span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="keyword">if</span> (cur == _root)</span><br><span class="line">	  &#123;</span><br><span class="line">		  _root = <span class="literal">nullptr</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">			parent-&gt;_left = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			parent-&gt;_right = <span class="literal">nullptr</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">delete</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.左孩子为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="keyword">if</span> (cur == _root)</span><br><span class="line">		  _root = cur-&gt;_right;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line">		  <span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">			  parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">		  <span class="keyword">else</span></span><br><span class="line">			  parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">delete</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.右孩子为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="keyword">if</span> (cur == _root)</span><br><span class="line">		  _root = cur-&gt;_left;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line">		  <span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">			  parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">		  <span class="keyword">else</span></span><br><span class="line">			  parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">delete</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.左右孩子都存在</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="comment">//a.照最左或最右节点</span></span><br><span class="line">	  <span class="comment">//找右子树的最左节点</span></span><br><span class="line">	  Node* leftMostChild = cur-&gt;_right;</span><br><span class="line">	  Node* parent = cur;</span><br><span class="line">	  <span class="keyword">while</span> (leftMostChild-&gt;_left)</span><br><span class="line">	  &#123;</span><br><span class="line">		  parent = leftMostChild;</span><br><span class="line">		  leftMostChild = leftMostChild-&gt;_left;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">//b.值替换</span></span><br><span class="line">	  cur-&gt;_val = leftMostChild-&gt;_val;</span><br><span class="line">	  <span class="comment">//c.删除最左或最右节点</span></span><br><span class="line">	  <span class="keyword">if</span> (parent-&gt;_left == leftMostChild)</span><br><span class="line">		  parent-&gt;_left = leftMostChild-&gt;_right;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">		  parent-&gt;_right = leftMostChild-&gt;_right;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">delete</span> leftMostChild;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>vector的基本使用和模拟实现</title>
    <url>/2020/06/20200611.html</url>
    <content><![CDATA[<h1 id="vector的基本使用"><a href="#vector的基本使用" class="headerlink" title="vector的基本使用"></a>vector的基本使用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; v2;</span><br><span class="line">vector&lt;string&gt; v3;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//10个5</span></span><br><span class="line"></span><br><span class="line">string s2 = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">v5</span><span class="params">(s2.begin(), s2.end())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">v6</span><span class="params">(v5)</span></span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="vector的遍历"><a href="#vector的遍历" class="headerlink" title="vector的遍历"></a>vector的遍历</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">v</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  *it = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  it++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span>&amp; ch : v)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  ch = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  v[i] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : v)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>反向迭代器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">v</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;::reverse_iterator rit = s.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span>(rit != s.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; *rit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  rit++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只读迭代器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVec</span><span class="params">(<span class="type">const</span> vector&lt;T&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vector&lt;T&gt;::const_iterator cit = v.<span class="built_in">cbegin</span>();</span><br><span class="line">  <span class="keyword">while</span>(it != c.<span class="built_in">cend</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; *cit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cit++;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  vector&lt;T&gt;::const_reverse_iterator it = v.<span class="built_in">crbegin</span>();</span><br><span class="line">  <span class="keyword">while</span>(crit != c.<span class="built_in">crend</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; *icrt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    crit++;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>operator[ ]</code>遍历越界，调试版本产生断言错误</p>
<p><code>at( )</code>遍历越界，抛异常</p>
<h1 id="vector容量"><a href="#vector容量" class="headerlink" title="vector容量"></a>vector容量</h1><ul>
<li><p>增容：如果为空，容量为0</p>
<p>  PJ版本中增容按照大于1.5倍进行，SGI一般是2倍</p>
</li>
</ul>
<p><code>resize(n, val)</code>：如果不给val参数，则使用默认值：内置类型 —-&gt; 0；自定义类型 —-&gt; 调用无参构造</p>
<ul>
<li><code>data()</code> 返回首地址指针</li>
</ul>
<h1 id="vector修改操作"><a href="#vector修改操作" class="headerlink" title="vector修改操作"></a>vector修改操作</h1><ul>
<li><code>insert()</code>插入，==参数需要迭代器==，在pos之前插入元素</li>
<li><code>erase()</code>删除pos之前的数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vectot&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">5</span>, <span class="number">0</span>);<span class="comment">//000001</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), a + <span class="number">1</span>, a + <span class="number">3</span>);<span class="comment">//23000001  表示左闭右开的范围（a + 1 , a + 3]</span></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>push_back()</code>尾插；·<code>pop_back()</code>尾删</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>
<p>==迭代器失效问题==：迭代器指向的位置，空间被释放或者变成一个不可访问的位置</p>
<ol>
<li>空间发生了变化，就会导致原来的迭代器失效 —-&gt; push_back, insert, reserve, resize, assign</li>
<li>位置错位 —-&gt; erase</li>
</ol>
<p>解决方案：</p>
<ol>
<li>重新获取迭代器</li>
<li>非删除接口：begin，end</li>
<li>erase：直接获取其返回值，其返回值指向被删除元素的下一个元素的迭代器。<strong>潜在的问题：</strong>如果传入的迭代器为最后一个元素的迭代器，获取的返回值为end迭代器，也是一个不能访问的位置</li>
</ol>
<ul>
<li><code>emplace</code>、<code>emplace_back</code>插入（更高效）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;B&gt; v;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), b);<span class="comment">//12  插入</span></span><br><span class="line">v.<span class="built_in">emplace</span>(v.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">4</span>);<span class="comment">//12  34 构造 + 插入</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">emplace</span>(v.<span class="built_in">begin</span>(), b2);</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(b2);</span><br><span class="line">v.<span class="built_in">emplace_back</span>(b);</span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>);<span class="comment">//构造 + 尾插</span></span><br></pre></td></tr></table></figure>
<h1 id="vector的实现"><a href="#vector的实现" class="headerlink" title="vector的实现"></a>vector的实现</h1><p><code>start</code> <code>finish</code> <code>end_of_storage</code> T * 类型</p>
<ul>
<li><code>start</code> 空间的首地址，第一个元素的首地址</li>
<li><code>finish</code> 最后一个元素的结束位置</li>
<li><code>end_of_storage</code> 空间的结束位置</li>
</ul>
<p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/vector%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">vector的模拟实现GitHub链接</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的扫雷游戏（是真的简单）</title>
    <url>/2020/01/20200101.html</url>
    <content><![CDATA[<h2 id="首先我们需要分析扫雷游戏"><a href="#首先我们需要分析扫雷游戏" class="headerlink" title="首先我们需要分析扫雷游戏"></a>首先我们需要分析扫雷游戏</h2><p>在微软的扫雷游戏中，开始游戏后，雷已经随机埋好，当鼠标点击一个待排查点，假如是雷，则游戏结束，假如不是雷，则会显示周围一圈格子中雷的数量。实际上游戏的机制非常简单，但需要实现，还是得仔细分析。</p>
<ol>
<li>需要两个数组（字符数组），一个用以存放雷的位置，一个用以向用户显示当前游戏状态，为了方便检测游戏中四条边的雷的数量，这里应将实际数组扩大一圈，比如游戏中看到的是8x8的格子，而在其内部应有一个10x10的二维数组来存放这些信息（通俗来讲就是扩大了一圈）。</li>
<li>利用srand函数和rand函数来生成随机坐标用以埋雷。用字符 ‘0’ 表示该地方没有雷，用字符 ‘1’ 来表示改地方有雷，最终给玩家显示的是一个由字符 ’ * ’ 组成的格子，当输入坐标时，若此地方有雷，游戏结束，没有雷则显示附近一圈的雷的数量。</li>
<li>用 ‘0’ ‘1’ 字符来贮存雷的原因是他们两个的ascii码值恰好差1，在计算当前格子周围有几个雷的时候，仅需将周围八个格子之和减去八乘以当前格子再加上字符 ‘0 ’即可。</li>
<li><strong>两个二维字符数组一一对应！！</strong></li>
</ol>
<span id="more"></span>
<h1 id="话不多说，上货"><a href="#话不多说，上货" class="headerlink" title="话不多说，上货"></a>话不多说，上货</h1><p>头文件放一些函数声明和预处理指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span><span class="comment">//上边；两个用以生成随机数字</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"><span class="comment">//设置棋盘的大小</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS ROW+2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS COL+2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EASY_COUNT 10</span></span><br><span class="line"><span class="comment">//用来设置雷的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span> <span class="built_in">set</span>)</span>; </span><br><span class="line"><span class="comment">//创建两个二维字符数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"><span class="comment">//显示当前棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">int</span> row,<span class="type">int</span> col)</span>;</span><br><span class="line"><span class="comment">//利用随机数设置雷的坐标</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> main[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"><span class="comment">//用来检测当前坐标是否有雷或者周围有几个雷</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;扫雷12_29.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;开始游戏\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> mine[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;<span class="comment">//存放雷‘0’ or ‘1’</span></span><br><span class="line">	<span class="type">char</span> show[ROWS][COLS] = &#123; <span class="number">0</span> &#125;;<span class="comment">//存放排雷信息‘*’</span></span><br><span class="line">	InitBoard(mine, ROWS, COLS, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	InitBoard(show, ROWS, COLS, <span class="string">&#x27;*&#x27;</span>);<span class="comment">//初始化</span></span><br><span class="line">	<span class="comment">/*DisplayBoard(mine, ROW, COL);</span></span><br><span class="line"><span class="comment">	printf(&quot;\n&quot;);  测试用  ^_^</span></span><br><span class="line"><span class="comment">	DisplayBoard(show, ROW, COL);*/</span></span><br><span class="line">	SetMine(mine, ROW, COL);</span><br><span class="line">	DisplayBoard(show, ROW, COL);</span><br><span class="line">	FindMine(mine, show, ROW, COL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span><span class="comment">//菜单</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;##################\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;#### 1. PLAY #####\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;#### 0. EXIT #####\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;##################\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span><span class="comment">//选择进入游戏或退出游戏</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span><span class="comment">//do while循环非常有必要！！</span></span><br><span class="line">	&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择：&gt;   &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">		<span class="keyword">switch</span> (input)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		    game();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;退出游戏\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请正确输入！！！\n\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));<span class="comment">//随机数种子，重要！！</span></span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>游戏本体</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;扫雷12_29.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;<span class="comment">//初始化棋盘</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			board[i][j] = <span class="built_in">set</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;<span class="comment">//用来显示棋盘</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------------------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= col; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, board[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;<span class="comment">//埋雷</span></span><br><span class="line">	<span class="type">int</span> count = EASY_COUNT;</span><br><span class="line">	<span class="keyword">while</span>(count)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = rand() % row + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> y = rand() % col + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (mine[x][y] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			mine[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			count--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GetMineCount</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;<span class="comment">//计算当前格子周围有多少个雷，用static修饰，只在此源文件内调用</span></span><br><span class="line">	<span class="keyword">return</span> mine[x - <span class="number">1</span>][y] +</span><br><span class="line">		mine[x - <span class="number">1</span>][y - <span class="number">1</span>] +</span><br><span class="line">		mine[x][y - <span class="number">1</span>] +</span><br><span class="line">		mine[x + <span class="number">1</span>][y - <span class="number">1</span>] +</span><br><span class="line">		mine[x + <span class="number">1</span>][y] +</span><br><span class="line">		mine[x + <span class="number">1</span>][y + <span class="number">1</span>] +</span><br><span class="line">		mine[x][y + <span class="number">1</span>] +</span><br><span class="line">		mine[x - <span class="number">1</span>][y + <span class="number">1</span>] - <span class="number">8</span> * <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;<span class="comment">//下坐标后判断</span></span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> win = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (win&lt;row * col - EASY_COUNT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入想排查坐标：&gt; &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= row &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= col)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mine[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;BOOOOOM!\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;你没了\n&quot;</span>);</span><br><span class="line">				DisplayBoard(mine, row, col);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> count = GetMineCount(mine, x, y);</span><br><span class="line">				show[x][y] =  count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				DisplayBoard(show, row, col);</span><br><span class="line">				win++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入坐标有误！\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (win == row*col - EASY_COUNT)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;YOU WIN !\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="github扫雷游戏链接"><a href="#github扫雷游戏链接" class="headerlink" title="github扫雷游戏链接"></a><a href="https://github.com/Latsummer/FinishedProducts/tree/master/%E6%89%AB%E9%9B%B7_12_29">github扫雷游戏链接</a></h3><h3 id="以上就是全部内容惹。"><a href="#以上就是全部内容惹。" class="headerlink" title="以上就是全部内容惹。"></a>以上就是全部内容惹。</h3>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>小作品</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树与堆的概念以及实现</title>
    <url>/2020/04/20200428.html</url>
    <content><![CDATA[<h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ol>
<li>根没有父节点</li>
<li>子树互不相交</li>
<li>节点数 = 边数 + 1</li>
<li>节点的度 = 子树的个数</li>
<li>树的度：最大节点个数</li>
<li>树的高度：最大层次</li>
</ol>
<span id="more"></span>
<blockquote>
<p>树的表示：双亲表示法，孩子表示法，孩子兄弟表示法</p>
</blockquote>
<ul>
<li>满二叉树：除过叶子，其他节点度都为二，并且每层都是满的</li>
<li>完全二叉树：除过最后一层，剩余结构是一个满二叉树，并且最后一层的节点从左向右中间无间隔</li>
</ul>
<blockquote>
<p>满二叉树一定是完全二叉树</p>
<p>完全二叉树不一定是满二叉树</p>
</blockquote>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h4 id="二叉树的节点总数"><a href="#二叉树的节点总数" class="headerlink" title="二叉树的节点总数"></a>二叉树的节点总数</h4><blockquote>
<p>n0 + n1 + n2 = 二叉树的节点总数</p>
<p>n1 + 2 * n2 = 二叉树边的总数</p>
<p>节点总数 - 1 = 边的个数</p>
<p>n0 + n1 + n2 - 1 = n1 + 2 * n2</p>
<p>n0 = n2 + 1</p>
</blockquote>
<p>满二叉树高度：<br>log⁡2(N+1) \\log_2(N+1) log2​(N+1)</p>
<p>∵2h−1\=N∴h\=log2(N+1) \\because2\^h - 1 =N \\quad \\therefore h = log_2(N+1) ∵2h−1\=N∴h\=log2​(N+1)</p>
<p>_<strong>满二叉树的节点一定为奇数</strong>_</p>
<h4 id="二叉树的存储形式"><a href="#二叉树的存储形式" class="headerlink" title="二叉树的存储形式"></a>二叉树的存储形式</h4><ol>
<li>顺序结构：<strong>适合存放完全二叉树，没有空间浪费</strong></li>
</ol>
<p>规则：从第一层开始存放，直到最后一层，每层从左向右依次存放，如果中间有空节点，保留空节点的位置</p>
<blockquote>
<p>完全二叉树</p>
<p>父子节点的位置：</p>
<p>parent： left_child = 2 x parent + 1</p>
<p> right_child = 2 x parent +2</p>
<p>child : parent = (child - 1) / 2</p>
</blockquote>
<ol>
<li>链式结构：_<strong>适合存放一般二叉树</strong>_</li>
</ol>
<p>二叉链：数据，指向左右孩子的指针</p>
<p>三叉链：数据，指向左右孩子的指针 + 指向父亲的指针</p>
<p>完全二叉树：总数 2n</p>
<p>度为1的节点出现在<strong>倒数第二层</strong></p>
<p>度为一的节点个数：</p>
<p> 节点个数为偶数：n1 = 1</p>
<p> 节点个数为奇数：n1 = 0</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote>
<p>大小堆：</p>
<p>大堆：每个父节点都比子节点大</p>
<p>小堆：每个父节点都比子节点小</p>
</blockquote>
<h4 id="堆的向下调整："><a href="#堆的向下调整：" class="headerlink" title="堆的向下调整："></a>堆的向下调整：</h4><p><strong>隐含的前提：当前需要调整的位置以下的子结构已经是一个堆。</strong></p>
<p><strong>1. 小堆</strong></p>
<p>从当前需要调整的位置开始，（parent）</p>
<p>a. 从左右孩子中选一个最小的（child）</p>
<p>b. 如果最小的child仍然小于parent：</p>
<p> 交换child和parent</p>
<p> 更新：parent = child，child = 2 * parent + 1</p>
<p> 如果child没有越界，跳到a，继续执行</p>
<p> 如果最小的child仍然大于parent：结束调整</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shiftDown</span><span class="params">(HPDataType* a, <span class="type">int</span> size, <span class="type">int</span> parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; a[child + <span class="number">1</span>] &lt; a[child])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="keyword">if</span> (a[child] &lt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			Swap(a, child, parent);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 大堆</strong></p>
<p>从当前需要调整的位置开始，（parent）</p>
<p>a. 从左右孩子中选一个最大的（child）</p>
<p>b. 如果最大的child仍然大于parent：</p>
<p> 交换child和parent</p>
<p> 更新：parent = child，child = 2 * parent + 1</p>
<p> 如果child没有越界，跳到a，继续执行</p>
<p> 如果最大的child仍然小于parent：结束调整</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shiftDown</span><span class="params">(HPDataType* a, <span class="type">int</span> size, <span class="type">int</span> parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; a[child + <span class="number">1</span>] &gt; a[child])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			Swap(a, child, parent);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆的向上调整"><a href="#堆的向上调整" class="headerlink" title="堆的向上调整"></a>堆的向上调整</h4><p>从当前位置开始（child），与父节点进行比较，如果是大堆，则若孩子大于父亲，交换二者，如果是小堆，则若孩子小于父亲，交换二者，直到不能交换为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shiftUp</span><span class="params">(HPDataType* a, <span class="type">int</span> child)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//小堆</span></span><br><span class="line">	<span class="comment">/*int parent = (child - 1) / 2;</span></span><br><span class="line"><span class="comment">	while (child &gt; 0)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		if (a[child] &lt; a[parent])</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			Swap(a, child, parent);</span></span><br><span class="line"><span class="comment">			child = parent;</span></span><br><span class="line"><span class="comment">			parent = (child - 1) / 2;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="comment">//大堆</span></span><br><span class="line">	<span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			Swap(a, child, parent);</span><br><span class="line">			child = parent;</span><br><span class="line">			parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> HPDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HPDataType* _a;</span><br><span class="line">	<span class="type">int</span> _size;</span><br><span class="line">	<span class="type">int</span> _capacity;</span><br><span class="line">&#125;Heap;</span><br></pre></td></tr></table></figure>
<p>堆的实现使用了线性表来存储数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(HPDataType* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = a[left];</span><br><span class="line">	a[left] = a[right];</span><br><span class="line">	a[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆的构建</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapCreate</span><span class="params">(Heap* hp, HPDataType* a, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	hp-&gt;_a = (HPDataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HPDataType)* size);</span><br><span class="line">	<span class="built_in">memcpy</span>(hp-&gt;_a, a, <span class="keyword">sizeof</span>(HPDataType)* size);</span><br><span class="line">	hp-&gt;_size = size;</span><br><span class="line">	hp-&gt;_capacity = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> parent = (size - <span class="number">2</span>) / <span class="number">2</span>; parent &gt;= <span class="number">0</span>; parent--)</span><br><span class="line">	&#123;</span><br><span class="line">		shiftDown(hp-&gt;_a, size, parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆得插入与删除，堆得插入则直接在线性表末尾插入，然后进行向上调整，堆得删除则需先交换堆顶与最后一个叶子结点，接着线性表进行尾删，然后进行向下调整</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆的插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapPush</span><span class="params">(Heap* hp, HPDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (hp-&gt;_size &gt;= hp-&gt;_capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		hp-&gt;_capacity *= <span class="number">2</span>;</span><br><span class="line">		hp-&gt;_a = (HPDataType*)<span class="built_in">realloc</span>(hp-&gt;_a, <span class="keyword">sizeof</span>(HPDataType)* hp-&gt;_capacity);</span><br><span class="line">	&#125;</span><br><span class="line">	hp-&gt;_a[hp-&gt;_size++] = x;</span><br><span class="line">	shiftUp(hp-&gt;_a, hp-&gt;_size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆的删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapPop</span><span class="params">(Heap* hp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (hp-&gt;_size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Swap(hp-&gt;_a, <span class="number">0</span>, hp-&gt;_size - <span class="number">1</span>);</span><br><span class="line">		hp-&gt;_size--;</span><br><span class="line">		shiftDown(hp-&gt;_a, hp-&gt;_size, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><ol>
<li>前序（先序）遍历，先访问父节点，在访问左孩子，最后访问右孩子。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryTreePrevOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;_data);</span><br><span class="line">		BinaryTreePrevOrder(root-&gt;_left);</span><br><span class="line">		BinaryTreePrevOrder(root-&gt;_right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归方式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryTreePrevOrderNoR</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack st;</span><br><span class="line">	StackInit(&amp;st);</span><br><span class="line">	BTNode* cur = root;</span><br><span class="line">	BTNode* top = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur || !StackEmpty(&amp;st))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, cur-&gt;_data);</span><br><span class="line">			StackPush(&amp;st, cur);</span><br><span class="line">			cur = cur-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line">		top = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line">		cur = top-&gt;_right;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归方式，使用到了栈</p>
</blockquote>
<ol>
<li>中序遍历，先访问左孩子，在访问父节点，最后访问右孩子。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryTreeInOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">	&#123;</span><br><span class="line">		BinaryTreeInOrder(root-&gt;_left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;_data);</span><br><span class="line">		BinaryTreeInOrder(root-&gt;_right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归方式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryTreeInOrderNoR</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack st;</span><br><span class="line">	StackInit(&amp;st);</span><br><span class="line">	BTNode* cur = root;</span><br><span class="line">	BTNode* top = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur || !StackEmpty(&amp;st))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			StackPush(&amp;st, cur);</span><br><span class="line">			cur = cur-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line">		top = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, top-&gt;_data);</span><br><span class="line">		cur = top-&gt;_right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归，使用到了栈</p>
</blockquote>
<ol>
<li>后序遍历，先访问左孩子，后访问右孩子，最后访问父节点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryTreePostOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">	&#123;</span><br><span class="line">		BinaryTreePostOrder(root-&gt;_left);</span><br><span class="line">		BinaryTreePostOrder(root-&gt;_right);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;_data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归方式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryTreePostOrderNoR</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack st;</span><br><span class="line">	StackInit(&amp;st);</span><br><span class="line">	BTNode* cur = root;</span><br><span class="line">	BTNode* top = <span class="literal">NULL</span>;</span><br><span class="line">	BTNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur || !StackEmpty(&amp;st))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			StackPush(&amp;st, cur);</span><br><span class="line">			cur = cur-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line">		top = StackTop(&amp;st);</span><br><span class="line">		<span class="keyword">if</span> (!top-&gt;_right || top-&gt;_right == prev)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, top-&gt;_data);</span><br><span class="line">			StackPop(&amp;st);</span><br><span class="line">			prev = top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cur = top-&gt;_right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归方式，使用到了栈</p>
</blockquote>
<ol>
<li>层序遍历，从第一层开始，每层向后遍历。</li>
</ol>
<blockquote>
<p>使用队列实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryTreeLevelOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	Queue q;</span><br><span class="line">	QueueInit(&amp;q);</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">		QueuePush(&amp;q, root);</span><br><span class="line">	<span class="keyword">while</span> (!QueueEmpty(&amp;q))</span><br><span class="line">	&#123;</span><br><span class="line">		BTNode* front = QueueFront(&amp;q);</span><br><span class="line">		QueuePop(&amp;q);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, front-&gt;_data);</span><br><span class="line">		<span class="keyword">if</span> (front-&gt;_left)</span><br><span class="line">			QueuePush(&amp;q, front-&gt;_left);</span><br><span class="line">		<span class="keyword">if</span> (front-&gt;_right)</span><br><span class="line">			QueuePush(&amp;q, front-&gt;_right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的构建"><a href="#二叉树的构建" class="headerlink" title="二叉树的构建"></a>二叉树的构建</h4><p>此处使用先序遍历的方式建树，‘ # ’代表数中的空节点NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BTNode* <span class="title function_">BinaryTreeCreate</span><span class="params">(BTDataType* a,<span class="type">int</span> n, <span class="type">int</span>* pi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[*pi] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; *pi &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		BTNode* root = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">		root-&gt;_data = a[*pi];</span><br><span class="line">		(*pi)++;</span><br><span class="line">		root-&gt;_left = BinaryTreeCreate(a, n, pi);</span><br><span class="line">		(*pi)++;</span><br><span class="line">		root-&gt;_right = BinaryTreeCreate(a, n, pi);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的节点个数问题"><a href="#二叉树的节点个数问题" class="headerlink" title="二叉树的节点个数问题"></a>二叉树的节点个数问题</h4><p>拆分成左右子数的问题，用递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树节点个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinaryTreeSize</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> BinaryTreeSize(root-&gt;_left)</span><br><span class="line">		+ BinaryTreeSize(root-&gt;_right)</span><br><span class="line">		+ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树叶子节点个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinaryTreeLeafSize</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!root-&gt;_left &amp;&amp; !root-&gt;_right)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> BinaryTreeLeafSize(root-&gt;_left)</span><br><span class="line">		+ BinaryTreeLeafSize(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树第k层节点个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinaryTreeLevelKSize</span><span class="params">(BTNode* root, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> BinaryTreeLevelKSize(root-&gt;_left, k - <span class="number">1</span>)</span><br><span class="line">		+ BinaryTreeLevelKSize(root-&gt;_right, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>从AVL树到红黑树(的插入)</title>
    <url>/2020/07/20200713.html</url>
    <content><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><ul>
<li>左右子树都是AVL树</li>
<li>左右子树高度差的绝对值不超过1（-1/0/1）（一般：右子树高度 - 左子树高度）</li>
<li>如果一棵二叉搜索树树高度平衡的，它就是AVL树。如果它有n个节点，其高度可保持在O(log<sub>2</sub>N)，搜索时间复杂度O(log<sub>2</sub>N)</li>
</ul>
<span id="more"></span>
<h2 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line">	T _value;</span><br><span class="line">	<span class="type">int</span> _bf;<span class="comment">//平衡因子</span></span><br><span class="line">	AVLNode&lt;T&gt;* _left;</span><br><span class="line">	AVLNode&lt;T&gt;* _right;</span><br><span class="line">	AVLNode&lt;T&gt;* _parent;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AVLNode</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">		: _value(val)</span><br><span class="line">		, _bf(<span class="number">0</span>)</span><br><span class="line">		, _left(<span class="literal">nullptr</span>)</span><br><span class="line">		, _right(<span class="literal">nullptr</span>)</span><br><span class="line">		, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入节点后：必须要更新平衡因子</p>
<p>可能需要更新平衡因子的节点：</p>
<ol>
<li>新插入节点中所有足祖先节点</li>
<li>如果节点的子树高度发生变化，则需要更新</li>
</ol>
</blockquote>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol>
<li><p>二叉搜索树的插入</p>
</li>
<li><p>从新插入的节点对应的父节点位置开始更新平衡因子</p>
</li>
<li><p>在第二步的过程中，平衡因子更新之后：</p>
<ol>
<li><p>平衡因子：0    —-&gt;     停止更新</p>
</li>
<li><p>平衡因子：-1/1    —-&gt;    继续向上更新</p>
</li>
<li><p>平衡因子：-2/2    —-&gt;    旋转</p>
<ol>
<li><p>单旋：</p>
<ol>
<li><p>左单旋：右边的右边高，<code>parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1</code></p>
<p> 修改链接：parent、subRL、subR</p>
<p> ​                    parent-&gt;_right : subRL、subR-&gt;left : parent</p>
<p> 更新平衡因子：parent、subR：0</p>
</li>
<li><p>右单旋：左边的左边高，<code>parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1</code></p>
<p> 修改链接：subL、subLR、parent</p>
<p> ​                    parent-&gt;left : subLR、subL-&gt;right : parent</p>
<p> 更新平衡因子：parent、subL：0</p>
</li>
</ol>
</li>
<li><p>双旋：</p>
<ol>
<li><p>左右双旋：左边的右边高，<code>parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1</code></p>
<p> 修改链接：subL、subLR、parent</p>
<p> ​        左旋：以subL为轴</p>
<p> ​        右旋：以parent为轴</p>
<p> 重新更新平衡因子：</p>
<p> if(subLR-&gt;bf == -1)</p>
<p> ​    subL-&gt;bf = 0, parent-&gt;bf = 1;</p>
<p> else if(subLR-&gt;bf == 1)</p>
<p> ​    subL-&gt;bf = -1, parent-&gt;bf = 0;</p>
</li>
<li><p>右左双旋右边的左边高，<code>parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1</code></p>
<p> 修改链接：parent、subRL、subR</p>
<p> ​        右旋：以subR为轴</p>
<p> ​        左旋：以parent为轴</p>
<p> ​    重新更新平衡因子：</p>
<p> ​    if(subRL-&gt;bf == 1)</p>
<p> ​        parent-&gt;bf = -1, subR-&gt;bf = 0;</p>
<p> else if(subRL-&gt;bf == -1)</p>
<p> ​        parent-&gt;bf = 0, subR-&gt;bf = 1;</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node* cur = _root;</span><br><span class="line">		Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//插入</span></span><br><span class="line">			parent = cur;</span><br><span class="line">			<span class="keyword">if</span> (cur-&gt;_value == val) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_value &lt; val) &#123;</span><br><span class="line">				cur = cur-&gt;_right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				cur = cur-&gt;_left;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;_value &lt; val) &#123;</span><br><span class="line">			parent-&gt;_right = cur;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			parent-&gt;_left = cur;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新 + 调整</span></span><br><span class="line">		<span class="keyword">while</span> (parent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//1.更新parent平衡因子</span></span><br><span class="line">			<span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">				parent-&gt;_bf--;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				parent-&gt;_bf++;</span><br><span class="line">			<span class="comment">//2.判断是否需要继续更新</span></span><br><span class="line">			<span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>) &#123;<span class="comment">//被补齐了，parent的父节点左右子树高度未发生变化</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-1</span> || parent-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">				cur = parent;</span><br><span class="line">				parent = parent-&gt;_parent;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> || parent-&gt;_bf == <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="comment">//调整</span></span><br><span class="line">				<span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="comment">//左边的左边高，右旋</span></span><br><span class="line">					<span class="built_in">RotateR</span>(parent);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">//右边的右边高，左旋</span></span><br><span class="line">					<span class="built_in">RotateL</span>(parent);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="comment">//右边的左边高，右左双旋</span></span><br><span class="line">          Node* subR = parent-&gt;_right;</span><br><span class="line">          Node* subRl = subR-&gt;_left;</span><br><span class="line">          <span class="type">int</span> bf = subRL-&gt;_bf;</span><br><span class="line">          </span><br><span class="line">					<span class="built_in">RotateR</span>(cur);</span><br><span class="line">					<span class="built_in">RotateL</span>(parent);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//调整平衡因子</span></span><br><span class="line">          <span class="keyword">if</span>(bf == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//subRL右子树高</span></span><br><span class="line">            subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">            parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(bf == <span class="number">-1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//subRL左子树高</span></span><br><span class="line">            parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">            subR-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">//左边的右边高,左右双旋</span></span><br><span class="line">					<span class="built_in">RotateL</span>(cur);</span><br><span class="line">					<span class="built_in">RotateR</span>(parent);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* subR = parent-&gt;_right;</span><br><span class="line">		Node* subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line">		subR-&gt;_left = parent;</span><br><span class="line">		parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (subRL)</span><br><span class="line">			subRL-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (parent == _root)</span><br><span class="line">		&#123;</span><br><span class="line">			_root = subR;</span><br><span class="line">			subR-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* g = parent-&gt;_parent;</span><br><span class="line">			subR-&gt;_parent = g;</span><br><span class="line">			<span class="keyword">if</span> (g-&gt;_left == parent)</span><br><span class="line">				g-&gt;_left = subR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				g-&gt;_right = subR;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parent-&gt;_parent = subR;</span><br><span class="line">		parent-&gt;_bf = subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* subL = parent-&gt;_left;</span><br><span class="line">		Node* subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line">		subL-&gt;_right = parent;</span><br><span class="line">		parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (subLR)</span><br><span class="line">			subLR-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (parent == _root)</span><br><span class="line">		&#123;</span><br><span class="line">			_root = subL;</span><br><span class="line">			subL-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* g = parent-&gt;_parent;</span><br><span class="line">			subL-&gt;_parent = g;</span><br><span class="line">			<span class="keyword">if</span> (g-&gt;_left == parent)</span><br><span class="line">				g-&gt;_left = subL;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				g-&gt;_right = subL;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		parent-&gt;_parent = subL;</span><br><span class="line">		parent-&gt;_bf = subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ol>
<li>每个节点不是红色就是黑色</li>
<li>根结点是黑色的</li>
<li>如果一个节点是红色的，则它的两个孩子节点是黑色的</li>
<li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点</li>
<li>每个叶子节点都是黑色的（空节点也可）</li>
</ol>
<blockquote>
<p>根是黑色的</p>
<p>红色不能连续，黑色可以连续</p>
<p>每条路径上，黑色节点个数相同</p>
<p>最长路径是最短路径的两倍（最短：全黑；最长：红黑相间）</p>
</blockquote>
<p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/RBTree">一个红黑树的简单实现 - GitHub</a></p>
<h2 id="节点结构-1"><a href="#节点结构-1" class="headerlink" title="节点结构"></a>节点结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">	BLACK,</span><br><span class="line">	RED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBNode</span></span><br><span class="line">&#123;</span><br><span class="line">	pair&lt;K, V&gt; _value;</span><br><span class="line">	Color _color;</span><br><span class="line">	RBNode&lt;K, V&gt; _parent;</span><br><span class="line">	RBNode&lt;K, V&gt; _left;</span><br><span class="line">	RBNode&lt;K, V&gt; _right;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RBNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; value = <span class="built_in">pair</span>&lt;K, V&gt;())</span><br><span class="line">		: _value(value)</span><br><span class="line">		, _color(RED)</span><br><span class="line">		, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">		, _left(<span class="literal">nullptr</span>)</span><br><span class="line">		, _right(<span class="literal">nullptr</span>)</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>不能改变当前结构中的黑色节点的个数，除了祖父节点为根节点的情况</p>
<ul>
<li>g：祖父</li>
<li>p：父亲</li>
<li>u：叔叔</li>
<li>cur：插入节点</li>
</ul>
<ol>
<li>搜索树的插入</li>
<li>判断是否需要调整：红色连续 </li>
</ol>
<ul>
<li>cur在p左边，叔叔存在且为红色，将p、u置为黑色，g为红色</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggnzzrztvuj31bo0toaak.jpg" alt="IMG_7063"></p>
<ul>
<li>cur在p左边，叔叔不存在，以g为轴心进行右旋，将g变红，将p变黑</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo07rykj1j31bo0to3z1.jpg" alt="IMG_7064"></p>
<ul>
<li>cur在p左边叔叔为黑色，以g为轴心进行右旋，将g变红，将p变黑</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo0c2ek0zj31bo0to0vf.jpg" alt="IMG_7065"></p>
<ul>
<li>cur在p右边，先以p为轴心左旋，交换p与cur指针，按照情况三处理</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo0qurg82j31bo0tot9k.jpg" alt="IMG_7066"></p>
<ul>
<li><strong>p在g右边，则操作完全相反</strong></li>
</ul>
<p>代码如下，其中旋转部分代码与AVL树相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_header-&gt;_parent == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//空树</span></span><br><span class="line">   Node* root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">   root-&gt;_color = BLACK;<span class="comment">//根为黑色</span></span><br><span class="line"></span><br><span class="line">   _header-&gt;_parent = root;</span><br><span class="line">   root-&gt;_parent = _header;</span><br><span class="line"></span><br><span class="line">   _header-&gt;_left = root;</span><br><span class="line">   _header-&gt;_right = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非空树</span></span><br><span class="line">  Node* cur = _header-&gt;_parent;</span><br><span class="line">  Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur)</span><br><span class="line">  &#123;</span><br><span class="line">   parent = cur;</span><br><span class="line">   <span class="keyword">if</span> (cur-&gt;_value.first == val.first)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (cur-&gt;_value.first &lt; val.first)</span><br><span class="line">    cur = cur-&gt;_right;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    cur = cur-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">  <span class="keyword">if</span> (parent-&gt;_value.first &lt; val.first)</span><br><span class="line">   parent-&gt;_right = cur;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   parent-&gt;_left = cur;</span><br><span class="line"></span><br><span class="line">  cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调整:修改颜色，旋转</span></span><br><span class="line">  <span class="keyword">while</span> (cur != _header-&gt;_parent &amp;&amp; cur-&gt;_parent-&gt;_color == RED)</span><br><span class="line">  &#123;</span><br><span class="line">   Node* p = cur-&gt;_parent;</span><br><span class="line">   Node* g = p-&gt;_parent;</span><br><span class="line">   <span class="keyword">if</span> (g-&gt;_left == p)</span><br><span class="line">   &#123;</span><br><span class="line">    Node* u = g-&gt;_right;</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u-&gt;_color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">     u-&gt;_color = p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line"></span><br><span class="line">     cur = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//ub不存在或u存在且为黑色</span></span><br><span class="line">     <span class="keyword">if</span> (cur == p-&gt;_right)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">RotateL</span>(p);</span><br><span class="line">      <span class="built_in">swap</span>(cur, p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//cur在p左边,右旋+修改颜色</span></span><br><span class="line">     <span class="built_in">RotateR</span>(g);</span><br><span class="line">     p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span><span class="comment">//p在g右边</span></span><br><span class="line">   &#123;</span><br><span class="line">    Node* u = g-&gt;_left;</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u-&gt;_color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">     u-&gt;_color = p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line">     cur = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span> (cur == p-&gt;_left)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">RotateR</span>(p);</span><br><span class="line">      <span class="built_in">swap</span>(cur, p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">RotateL</span>(g);</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line">     p-&gt;_color = BLACK;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将根置为黑</span></span><br><span class="line">  _header-&gt;_parent-&gt;_color = BLACK;</span><br><span class="line">  <span class="comment">//更新头的左右指针</span></span><br><span class="line">  _header-&gt;_left = <span class="built_in">leftMost</span>();</span><br><span class="line">  _header-&gt;_right = <span class="built_in">rightMost</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>从无序关联容器到哈希（及无序关联容器的模拟实现）</title>
    <url>/2020/07/20200719.html</url>
    <content><![CDATA[<h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>基本使用与map相同，迭代器无反向迭代器，无序map，其体现在遍历时无序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testUMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">	um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line">	um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">	um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">15</span>, <span class="number">1</span>));</span><br><span class="line">	um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	um[<span class="number">100</span>] = <span class="number">100</span>;<span class="comment">//插入</span></span><br><span class="line">	um[<span class="number">15</span>] = <span class="number">15</span>;<span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line">	um.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">2</span>;<span class="comment">//at无法插入，key不存在直接抛异常</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历无序</span></span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator uit = um.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (uit != um.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; uit-&gt;first &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; uit-&gt;second &lt;&lt; endl;</span><br><span class="line">		uit++;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  uit = um.<span class="built_in">find</span>(<span class="number">100</span>);<span class="comment">//find找到返回指定位置迭代器，找不到则返回end迭代器</span></span><br><span class="line">	cout &lt;&lt; um.<span class="built_in">count</span>(<span class="number">100</span>) &lt;&lt; endl;<span class="comment">//count返回元素个数，1或0</span></span><br><span class="line">	cout &lt;&lt; uit-&gt;first &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; uit-&gt;second &lt;&lt; endl;</span><br><span class="line">	uit = um.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; um.<span class="built_in">count</span>(<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (uit == um.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">99</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">48</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">27</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历无序</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::iterator uit = us.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (uit != us.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *uit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	uit++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="和有序容器的区别"><a href="#和有序容器的区别" class="headerlink" title="和有序容器的区别"></a>和有序容器的区别</h2><p>map, set, multi_map, multi_set：迭代器遍历有序，中序遍历；底层实现：红黑树；操作时间复杂度O(log<sub>2</sub>n)</p>
<p>unordered_map, unordered_set, unordered_multimap, unordered_multiset：</p>
<p>迭代器遍历无序，底层实现：哈希；操作时间复杂度O(1)</p>
<p>使用场景：</p>
<ol>
<li>对遍历顺序有要求：非unordered系列容器</li>
<li>对性能要求更高：unordered系列容器</li>
</ol>
<h1 id="底层结构：哈希结构"><a href="#底层结构：哈希结构" class="headerlink" title="底层结构：哈希结构"></a>底层结构：哈希结构</h1><p>通过构造一种存储结构，通过某种函数（hashFunc）使元素的存储位置和它的关键码之间能够建立一一映射的关系，那么在查找时就可以很快的找到该元素，一种以空间换时间的结构</p>
<p>映射关系：哈希函数</p>
<p>​        哈希：把元素/键值映射到空间的某一个位置</p>
<p>​        特点：</p>
<ol>
<li>映射位置范围小于等于空间范围</li>
<li>映射位置尽量均匀</li>
<li>映射关系尽量简单</li>
</ol>
<p>常用的哈希函数：</p>
<ol>
<li>除留余数法（通用）：元素/键值 % 空间的大小</li>
<li>直接定址法（只适合范围紧凑的数据，如字符）：线性函数，A * x(元素/键值) + (B)偏置</li>
</ol>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>不同的数据映射到同一个位置即为哈希冲突</p>
<p>解决哈希冲突问题：</p>
<ol>
<li><p>闭散列（开放定址法）</p>
<p> 线性探测、二次探测</p>
</li>
<li><p>开散列（拉链法，哈希桶）</p>
</li>
</ol>
<p>负载因子：实际存放的元素个数 / 空间大小（一般70%～80%）</p>
<p><strong>线性探测：</strong></p>
<ol>
<li>插入：<ol>
<li>通过哈希函数计算哈希位置</li>
<li>如果当前位置为空，则进行插入操作</li>
<li>如果位置不为空，则从当前位置开始，找到第一个空的位置，再进行插入操作</li>
</ol>
</li>
<li>查找：<ol>
<li>通过哈希函数计算哈希位置</li>
<li>查看当前位置的数据是否和查找的数据相同，如果相同，则查找结束</li>
<li>如果不相同，则从当前位置继续向后查找，直到找到了数据或者走到了空的位置，则查找结束</li>
</ol>
</li>
<li>删除：假删除，通过设置状态数据，来标记数据是否可用<ol>
<li>进行查找操作</li>
<li>如果找到需要删除的数据，则对待删除数据所在位置进行删除状态标记</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>二次探测：每次偏移的位置的长度为上一次的平方</strong></p>
</blockquote>
<p><strong>开散列：</strong></p>
<ol>
<li>增容：<ol>
<li>遍历旧表中的每一个元素</li>
<li>计算每一个元素在新表中的位置</li>
<li>把元素重新挂载到新表中的对应位置</li>
</ol>
</li>
<li>迭代器++：<ol>
<li>_next非空：更新到_next</li>
<li>_next为空：</li>
</ol>
</li>
</ol>
<p><code>HashTable</code>: K, V, KeyOfValue, HashFun</p>
<ul>
<li>K：数据键值</li>
<li>V：键值对应的value， <code>unordered_map</code>—&gt;pair<K, v>、<code>unordered_set</code>—-&gt;K</K,></li>
<li>KeyOfValue：获取value对应的键值</li>
<li>HashFun：把键值K转换成整形数据（非整形数类型的转换，非整数—&gt;映射—&gt;整数）</li>
<li>哈希表迭代器：前置声明，友元类声明</li>
<li>成员：节点，哈希表指针</li>
<li>++操作：<ul>
<li>next是否非空，不为空：更新到next节点；为空：<ul>
<li>首先通过kov获取对应键值</li>
<li>通过hashFun计算键值对应的整数值</li>
<li>通过整数值计算当前节点在哈希表中的位置</li>
<li>从上一步计算位置的下一个位置开始，寻找第一个非空练表的头节点</li>
<li>如果没有找到，更新为空指针</li>
</ul>
</li>
</ul>
</li>
<li>begin：第一个非空链表的头节点</li>
<li>end：空节点</li>
</ul>
<p>哈希表（开散列）：可以存放任意类型的数据，如果键值类型为非数值类型，可以通过hashFun转换为整数值</p>
<p>插入、查找、删除：</p>
<ul>
<li>首先进行的操作为：通过键值计算位置</li>
<li>然后进行类似单链表的操作</li>
</ul>
<h1 id="unordered-map与unordered-set的模拟实现"><a href="#unordered-map与unordered-set的模拟实现" class="headerlink" title="unordered_map与unordered_set的模拟实现"></a>unordered_map与unordered_set的模拟实现</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>unordered_map和unordered_set的底层均由同一个哈希表实现，本次实现使用开散列哈希桶的结构，其结构大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span></span><br><span class="line">&#123;</span><br><span class="line">	V _value;</span><br><span class="line">	HashNode&lt;V&gt;* _next;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HashNode</span>(<span class="type">const</span> V&amp; val = <span class="built_in">V</span>())</span><br><span class="line">		: _value(val)</span><br><span class="line">		, _next(<span class="literal">nullptr</span>)</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//迭代器声明为友元类，原因是在迭代器类中，需要使用到哈希表来进行迭代器的自加操作</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">HashIterator</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> HashIterator&lt;K, V, KeyOfValue, HF&gt; iterator;<span class="comment">//迭代器</span></span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">	iterator <span class="title">end</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">	pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">CheckCapacity</span>();</span><br><span class="line"></span><br><span class="line">		HF hf;</span><br><span class="line">		KeyOfValue kov;</span><br><span class="line">		<span class="type">size_t</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(value)) % _table.<span class="built_in">size</span>();<span class="comment">//计算当前元素对应的位置</span></span><br><span class="line"></span><br><span class="line">		Node* cur = _table[idx];</span><br><span class="line">		<span class="keyword">while</span> (cur)<span class="comment">//寻找是否有重复元素，重复则插入失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">kov</span>(cur-&gt;_value) == <span class="built_in">kov</span>(value))</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">			cur = cur-&gt;_next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur = <span class="keyword">new</span> <span class="built_in">Node</span>(value);<span class="comment">//头插</span></span><br><span class="line">		cur-&gt;_next = _table[idx];</span><br><span class="line">		_table[idx] = cur;</span><br><span class="line">		_size++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span>；</span></span><br><span class="line"><span class="function">	<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">	size_t getNextSize(size_t n);</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CheckCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_size == _table.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">size_t</span> newSize = <span class="built_in">getNextSize</span>(_size);<span class="comment">//获取下一个表的大小值</span></span><br><span class="line">			vector&lt;Node*&gt; newTable;</span><br><span class="line">			newTable.<span class="built_in">resize</span>(newSize);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//遍历旧表中的非空单链表</span></span><br><span class="line">			KeyOfValue kov;</span><br><span class="line">			HF hf;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table.<span class="built_in">size</span>(); i++)</span><br><span class="line">			&#123;</span><br><span class="line">				Node* cur = _table[i];</span><br><span class="line">				<span class="keyword">while</span> (cur)</span><br><span class="line">				&#123;</span><br><span class="line">					Node* next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line">					<span class="type">int</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(cur-&gt;_value)) % newTable.<span class="built_in">size</span>();</span><br><span class="line">					<span class="comment">//头插</span></span><br><span class="line">					cur-&gt;_next = newTable[idx];</span><br><span class="line">					newTable[idx] = cur;</span><br><span class="line"></span><br><span class="line">					cur = next;</span><br><span class="line">				&#125;</span><br><span class="line">				_table[i] = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			_table.<span class="built_in">swap</span>(newTable);<span class="comment">//交换新旧表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;Node*&gt; _table;</span><br><span class="line">	<span class="type">size_t</span> _size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用序列容器vector来存放单链表表头，当遇到哈希冲突时，直接将插入元素头插在对应位置的单链表；其中K、V两个泛型参数在unordered_map中分别为K，<code>pair&lt;K, V&gt;</code>，在unordered_set中为K、K；泛型参数<code>KeyOfValue</code>则为不同的获取Key值的方法，通过仿函数对象来实现具体的方法</p>
<p>在unordered_map中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfValue</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value.first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>在unordered_set中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而泛型参数HF则为哈希函数，一般具有默认类型参数，也可指定，如在本次实现中为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashFunc</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashFunc</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* str = s.<span class="built_in">c_str</span>();</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> seed = <span class="number">131</span>; </span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (*str)</span><br><span class="line">		&#123;</span><br><span class="line">			hash = hash * seed + (*str++);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> hash;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>哈希表的迭代器不能通过简单的指针来完成，必须对指针进行封装，封装成一个类，并开放begin，end，++等操作的接口，大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashIterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> HashIterator&lt;K, V, KeyOfValue, HF&gt; Self;</span><br><span class="line">	<span class="keyword">typedef</span> HashTable&lt;K, V, KeyOfValue, HF&gt; HT;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HashIterator</span>(Node* node, HT* ht)</span><br><span class="line">		: _node(node)</span><br><span class="line">		, _ht(ht)</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">	V&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> _node-&gt;_value;&#125;</span><br><span class="line"></span><br><span class="line">	V* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> &amp;_node-&gt;_value;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it)&#123;<span class="keyword">return</span> _node != it._node;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; it)&#123;<span class="keyword">return</span> _node == it._node;&#125;</span><br><span class="line"></span><br><span class="line">	Self&amp; <span class="keyword">operator</span>++()&#123;<span class="built_in">add</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">	Self&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;<span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="built_in">add</span>(); <span class="keyword">return</span> *tmp;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_node-&gt;_next)</span><br><span class="line">			_node = _node-&gt;_next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			KeyOfValue kov;</span><br><span class="line">			HF hf;</span><br><span class="line"></span><br><span class="line">			<span class="type">size_t</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(_node-&gt;_value)) % _ht-&gt;_table.<span class="built_in">size</span>();<span class="comment">//计算当前传入值对应的位置</span></span><br><span class="line">			idx++;</span><br><span class="line">			<span class="keyword">if</span> (idx == _ht-&gt;_table.<span class="built_in">size</span>())<span class="comment">//走到哈希表尾</span></span><br><span class="line">			&#123;</span><br><span class="line">				_node = <span class="literal">nullptr</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Node* cur = _ht-&gt;_table[idx];</span><br><span class="line">			<span class="keyword">for</span> (; idx &lt; _ht-&gt;_table.<span class="built_in">size</span>(); idx++)<span class="comment">//找到下一个非空链表头</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (_ht-&gt;_table[idx])</span><br><span class="line">				&#123;</span><br><span class="line">					_node = _ht-&gt;_table[idx];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (idx == _ht-&gt;_table.<span class="built_in">size</span>())<span class="comment">//检查是否已经遍历完成</span></span><br><span class="line">				_node = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* _node;</span><br><span class="line">	HT* _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至此，unordered_map和unordered_set的实现已经完成了大半，接下来创建这两个类分别对哈希表类进行封装即可</p>
<h2 id="unordered-set-1"><a href="#unordered-set-1" class="headerlink" title="unordered_set"></a>unordered_set</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span> = HashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Unordered_Set</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> SetKeyOfValue</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> K&amp; value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, K, SetKeyOfValue, HF&gt;::iterator iterator;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">end</span>();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; value)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">insert</span>(value);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">erase</span>(key);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">HashNode&lt;K&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">count</span>(key);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HashTable&lt;K, K, SetKeyOfValue, HF&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，通过调用哈希表的不同接口，来实现unordered_set的各种功能</p>
<h2 id="unordered-map-1"><a href="#unordered-map-1" class="headerlink" title="unordered_map"></a>unordered_map</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">HF</span> = HashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Unordered_Map</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> MapKeyOfValue</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value.first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfValue, HF&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">end</span>();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">insert</span>(value);&#125;</span><br><span class="line"></span><br><span class="line">	V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)&#123;</span><br><span class="line">        pair&lt;iterator, <span class="type">bool</span>&gt; ret = _ht.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line">		<span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">erase</span>(key);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">HashNode&lt;V&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">count</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfValue, HF&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p><a href="[https://github.com/Latsummer/FinishedProducts/tree/master/unordered_map%E4%B8%8Eset/unordered_map%E4%B8%8Eset](https://github.com/Latsummer/FinishedProducts/tree/master/unordered_map与set/unordered_map与set">unordered_map与unordered_set的模拟实现 - GitHub</a>)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>信创系统-凝思606替换GLIBC库以运行QT的可行性调查</title>
    <url>/2024/05/20240518.html</url>
    <content><![CDATA[<h1 id="信创系统-凝思606替换GLIBC库以运行QT的可行性调查"><a href="#信创系统-凝思606替换GLIBC库以运行QT的可行性调查" class="headerlink" title="信创系统-凝思606替换GLIBC库以运行QT的可行性调查"></a>信创系统-凝思606替换GLIBC库以运行QT的可行性调查</h1><ol>
<li><p>安装CentOS7编译的带UI的QT程序，其中systemctl相关服务已被替换为service</p>
<p> 由于606系统libc.so.6版本过低，无法正常运行</p>
</li>
<li><p>尝试替换其他高版本的libc.so至本地的lib目录，同时替换其依赖</p>
<p> <img src="/2024/05/20240518/image-20240508143943090.png" alt="image-20240508143943090"></p>
<p> <img src="/2024/05/20240518/image-20240508143957295-17151504030681.png" alt="image-20240508143957295"></p>
 <span id="more"></span>
</li>
<li><p>替换完成后，碰到一些系统命令调用的问题，由于eps_service脚本会指定LD_LIBRARY_PATH，所以在该脚本中执行的系统调用命令会优先使用刚在替换的库，先在尝试将这些命令也替换为高版本gcc编译出的可执行文件，为了避免造成系统出错，这里将脚本中的系统命令换位执行本地目录的命令</p>
<ol>
<li><p>替换/增加的文件有</p>
 <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bash</span>、ln、sleep、pidof、mkdir、dirname</span><br><span class="line"><span class="attribute">ld</span>-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> -&gt; ld-<span class="number">2</span>.<span class="number">17</span>.so</span><br><span class="line"><span class="attribute">libtinfo</span>.so.<span class="number">5</span> -&gt; libtinfo.so.<span class="number">5</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">libgcc_s</span>.so.<span class="number">1</span> -&gt; libgcc_s-<span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span>-<span class="number">20150702</span>.so.<span class="number">1</span></span><br><span class="line"><span class="attribute">libm</span>.so.<span class="number">6</span> -&gt; libm-<span class="number">2</span>.<span class="number">17</span>.so</span><br><span class="line"><span class="attribute">libstdc</span>++.so.<span class="number">6</span> -&gt; libstdc++.so.<span class="number">6</span>.<span class="number">0</span>.<span class="number">19</span></span><br><span class="line"><span class="attribute">libc</span>.so.<span class="number">6</span> -&gt; libc-<span class="number">2</span>.<span class="number">17</span>.so</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>替换这些文件后， 报错信息仍然如下</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">relocation error: /opt/apps/xxx/lib/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference</span><br></pre></td></tr></table></figure>
</li>
<li><p>经查阅(<a href="https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host">https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host</a>)</p>
<p> <code>ld-linux-x86-64.so.2</code>所指向的ld-2.17.so是一个链接器，他是可执行的，并且可执行文件所需要的链接器路径是写死在文件头信息中的，可通过工具<code>patchelf</code>来修改文件头部信息，命令如下</p>
<p> <code>patchelf --set-interpreter $&#123;从别处拷贝的链接器(ld-linux-x86-64.so.2)&#125; --set-rpath $&#123;自己的lib目录&#125; $&#123;文件名&#125;</code></p>
<p> 例如<code>patchelf --set-interpreter /opt/apps/xxx/lib/ld-linux-x86-64.so.2 --set-rpath /opt/apps/xxx/lib/ /opt/apps/xxx/bin/bash</code></p>
<p> 同时，也可直接使用<code>ld-linux-x86-64.so.2</code>文件本身来单次指定链接器，<strong>仅当次生效</strong>，这在设置了<code>LD_LIBRARY_PATH</code>后想要执行系统自身命令，如想要使用gdb看看情况时==非常有用==。可以用低版本系统本身的<code>ld-linux-x86-64.so.2</code>指向系统本身的库，如下</p>
<p> <code>/lib64/ld-linux-x86-64.so.2 --library-path /lib64 /usr/bin/gdb ./edr_monitor</code></p>
</li>
<li><p>当做完这些后，发现仍然无法启动程序，启动报段错误，使用<code>/lib64/ld-linux-x86-64.so.2 --library-path /lib64 /usr/bin/gdb ./app</code>调试，未能发现其他问题，而==导入环境变量后直接执行程序会段错误==</p>
</li>
</ol>
<h2 id="改变思路"><a href="#改变思路" class="headerlink" title="改变思路"></a>改变思路</h2><ol>
<li><p>在凝思606上安装gcc4.8.5编译器</p>
 <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">./configure -<span class="keyword">enable</span>-checking=<span class="keyword">release</span> -<span class="keyword">enable</span>-languages=c,c++ -<span class="keyword">disable</span>-multilib</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>编译QT5.9.8</p>
 <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">./configure -<span class="keyword">confirm</span>-license -opensource -release -prefix <span class="string">&quot;/tmp/qt&quot;</span> -nomake tests -nomake examples -<span class="keyword">no</span>-compile-examples -qt-xcb -<span class="keyword">no</span>-openssl -skip webengine -skip tools -skip <span class="number">3</span>d -skip gamepad -skip multimedia -skip doc -skip location -skip sensors -skip androidextras -<span class="keyword">c</span>++std <span class="keyword">c</span>++<span class="number">11</span> -<span class="keyword">no</span>-static -<span class="keyword">no</span>-use-gold-linker -<span class="keyword">no</span>-glib -<span class="keyword">no</span>-<span class="built_in">iconv</span> -<span class="keyword">no</span>-icu -qt-freetype -qt-harfbuzz -<span class="keyword">no</span>-fontconfig -<span class="keyword">no</span>-xkbcommon-evdev -<span class="keyword">no</span>-gtk -qt-libjpeg -qt-libpng -<span class="keyword">no</span>-libinput -<span class="keyword">no</span>-cups -dbus-<span class="keyword">runtime</span> -<span class="keyword">no</span>-eglfs -skip wayland -optimize-size -skip serialport -skip virtualkeyboard -skip connectivity -skip activeqt -<span class="keyword">no</span>-avx2</span><br></pre></td></tr></table></figure>
<p> 其中<code>-no-avx2</code>这个参数很重要, <strong>指定编译用的CPU指令集不包含avx2</strong>, qt的configure在这个环境下无法自动检测, 会造成一些编译错误, 例如下图</p>
<p> <img src="/2024/05/20240518/image-20240508144334144.png" alt="image-20240508144334144"></p>
</li>
<li><p>编译代码(部分三方库需要重编, 因为glibc库此时还是低版本的)</p>
</li>
<li><p>此时编译出来的终端除了ui外其他都可以正常运行, 经排查, 是系统libstdc++.so版本问题, 尝试将高版本库放入终端lib目录</p>
</li>
<li><p>引入高版本libstdc++.so此时UI程序报 段错误，经排查，是由于其中一个list进行push_back操作导致</p>
<p> <img src="/2024/05/20240518/image-20240508144424382.png" alt="image-20240508144424382"></p>
<p> 虽然不能找出具体原因，但是替换为vector后即可正常使用</p>
</li>
<li><p>此时QT的画笔模块出现问题</p>
<p> <img src="/2024/05/20240518/image-20240508144450629.png" alt="image-20240508144450629"></p>
</li>
<li><p>对比了可以正常运行版本的依赖，发现依赖数量相差九个</p>
<p> <img src="/2024/05/20240518/image-20240508144503912.png" alt="image-20240508144503912"></p>
</li>
<li><p>经排查多出来的为libGL.so的依赖，属于OpenGL库，遂安装mesa-10.1.0，此时安装后，依赖数量仍差两个，此时UI仍然无法正常启动，问题同之前，通过gdb调试得到其崩溃是因为QT库的问题，程序异常退出并存在信号SIGFPE</p>
</li>
<li><p>编译debug版本的QT，重新编译UI准备调试，此时托盘图标页无法弹出，通过gdb运行发现有信号SIGABRT，经过追踪，确定问题出在加载托盘图标，实例化QIcon这一步，其中有一个函数获取系统不透明度格式时返回了非法值，触发了接下来的一个assert，从而导致出现问题，通过将QT源码改写，将原来出问题的函数中的连续三次指针调用成员函数改为分三句执行，发现最重要的第三步无法跟进去，同时gdb报<code>RTTI symobl not found for class &#39;QXcbScreen&#39;</code>，怀疑其和QXcbScreen这个类有关，同时也在该类中找到了同名函数format</p>
</li>
</ol>
<p><img src="/2024/05/20240518/image-20240508144536501.png" alt="image-20240508144536501"></p>
<p><img src="/2024/05/20240518/image-20240508144549717.png" alt="image-20240508144549717"></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>位图、布隆过滤器与大数据处理</title>
    <url>/2020/07/20200710.html</url>
    <content><![CDATA[<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>每一个比特位来表示当前比特位对应的数据是否存在，存在为1，不存在为0</p>
<p>整数数组：</p>
<ol>
<li>整数位置：n/32</li>
<li>整数位置中具体的bit位置：n%32</li>
</ol>
<ul>
<li>右移相当于除，右移n位 == 数字➗2^n^</li>
</ul>
<p>位图实现：哈希表</p>
<ol>
<li>实现：整数数组</li>
<li>数据单元是bit位</li>
<li>节省空间，一个字节可以存放8个整数的二值信息（存在与否），不存放数据本身</li>
<li>操作效率高，通过哈希映射获取位置，通过位运算执行操作， 时间效率O(1)</li>
<li>位置映射：<ol>
<li>获取整数位置，n / 32</li>
<li>获取整数的比特位：n % 32</li>
</ol>
</li>
<li>位图需要的空间大小和数据的范围有关，和数据本身大小没有关系</li>
<li>适合的场景：数据不重复，信息简单</li>
</ol>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BitMap</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BitMap</span>(<span class="type">size_t</span> range)</span><br><span class="line">	{</span><br><span class="line">		_bit.<span class="built_in">resize</span>(range / <span class="number">32</span> + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//查询: Test</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="comment">//整数位置</span></span><br><span class="line">		<span class="type">int</span> idx = n &gt;&gt; <span class="number">5</span>;<span class="comment">//等价于n/32</span></span><br><span class="line">		<span class="type">int</span> bitIdx = n % <span class="number">32</span>;</span><br><span class="line">		<span class="comment">//获取对应二进制值</span></span><br><span class="line">		<span class="keyword">if</span> ((_bit[idx] &gt;&gt; bitIdx) &amp; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//存储: Set</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="type">int</span> idx = n / <span class="number">32</span>;</span><br><span class="line">		<span class="type">int</span> bitIdx = n % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">		_bit[idx] |= (<span class="number">1</span> &lt;&lt; bitIdx);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//删除: Reset</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="type">int</span> idx = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> bitIdx = n % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">		_bit[idx] &amp;= ~(<span class="number">1</span> &lt;&lt; bitIdx);</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; _bit;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>多个位置映射来记录数据是否存在，不能直接支持删除操作，可以通过将每个比特为扩展为一个整形，作为数据的计数器，添加元素加一，删除减一，但会多占用几倍的存储空间，并且其仍不能保证某个数据一定存在，同时该方式存在计数回绕</p>
<p>m：布隆过滤器的长度，n：插入元素个数，p：误报率</p>
<script type="math/tex; mode=display">
m=-\frac {nlnp}{(ln2)^2}</script><p>k：哈希函数个数</p>
<script type="math/tex; mode=display">
k=\frac mnln 2</script><p>缺陷：</p>
<ol>
<li>有误判率，即存在假阳性，即不能准确判断元素是否在集合中(补救方法：再建立一个白</li>
</ol>
<p>名单，存储可能会误判的数据)</p>
<ol>
<li>不能获取元素本身</li>
<li>一般情况下不能从布隆过滤器中删除元素</li>
<li>如果采用计数方式删除，可能会存在计数回绕问题</li>
</ol>
<p>优点:</p>
<ol>
<li>增加和查询元素的时间复杂度为O(K)，k为哈希函数个数，一般比较小，与数据量大小无关</li>
<li>哈希函数相互之间没有关系，方便硬件并行运算</li>
<li>不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势</li>
<li>能够承受一定范围内的误判，占用空间小</li>
<li>数据量大的时候，布隆过滤器可以表示全集</li>
<li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">strToint1</span></span><br><span class="line">{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">strToint2</span></span><br><span class="line">{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">strToint3</span></span><br><span class="line">{};</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HF1</span>, <span class="keyword">class</span> <span class="title class_">HF2</span>, <span class="keyword">class</span> <span class="title class_">HF3</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//bit位数量 = hash函数个数 * 数据量 / ln2</span></span><br><span class="line">	<span class="built_in">BloomFilter</span>(<span class="type">size_t</span> num)</span><br><span class="line">		: _bit(<span class="number">5</span> * num)</span><br><span class="line">		, _bitCount(<span class="number">5</span> * num)</span><br><span class="line">	{ }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		HF1 hf1;</span><br><span class="line">		HF2 hf2;</span><br><span class="line">		HF3 hf3;</span><br><span class="line"></span><br><span class="line">		<span class="type">size_t</span> hashCode1 = <span class="built_in">hf1</span>(value);</span><br><span class="line">		<span class="type">size_t</span> hashCode2 = <span class="built_in">hf2</span>(value);</span><br><span class="line">		<span class="type">size_t</span> hashCode3 = <span class="built_in">hf3</span>(value);</span><br><span class="line"></span><br><span class="line">		_bit.<span class="built_in">Set</span>(hashCode1 % _bitCount);</span><br><span class="line">		_bit.<span class="built_in">Set</span>(hashCode2 % _bitCount);</span><br><span class="line">		_bit.<span class="built_in">Set</span>(hashCode3 % _bitCount);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		HF1 hf1;</span><br><span class="line">		<span class="type">size_t</span> hashCode1 = <span class="built_in">hf1</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (!_bit.<span class="built_in">Test</span>(hashCode1 % _bitCount))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		HF2 hf2;</span><br><span class="line">		<span class="type">size_t</span> hashCode2 = <span class="built_in">hf2</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (!_bit.<span class="built_in">Test</span>(hashCode2 % _bitCount))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		HF3 hf3;</span><br><span class="line">		<span class="type">size_t</span> hashCode3 = <span class="built_in">hf3</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (!_bit.<span class="built_in">Test</span>(hashCode3 % _bitCount))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	BitMap _bit;</span><br><span class="line">	<span class="type">size_t</span> _bitCount;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="对于大数据的处理"><a href="#对于大数据的处理" class="headerlink" title="对于大数据的处理"></a>对于大数据的处理</h1><p>常规的思路对于海量的数据来说，要么过于耗费时间，要么空间占用过高，而哈希思想可以在大数据中发挥很好的作用。</p>
<ul>
<li>比如：给定100亿个整数，想要找到其中只出现一次的整数</li>
</ul>
<p>此时即可以应用位图来操作，使用两个比特为来表示一个数据：</p>
<p>00：数据不存在；</p>
<p>01：出现过一次；</p>
<p>10：出现过多次；</p>
<p>将数据映射到位图中，如果对应位置的比特位为00，则将其改为01；如果对应位置为01，则将其改写为10，如果对应位置为10，则不做操作。</p>
<p>全部映射完成后，每两个比特位进行统计，找到对应比特位为01的那个数据即可</p>
<blockquote>
<p>假如要找到出现次数不超过两次的数据，则只需扩充10：出现过两次；11：出现过多次，映射完成之后统计10与01所对应的数据即可</p>
</blockquote>
<ul>
<li>有两个分别有100亿个整数的文件，设法找到两个文件的交集</li>
</ul>
<p>同样应用位图来处理，分别使用两个位图，将两个文件映射到其中去，然后两个位图进行按位与，统计结果中位图为1的比特位即为两个文件的交集</p>
<ul>
<li>给一个超过100G大小的log file, log中存着IP地址, 设计算法找到出现次数最多的IP地址？ 与上题条件相同，如何找到top K的IP？</li>
</ul>
<ol>
<li>哈希切割，将文件拆分成多个文件</li>
<li>将IP地址转化成整数，并模文件份数，将对应的IP放在对应的文件中</li>
<li>采用unordered_map统计每个文件中IP的出现次数，找到最多即可</li>
<li>topK问题则是在哈希切割之后，采用小堆，其节点为<ip，次数>键值对，同时需要一个仿函数类来实现大于比较，先用K个元素建堆，之后遍历所有元素，如果次数小于堆顶元素，不做任何操作，如果大于堆顶元素，删除堆顶元素并插入该元素，遍历完之后，堆内的元素即为topK</ip，次数></li>
</ol>
<p>综上所述，位图、布隆过滤器对于大数据的处理是极为合适的，只需要找到对应的处理办法，它（哈希）可以以比传统方法更高效的完成需求</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C语言中函数的一些认知</title>
    <url>/2020/02/20200202.html</url>
    <content><![CDATA[<h2 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h2><p>在C语言中，函数又可以被称为 “子程序”，它是一个大程序的某一个部分，由一个或多个语句块构成，负责完成某项特定任务，而且相较于其他代码，其具备相对独立性，可以用它来实现代码的模块化。</p>
<span id="more"></span>
<h2 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h2><h3 id="1-库函数"><a href="#1-库函数" class="headerlink" title="1.库函数"></a>1.库函数</h3><p>诸如printf（打印），strcpy（字符串拷贝）等基础功能函数，在C语言中基础库中提供了一系列的库函数，在使用是仅需使用#include来包含对应的头文件即可（可配合查询工具使用）</p>
<h3 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2.自定义函数"></a>2.自定义函数</h3><p>自定义函数的组成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span><span class="comment">/*函数返回值类型*/</span> fun<span class="comment">/*自定义函数的名称*/</span>(<span class="type">int</span><span class="comment">/*参数类型*/</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/*语句项*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，即为一个自定义函数<br>通俗易懂，基本无需解释</p>
<h2 id="3-函数的参数"><a href="#3-函数的参数" class="headerlink" title="3.函数的参数"></a>3.函数的参数</h2><h4 id="函数的参数分为形式参数和实际参数"><a href="#函数的参数分为形式参数和实际参数" class="headerlink" title="函数的参数分为形式参数和实际参数"></a>函数的参数分为形式参数和实际参数</h4><h5 id="实际参数：真实传递给函数的参数"><a href="#实际参数：真实传递给函数的参数" class="headerlink" title="实际参数：真实传递给函数的参数"></a>实际参数：真实传递给函数的参数</h5><h5 id="形式参数：指函数名括号后的变量，只有在只有在函数背后调用的时候才会被实例化"><a href="#形式参数：指函数名括号后的变量，只有在只有在函数背后调用的时候才会被实例化" class="headerlink" title="形式参数：指函数名括号后的变量，只有在只有在函数背后调用的时候才会被实例化"></a>形式参数：指函数名括号后的变量，只有在只有在函数背后调用的时候才会被实例化</h5><p>需要注意的是：_<strong>形参实例化之后相当于实参的一份临时拷贝</strong>_</p>
<h2 id="4-函数的调用"><a href="#4-函数的调用" class="headerlink" title="4.函数的调用"></a>4.函数的调用</h2><p>其分为<strong>传值调用</strong>和<strong>传址调用</strong></p>
<p><strong>传值调用</strong>：函数的形参和实参分别占用不同的内存块，对形参的修改不会影响到实参</p>
<p><strong>传址调用</strong>：将函数外部建立的变量的地址传给函数参数，将函数与外部变量建立联系，可以通过在函数内部来修改函数外部变量</p>
<h2 id="5-函数的嵌套调用和链式访问"><a href="#5-函数的嵌套调用和链式访问" class="headerlink" title="5.函数的嵌套调用和链式访问"></a>5.函数的嵌套调用和链式访问</h2><h6 id="嵌套调用"><a href="#嵌套调用" class="headerlink" title="嵌套调用"></a>嵌套调用</h6><p>指在一个函数里调用另一个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">two</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hhhh\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">one</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      two();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    one();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="链式访问"><a href="#链式访问" class="headerlink" title="链式访问"></a>链式访问</h6><p>把一个函数的返回值作为另一个函数的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">43</span>)));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-函数的声明与定义"><a href="#6-函数的声明与定义" class="headerlink" title="6.函数的声明与定义"></a>6.函数的声明与定义</h2><h5 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h5><p>告诉编译器有一个函数，它的函数名，参数类型，返回值类型分别是什么，与该函数到底存在与否无关，一般放在头文件中，需要满足先声明，后使用。</p>
<h5 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h5><p>函数的具体功能实现</p>
<h2 id="7-函数递归"><a href="#7-函数递归" class="headerlink" title="7.函数递归"></a>7.函数递归</h2><p>函数调用自身的一种程序编写技巧，会让代码看起来更简洁更美观（当然也更难）<br>需要满足两个条件<br><strong>1.存在限制条件，条件满足后不再递归<br>2.每次递归更接近限制条件</strong><br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(num&gt;<span class="number">9</span>)</span><br><span class="line">    print(nunm / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">12345</span>;</span><br><span class="line">  print(num);</span><br><span class="line">  returen <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之后，我想针对函数的递归再另写一篇文章，因为我认为函数的递归实在是简洁明了，美观大气，并且这种类似于递归的思想我也在一些古典乐中见到过，当然这不属于编程的范畴了，算是一点杂谈。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>关于原码、反码及补码的一些总结</title>
    <url>/2020/02/20200227.html</url>
    <content><![CDATA[<h4 id="大小端字节序"><a href="#大小端字节序" class="headerlink" title="大小端字节序"></a>大小端字节序</h4><p><strong>小端:数字的低位存到内存的低地址上。</strong><br><strong>大端:数字的低位存到内存的高地址上。</strong><br>_大端字节序符合平时直觉，一台机器大端还是小端，取决于CPU_  </p>
<span id="more"></span>
<p>int a = 0x11223344</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>低地址</th>
<th>0x100</th>
<th>0x101</th>
<th>0x102</th>
<th>0x103</th>
<th>高地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>低地址</td>
<td>44</td>
<td>33</td>
<td>22</td>
<td>11</td>
<td>小端</td>
</tr>
<tr>
<td>低地址</td>
<td>11</td>
<td>22</td>
<td>33</td>
<td>44</td>
<td>大端</td>
</tr>
</tbody>
</table>
</div>
<h4 id="原码反码与补码"><a href="#原码反码与补码" class="headerlink" title="原码反码与补码"></a>原码反码与补码</h4><p>例如-10：<br>1000 0000 0000 0000 0000 0000 0000 1010 原码<br>1111 1111 1111 1111 1111 1111 1111 0101反码<br>1111 1111 1111 1111 1111 1111 1111 0110补码(原码取反再加一，得到补码)</p>
<p>计算机采用补码来存储，肯定要比直接用原码麻烦，付出这样的代价是为了让计算机的硬件 设备实现起来更简单，通过补码的方式，能够把二进制的加减法统一成加法运算<br>例如：<br>计算 0 - 1 =&gt; 0 + (-1)<br>1000 0000 0000 0000 0000 0000 0000 0001 -1的原码<br>1111 1111 1111 1111 1111 1111 1111 1110 ,-1的反码<br>1111 1111 1111 1111 1111 1111 1111 1111 , -1的补码<br>计算 2-1 2+（-1）<br>1111 1111 1111 1111 1111 1111 1111 1111 ,-1的补码<br>1000 0000 0000 0000 0000 0000 0000 0010 ,2的补码（正数的原码反码补码都一样）<br><strong>「对于负数来说，需要把原码转成补码在储存，也需要用到补码转原码」<br>「原码转补码是 取反+1」<br>「补码转原码还是 取反+1」</strong></p>
<h4 id="关于char类型的一些问题"><a href="#关于char类型的一些问题" class="headerlink" title="关于char类型的一些问题"></a>关于char类型的一些问题</h4><p>char 一个字节的变量，当按照\%d打印的时候，就会把char隐式转换成int类型的变量,再打印</p>
<p>1000 0001 -1的原码<br>1111 1110 -1的反码<br>1111 1111 -1的补码<br>\%d打印的时候就先将a先隐式转换成int<br>这个转换过程中，高位的三个字节也要填充，按照符号为来填充（如果a的符号位是0，高位就补0；反之补1）<br>此时<br>char =&gt; int<br>1111 1111 =&gt; 1111 1111 1111 1111 1111 1111 1111 1111 =&gt; -1的补码<br>高位补1也就是为了防止出现这样转换过程中出现数据错误的情况</p>
<p>1111 1111 -1在内存中的存储 unsigned char 存的还是八个1，此时最高位的1 不再是符号位了，八个1理解成正数（不考虑符号位）的结果就是255，\%d打印时，1111 1111 =&gt; 高位补0（unsigned char没有符号位）<br>0000 0000 0000 0000 0000 0000 1111 1111</p>
<p>char的范围：-128 =&gt; +127<br>128 转化成二进制</p>
<p>1000 0000 0000 0000 0000 0000 1000 0000 -128原码<br>1111 1111 1111 1111 1111 1111 0111 1111 -128反码<br>1111 1111 1111 1111 1111 1111 1000 0000 -128补码</p>
<p>Char a = -128<br>1000 0000<br>👇<br>1111 1111 1111 1111 1111 1111 1000 0000（int）<br>👇<br>1111 1111 1111 1111 1111 1111 1000 0000（unsigned int）<br>此时最高位不再是符号位，不再表示负数，被理解成了一个很大的数字</p>
<p>128 内存中的二进制表示方式<br>0000 0000 0000 0000 0000 0000 1000 0000 （int）<br>Char a =128；<br>1000 0000<br>发生了截断<br>导致唯一的一个1阴差阳错的成了符号位，此时a的本质上是-128</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>图</title>
    <url>/2021/03/20210312.html</url>
    <content><![CDATA[<h1 id="图的构成"><a href="#图的构成" class="headerlink" title="图的构成"></a>图的构成</h1><p><strong>顶点集合</strong>+<strong>边的集合</strong>：<code>G = (V, E)</code>，顶点集合<code>V = {x | x属于某个数据对象及}</code>是有穷非空集合</p>
<ul>
<li><p><code>E = {(x, y) | x, y属于V}</code>或者<code>E = {&lt;x, y&gt; | x, y属于V &amp;&amp; Path(x, y)}</code>是顶点间关系的有穷集合，也叫边集合</p>
</li>
<li><p><code>(x, y)</code>表示x到y的一条双向通道，即<code>(x, y)</code>是无方向的，<code>Path(x, y)</code>表示从x到y的一条单向通路，即<code>Path(x, y)是有方向的</code></p>
</li>
</ul>
<p>顶点和边：图中节点成为顶点，第i个顶点记作vi， 两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中第k条边记作ek，<code>ek = (vi, vj)</code>或<code>ek = &lt;vi, vj&gt;</code></p>
<ul>
<li>在有向图中，顶点对<code>&lt;x, y&gt;</code>是有序的，顶点对<code>&lt;x, y&gt;</code>称为顶点x到顶点y的一条边(弧)，<code>&lt;x, y&gt;</code>和<code>&lt;y ,x&gt;</code>是两条不同的边，如G3、G4</li>
<li>在无向图中，顶点对(x, y)是无序的，顶点对(x,y) 称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，如G1、G2</li>
<li>注意：<strong>无向边<code>(x, y)</code>等于有向边<code>&lt;x, y&gt;</code>和<code>&lt;y, x&gt;</code></strong></li>
</ul>
<span id="more"></span>
<p><em>可以表示</em>：社交关系</p>
<ul>
<li>社交关系中，每个人就是一个顶点，两个人是好友，他们之间就有了边，那么边的权值可以是他们的亲密度</li>
<li>无向图：QQ、微信类似的社交关系可以被看作是无向图（强社交关系，熟人社交）</li>
<li>有向图：微博（关注的关系）、抖音 （弱社交关系，陌生人社交、粉丝社交）</li>
<li>也可以用来表示地图（导航路线选择），网络连接（路由器选择）</li>
<li>vertex 顶点、edge 边、weight 权值</li>
</ul>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ol>
<li>完全图（即所有顶点相连接）：在有n个顶点的无向图中，若有<code>n * (n-1)/2</code>条边，即<em>任意两个顶点之间有且仅有一条边</em>，则称此图为<strong>无向完全图</strong>，如G1；在n个顶点的有向图中，若有<code>n * (n-1)</code>条边，即<em>任意两个顶点之间有且仅有方向</em> 相反的边，则称此图为<strong>有向完全图</strong>，如G4。</li>
<li>邻接顶点：在无向图中G中，若(u, v)是E(G)中的一条边，则称u和v互为邻接顶点，并称边(u,v)依附于顶点u 和v；在有向图G中，若是E(G)中的一条边，则称顶点u邻接到v，顶点v邻接自顶点u，并称边与 顶点u和顶点v相关联。</li>
<li>顶点的度：<u>顶点v的度是指与它相关联的边的条数</u>，记作<code>deg(v)</code>。在有向图中，顶点的度等于该顶点的入度与 出度之和，其中顶点v的入度是以v为终点的有向边的条数，记作<code>indev(v)</code>;顶点v的出度是以v为起始点的有向 边的条数，记作<code>outdev(v)</code>。因此：<code>dev(v) = indev(v) + outdev(v)</code>。注意：对于无向图，顶点的度等于该顶 点的入度和出度，即<code>dev(v) = indev(v) = outdev(v)</code>。</li>
<li>路径：在图<code>G = (V， E)</code>中，若从顶点vi出发有一组边使其可到达顶点vj，则称顶点vi到顶点vj的顶点序列为从 顶点vi到顶点vj的路径。</li>
<li>路径长度：对于不带权的图，一条路径的路径长度是指该路径上的边的条数；对于带权的图，一条路 径的路 径长度是指该路径上各个边权值的总和。</li>
</ol>
<p><img src="/2021/03/20210312/008eGmZEly1gpljuxnpgij30k00i1aby.jpg" alt="截屏2021-04-16 14.04.25"></p>
<ol>
<li>简单路径与回路：若路径上各顶点v1，v2，v3，…，vm均不重复，则称这样的路径为简单路径。若路 径上 第一个顶点v1和最后一个顶点vm重合，则称这样的路径为回路或环。即路径不重复为简单路径，重复则为回路</li>
<li>子图：某个图的一个部分（一部分边、一部分顶点等）称为其的子图</li>
<li>连通图：在<strong>无向图</strong>中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。如果图中任意一 对顶点 都是连通的，则称此图为连通图。（连通图不一定是完全图，但完全图一定是连通图，对连通图来说，仅需有路径即可，而完全图则要求两顶点邻接）</li>
<li>强连通图：在<strong>有向图</strong>中，若在每一对顶点vi和vj之间都存在一条从vi到vj的路径，也存在一条从vj到 vi的路 径，则称此图是强连通图</li>
<li>生成树（用最少的边把图连通）：一个连通图的最小连通子图称作该图的生成树。有n个顶点的连通图的生成树有n个顶点和n - 1条边。</li>
</ol>
<ul>
<li>图和树的区别：<ul>
<li>树可以认为是特殊的图，图不一定是树</li>
<li>联通图，且不带环（没有回路），就可以认为是树</li>
</ul>
</li>
</ul>
<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>保存节点以及边的关系</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>因为节点与节点之间的关系就是连通与否，即为0或者1，因此邻接矩阵(二维数组)即是：先用一个数组将顶点保存，然后采用矩阵来表示节点与节点之间的关系。</p>
<p><img src="/2021/03/20210312/008eGmZEly1gplp3axgjsj306n06wjrm.jpg" alt="截屏2021-04-16 17.05.50"></p>
<p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下</p>
<script type="math/tex; mode=display">
edge = \left[ \begin{matrix}  & A & B & C & D \\ A & 0 & 1 & 0 & 1 \\ B & 1 & 0 & 1 & 0 \\ C & 0 & 1 & 0 & 1 \\ D & 1 & 0 & 1 & 0 \end{matrix} \right]</script><p><img src="/2021/03/20210312/008eGmZEly1gpltlbqflfj305i098jrl.jpg" alt="截屏2021-04-16 19.41.36"></p>
<p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下</p>
<script type="math/tex; mode=display">
edge = \left[ \begin{matrix}  & A & B & C  \\ A & 0 & 1 & 0 \\ B & 1 & 0 & 1 \\ C & 0 & 0 & 0\end{matrix} \right]</script><ul>
<li>无向图的邻接矩阵是对称的，第i行(列)元素之和，就是顶点i的度。有向图的邻接矩阵则不一定是对称 的，第i行(列)元素之后就是顶点i 的出(入)度</li>
<li>如果边带有权值，并且两个节点之间是连通的，上图中的边的关系就用权值代替，如果两个顶点不通， 则使用无穷大代替</li>
<li>用邻接矩阵存储图的有点是能够快速知道两个顶点是否连通，缺陷是如果顶点比较多，边比较少时，矩 阵中存储了大量的0成为系数矩阵，比较浪费空间，并且要求两个节点之间的路径不是很好求。</li>
</ul>
<p><img src="/2021/03/20210312/008eGmZEly1gpluoyfacuj30m409f406.jpg" alt="截屏2021-04-16 20.18.53"></p>
<h3 id="邻接矩阵代码实现"><a href="#邻接矩阵代码实现" class="headerlink" title="邻接矩阵代码实现"></a>邻接矩阵代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vertex 顶点</span></span><br><span class="line"><span class="comment">//edge 边</span></span><br><span class="line"><span class="comment">//weight 权值</span></span><br><span class="line"><span class="comment">//matrix矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> matrix</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        {</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            _matrex.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                _matrex[i].<span class="built_in">resize</span>(n, <span class="built_in">W</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">"非法顶点"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            _matrex[srcIndex][dstIndex] = w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">                _matrex[dstIndex][srcIndex] = w;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;vector&lt;W&gt; &gt; _matrex;     <span class="comment">//表示邻接矩阵的边</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>使用数组表示顶点的集合，使用链表表示边的关系。</p>
<ul>
<li>图为无向图的邻接表存储</li>
</ul>
<p><img src="/2021/03/20210312/008eGmZEly1gpn1zc5fnyj30ir08adgk.jpg" alt="截屏2021-04-17 21.17.19"></p>
<ul>
<li>注意：无向图中同一条边在邻接表中出现了两次。如果想知道顶点vi的度，只需要知道顶点vi边链表集合中结点的数目即可</li>
<li>有向图则添加一个边的集合或者反向添加一次</li>
</ul>
<h2 id="邻接表的代码实现"><a href="#邻接表的代码实现" class="headerlink" title="邻接表的代码实现"></a>邻接表的代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> table</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> _srcIndex;</span><br><span class="line">        <span class="type">int</span> _dstIndex;</span><br><span class="line">        <span class="type">const</span> W&amp; _w;</span><br><span class="line"></span><br><span class="line">        EdgeNode&lt;W&gt;* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        {</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            _linkTable.<span class="built_in">resize</span>(n, <span class="literal">nullptr</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">"非法顶点"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">            node-&gt;_srcIndex = srcIndex;</span><br><span class="line">            node-&gt;_dstIndex = dstIndex;</span><br><span class="line">            node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//挂起头</span></span><br><span class="line">            node-&gt;_next = _linkTable[srcIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">            _linkTable[srcIndex] = node;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">            {</span><br><span class="line">                EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">                node-&gt;_srcIndex = dstIndex;</span><br><span class="line">                node-&gt;_dstIndex = srcIndex;</span><br><span class="line">                node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//挂起头</span></span><br><span class="line">                node-&gt;_next = _linkTable[dstIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">                _linkTable[dstIndex] = node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;EdgeNode&lt;W&gt;*&gt; _linkTable;<span class="comment">//邻接表</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历 一次。”遍历”即对结点进行某种操作的意思</p>
<h2 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h2><p>对邻接矩阵，深度优先可是使用递归的方式实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _DFS(<span class="type">int</span> srcIndex, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span><br><span class="line">{</span><br><span class="line">  cout &lt;&lt; _vertexs[srcIndex] &lt;&lt; <span class="string">":"</span> &lt;&lt; srcIndex &lt;&lt; <span class="string">"-&gt;"</span>;<span class="comment">//输出当前节点</span></span><br><span class="line">  visited[srcIndex] = <span class="literal">true</span>;<span class="comment">//标记当前节点已访问</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">  {<span class="comment">//访问当前节点的相邻顶点</span></span><br><span class="line">    <span class="keyword">if</span>(_matrex[srcIndex][i] != <span class="built_in">W</span>() &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">      _DFS(i, visited);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">  _DFS(srcIndex, visited);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h2><p>对邻接矩阵，广度优先可以使用队列实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line"></span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(srcIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; _vertexs[front] &lt;&lt; <span class="string">":"</span> &lt;&lt; front &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    <span class="comment">//好友入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(visited[i] == <span class="literal">false</span> &amp;&amp; _matrex[front][i] != <span class="built_in">W</span>())</span><br><span class="line">      {</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>连通图中的每一棵生成树，都是原图的一个极大无环子图，即：从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成一条回路。 </p>
<p>若连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边。因此构造最小生成树的准则有三条：</p>
<ol>
<li>只能使用图中的边来构造最小生成树 </li>
<li>只能使用恰好n-1条边来连接图中的n个顶点</li>
<li>选用的n-1条边不能构成回路</li>
</ol>
<p>构造最小生成树的方法：<strong>Kruskal算法</strong>和<strong>Prim算法</strong>。</p>
<ul>
<li>这两个算法都采用了<strong>逐步求解的贪心策略</strong>。 贪心算法：是指在问题求解时，总是做出当前看起来最好的选择。也就是说贪心算法做出的不是整体最优的选择，而是某种意义上的局部最优解。贪心算法不是对所有的问题都能得到整体最优解。</li>
</ul>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><ol>
<li><p>任给一个有n个顶点的连通网络<code>N={V,E}</code></p>
</li>
<li><p>首先构造一个由这n个顶点组成、不含任何边的图<code>G={V,NULL}</code>，其中每个顶点自成一个连通分量</p>
</li>
<li>接着不断从E中取出权值最小的一条边(若有多条任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。</li>
<li>如此重复，直到所有顶点在同一个连通分量上为止。 </li>
</ol>
<ul>
<li>核心：每次迭代时，选出一条具有最小权值，且两端点不在同一连通分量上的边，加入生成树。</li>
</ul>
<blockquote>
<p>如何判断选出一条边以后跟已有的边是否构成回路：并查集</p>
<p>如果选的边在一个集合中，就不能再使用，不在一个集合才能添加</p>
</blockquote>
<h2 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a>Prime算法</h2><p>仍是贪心算法，但它先选出最小的一条边，接着并非从全局中找到最小的边，而是以最小的边为基础，选已有的边的邻接顶点链接出的边中最小的，避开了选出环路的情况</p>
<h1 id="单元最短路径"><a href="#单元最短路径" class="headerlink" title="单元最短路径"></a>单元最短路径</h1><p>从在带权图的某一顶点出发，找出一条通往另一顶点的最短路径，最短也就是沿路径各边的权值总和达到最小。</p>
<blockquote>
<p>Dijkstra算法和Floyd算法</p>
</blockquote>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>求一个点和图中的其他所有点之间的最路径</p>
<p><img src="/2021/03/20210312/008i3skNly1gptzx4hmntj30au0a0mxt.jpg" alt="截屏2021-04-23 21.25.02"></p>
<p><img src="/2021/03/20210312/008i3skNly1gpu0bcc8v9j30kv089wgk.jpg" alt="截屏2021-04-23 21.38.39"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径</th>
<th>路径长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>0，1</td>
<td>无穷大</td>
</tr>
<tr>
<td>0，2</td>
<td>50</td>
</tr>
<tr>
<td>0，3</td>
<td>10</td>
</tr>
<tr>
<td>0，4</td>
<td>50</td>
</tr>
</tbody>
</table>
</div>
<p>依次遍历所有的边，找出更短路径，找到则更新</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>在线的面试预约系统</title>
    <url>/2020/08/20200827.html</url>
    <content><![CDATA[<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>通过httplib库函数中的Post和Get方法来处理以下四种请求</p>
<ul>
<li><code>注册</code> ：处理浏览器传来的数据，并调用数据库函数增加列</li>
<li><code>登录</code> ：处理浏览器传来的数据，在数据库中进行查询，登陆成功则生成sessionID用以后续使用</li>
<li><code>数据页面</code>：处理浏览器传来的数据，使用sessionID查询当前登录的用户，在数据库中查询该用户信息并返回</li>
<li><code>数据提交</code>：处理浏览器传来的数据，根据头部的sessionID查询登陆用户，切割正文提交的信息，插入数据库</li>
</ul>
<span id="more"></span>
<p><img src="/2020/08/20200827/007S8ZIlly1gi4nyalqwpj31f40nijuu.jpg" alt="IMG_7559"></p>
<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><h3 id="http服务"><a href="#http服务" class="headerlink" title="http服务"></a>http服务</h3><p>创建了一个类来完成整个项目的运行，这个类用于保存登录数据库的参数、所有登录用户的sessionid、启动http服务，其结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AisSvr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AisSvr</span>()</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">OnInit</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span><span class="comment">//启动http服务</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">GetSessionId</span><span class="params">(httplib::Request res, string* session_id)</span></span>;<span class="comment">//获取当前用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span></span>;<span class="comment">//打开配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string _svr_ip;<span class="comment">//服务端监听的IP地址</span></span><br><span class="line">  <span class="type">uint16_t</span> _svr_port;<span class="comment">//服务端监听的端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据库类成员</span></span><br><span class="line">  DataBaseSvr* _db;</span><br><span class="line">  string _db_ip;</span><br><span class="line">  string _db_user;</span><br><span class="line">  string _db_passwd;</span><br><span class="line">  string _db_name;</span><br><span class="line">  <span class="type">uint16_t</span> _db_port;</span><br><span class="line"></span><br><span class="line">  AllSessionInfo* _all_session;<span class="comment">//所有登录用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  httplib::Server _http_svr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>对于数据库的操作，同样创建了一个类来完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataBaseSvr</span><span class="comment">//数据库类</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DataBaseSvr</span>(string&amp; host, string&amp; user, string&amp; passwd, string&amp; db, <span class="type">uint16_t</span> port)</span><br><span class="line">    &#123;</span><br><span class="line">      _host = host;</span><br><span class="line">      _user = user;</span><br><span class="line">      _passwd = passwd;</span><br><span class="line">      _db = db;</span><br><span class="line">      _port = port;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">mysql_init</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DataBaseSvr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">mysql_close</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QuerySql</span><span class="params">(<span class="type">const</span> string&amp; sql)</span></span>;<span class="comment">//操作数据库接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Connect2MySQL</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  	<span class="type">bool</span> <span class="title">QueryUserExist</span><span class="params">(Json::Value&amp; request_json, Json::Value* result)</span></span>;<span class="comment">//数据库查询</span></span><br><span class="line">  	<span class="function"><span class="type">bool</span> <span class="title">QueryOneStuInfo</span><span class="params">(string user_id, Json::Value* result)</span></span>;<span class="comment">//查询用户信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//MySQL就是客户端的操作句柄</span></span><br><span class="line">    MYSQL _mysql;</span><br><span class="line">    string _host;</span><br><span class="line">    string _user;</span><br><span class="line">    string _passwd;</span><br><span class="line">    string _db;</span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="sessionid管理"><a href="#sessionid管理" class="headerlink" title="sessionid管理"></a>sessionid管理</h3><p>创建了一个类专门计算MD5值，用另一个类进行封装，同时管理一批sessionid</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Session</span>(Json::Value&amp; user_info)</span><br><span class="line">    &#123;</span><br><span class="line">      _origin_str.<span class="built_in">clear</span>();</span><br><span class="line">      _user_info = user_info;</span><br><span class="line"></span><br><span class="line">      _origin_str += <span class="built_in">to_string</span>(_user_info[<span class="string">&quot;stu_id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_interview_time&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SumMd5</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">string&amp; <span class="title">GetSessionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">SumMd5</span>();</span><br><span class="line">      <span class="keyword">return</span> _session_id;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//private:因为不想再写个接口获取sessionid所以直接将成员变量设为public（懒惰！）</span></span><br><span class="line">    string _session_id;<span class="comment">//保存session_id</span></span><br><span class="line">    string _origin_str;<span class="comment">//原始的串，用来生成session_id</span></span><br><span class="line">    Json::Value _user_info;<span class="comment">//原始串内容：stu_id, stu_name, stu_interview_time</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllSessionInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  ~<span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  <span class="comment">//Set Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">SetSessionValue</span><span class="params">(string&amp; session_id, Session&amp; session_info)</span></span>;</span><br><span class="line">  <span class="comment">//Get Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetSessionValue</span><span class="params">(string&amp; session_id, Session* session_info)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//key：sessionid，value：session</span></span><br><span class="line">  unordered_map&lt;string, Session&gt; _session_map;</span><br><span class="line">  <span class="type">pthread_mutex_t</span> _map_lock;<span class="comment">//所有操作均需要互斥完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>该模块主要完成对浏览器响应正文的数据进行分割和解析，输出日志信息，较为简单</p>
<h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><h3 id="响应登录请求-Post方法"><a href="#响应登录请求-Post方法" class="headerlink" title="响应登录请求(Post方法)"></a>响应登录请求(Post方法)</h3><ol>
<li>解析提交的内容</li>
<li>先根据邮箱作为查询条件，如果邮箱不存在，则登陆失败，如果邮箱存在，则校验密码</li>
<li>上一步校验失败，向浏览器返回false，校验成功则进行下一步</li>
<li>根据登录用户信息，生成sessionid，用以表示当前用户</li>
<li>跳转到个人信息页面</li>
</ol>
<h3 id="个人信息也页面-Get方法"><a href="#个人信息也页面-Get方法" class="headerlink" title="个人信息也页面(Get方法)"></a>个人信息也页面(Get方法)</h3><ol>
<li>根据请求头部的sessionid信息，从管理sessionid的类中获取当前登录用户信息</li>
<li>查询数据库，获取用户信息</li>
<li>组织应答</li>
</ol>
<h3 id="注册请求-Post方法"><a href="#注册请求-Post方法" class="headerlink" title="注册请求(Post方法)"></a>注册请求(Post方法)</h3><ol>
<li>解析请求正文</li>
<li>将解析出的用户信息插入注册信息表(此处需要开启数据库事务，加入注册信息插入失败，则回滚)</li>
<li>组织应答</li>
</ol>
<h3 id="预约请求-Post方法"><a href="#预约请求-Post方法" class="headerlink" title="预约请求(Post方法)"></a>预约请求(Post方法)</h3><p>基本思路同注册请求</p>
<h1 id="效果预览图与项目代码"><a href="#效果预览图与项目代码" class="headerlink" title="效果预览图与项目代码"></a>效果预览图与项目代码</h1><p>注册页面</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nypyjs4j310k0qiwgl.jpg" alt="IMG_7555"></p>
<p>登录页面</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nzbxgiwj310k0qiwgh.jpg" alt="IMG_7556"></p>
<p>数据提交页面</p>
<p><img src="/2020/08/20200827/007S8ZIlly1gi4o34di6rj30xn06574p.jpg" alt="IMG_7554"></p>
<p>个人信息页面</p>
<p><img src="/2020/08/20200827/007S8ZIlly1gi4o35739vj30xn06574p.jpg" alt="IMG_7558"></p>
<p>GitHub地址：<a href="https://github.com/Latsummer/interview-system">https://github.com/Latsummer/interview-system</a></p>
]]></content>
      <categories>
        <category>小作品</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>在MIPS及LoongArch的架构下编译go语言二进制</title>
    <url>/2024/05/20240520.html</url>
    <content><![CDATA[<h1 id="在MIPS及LoongArch的架构下编译go语言二进制"><a href="#在MIPS及LoongArch的架构下编译go语言二进制" class="headerlink" title="在MIPS及LoongArch的架构下编译go语言二进制"></a>在<code>MIPS</code>及<code>LoongArch</code>的架构下编译go语言二进制</h1><h3 id="首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境"><a href="#首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境" class="headerlink" title="首先需要找到一个已经安装go的机器, 可以是X86或ARM等任何可以执行go的环境"></a>首先需要找到一个已经安装go的机器, 可以是<code>X86</code>或<code>ARM</code>等任何可以执行go的环境</h3><p>其次准备好go源码</p>
<p>接着进行如下操作</p>
<ol>
<li><p>解压go源码</p>
</li>
<li><p>设定环境变量 <code>GOROOT_BOOTSTRAP</code>/<code>GOOS</code>/<code>GOARCH</code><br> 其中 <code>GOROOT_BOOTSTRAP</code> 为当前可以执行 go 文件的安装目录, 例如当前环境的 go 可执行文件为<code>/usr/local/go/bin/go</code>, 则 <code>GOROOT_BOOTSTRAP</code> 应设置为 <code>/usr/local/go</code><br> <code>GOOS</code> 为目标环境系统<br> <code>GOARCH</code> 为目标架构<br> 关于 <code>GOOS</code> 以及 <code>GOARCH</code>, 可以使用命令, go tool dist list 查看, 版本越高的go支持的越多</p>
 <span id="more"></span>
</li>
<li><p><img src="/2024/05/20240520/image-20240416195706201.png" alt="image-20240416195706201"></p>
</li>
<li><p>设定好环境变量后, 进入源码目录下的<code>src</code>目录, 执行脚本 <code>bootstrap.bash</code></p>
</li>
</ol>
<p>​    <img src="/2024/05/20240520/image-20240416195943599.png" alt="image-20240416195943599">    </p>
<ol>
<li><p>等待脚本执行完毕, 会在<code>src</code>目录的上层的上层目录 即 <code>../../</code> 目录 (脚本最后一般会输出文件路径)下生成 一个<code>tbz</code>文件, 将此文件拷贝至目标机器, 并解压</p>
</li>
<li><p>解压后, 进入 <code>$&#123;解压后的目录&#125;/bin</code> , 此时应该存在 <code>go</code>,  <code>gofmt</code> 两个二进制文件, 执行以下 <code>./go version</code> , 看看能否正常运行</p>
<ol>
<li><p>这里在<code>loongarrch</code>架构碰到一个问题, 执行后出现 段错误</p>
<p> <img src="/2024/05/20240520/image-20240416200939524.png" alt="image-20240416200939524"></p>
</li>
<li><p><code>gdb</code>了一下发现是在编译的时候似乎把依赖路径硬编码进去了(也可能是没有设置好环境变量)</p>
</li>
<li><p>将解压后的文件放到与编译时的文件同一个路径即可</p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>在目标机器设定环境变量, <code>GOROOT_BOOTSTRAP</code> , <code>GOROOT</code>, 将源码文件解压到任何你想解压到的地方, 其中</p>
<ol>
<li><p><code>GOROOT_BOOTSTRAP</code> 为之前编译出来的<code>tbz</code>文件的解压路径</p>
</li>
<li><p><code>GOROOT</code> 为解压后的go源码文件路径</p>
</li>
</ol>
</li>
<li><p>进入 <code>$GOROOT/scr</code>, 执行 <code>./all.bash</code>, 此步骤耗时较久, 会测试一些东西</p>
</li>
<li><p>执行完毕后, <code>$GOROOT</code>目录即会多出一个bin目录, 此时将整个<code>$GOROOT</code>目录挪到任何你想挪到的地方, 并将 <code>$GOROOT/bin</code> 添加到环境变量即可</p>
</li>
</ol>
<h3 id="如果在进行测试时失败-可以看一下有没有超时-测试项完成后会显示使用时间-默认为3分钟-类似下图"><a href="#如果在进行测试时失败-可以看一下有没有超时-测试项完成后会显示使用时间-默认为3分钟-类似下图" class="headerlink" title="如果在进行测试时失败, 可以看一下有没有超时, 测试项完成后会显示使用时间, 默认为3分钟, 类似下图"></a>如果在进行测试时失败, 可以看一下有没有超时, 测试项完成后会显示使用时间, 默认为3分钟, 类似下图</h3><p><img src="/2024/05/20240520/image2023-2-17_11-24-37.png" alt="image2023-2-17_11-24-37"></p>
<p>解决方式是设定环境变量 <code>GO_TEST_TIMEOUT_SCALE</code> = 2, 这会将超时时间倍乘二, 变为 6 分钟</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-顺序表和链表</title>
    <url>/2020/04/20200407.html</url>
    <content><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表n个具有相同特性的数据元素的<strong>有限</strong>序列，它是一种在实际使用中广泛使用的数据结构，常见的线性表有顺序表、链表、栈、队列等。线性表在逻辑上是线性结构，但是在物理上不一定连续（比如链表）。</p>
<span id="more"></span>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表是一段<strong>物理地址连续</strong>的存储单元依次存储数据元素的线性结构，一般用数组存储，在数组上完成数据的增删查改。<br>顺序表一般分为：</p>
<ol>
<li>静态顺序表（不常用）：使用定长数组存储。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Type <span class="built_in">array</span>[N];<span class="comment">//定长数组</span></span><br><span class="line">	<span class="type">size_t</span> size;<span class="comment">//有效数据个数</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>
<ol>
<li>动态顺序表：使用动态开辟的数组存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Type* <span class="built_in">array</span>;<span class="comment">//指向动态开辟的数组</span></span><br><span class="line">	<span class="type">size_t</span> size;<span class="comment">//有效数据个数</span></span><br><span class="line">	<span class="type">size_t</span> capicity;<span class="comment">//容量</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>
<p>一般来说，更常使用的是动态顺序表，因为它更灵活一些。</p>
<h3 id="顺序表的接口实现"><a href="#顺序表的接口实现" class="headerlink" title="顺序表的接口实现"></a>顺序表的接口实现</h3><ol>
<li>顺序表的增，可分为头插，尾插，任意位置插入。它们的时间复杂度分别为头插：O(n)、尾插：O(1)、任意位置插入：O(n)。代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushFront</span><span class="params">(SeqList* ps, SLDateType x)</span><span class="comment">//头插</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ps-&gt;size &gt;= ps-&gt;capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		Realoc(ps);<span class="comment">//扩容</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> end = ps-&gt;size;</span><br><span class="line">	<span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ps-&gt;a[end] = ps-&gt;a[end - <span class="number">1</span>];</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">	ps-&gt;a[<span class="number">0</span>] = x;</span><br><span class="line">	ps-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushBack</span><span class="params">(SeqList* ps, SLDateType x)</span><span class="comment">//尾插</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ps-&gt;size &gt;= ps-&gt;capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		Realoc(ps);<span class="comment">//扩容</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps-&gt;a[ps-&gt;size] = x;</span><br><span class="line">	ps-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* ps, <span class="type">size_t</span> pos, SLDateType x)</span><span class="comment">//pos位置插入</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ps-&gt;size &gt;= ps-&gt;capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		Realoc(ps);<span class="comment">//扩容</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> end = ps-&gt;size;</span><br><span class="line">	<span class="keyword">while</span> (end &gt; (pos - <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		ps-&gt;a[end] = ps-&gt;a[end - <span class="number">1</span>];</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">	ps-&gt;a[pos - <span class="number">1</span>] = x;</span><br><span class="line">	ps-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>顺序表的删也可以分为头删、尾删以及任意位置删除，它们的时间复杂度分别为，头删：O(n)、尾删：O(1)、任意位置删除：O(n)。代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListPopFront</span><span class="params">(SeqList* ps)</span><span class="comment">//头删</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ps-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ps-&gt;a[i] = ps-&gt;a[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	ps-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPopBack</span><span class="params">(SeqList* ps)</span><span class="comment">//尾删</span></span><br><span class="line">&#123;</span><br><span class="line">	ps-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListErase</span><span class="params">(SeqList* ps, <span class="type">size_t</span> pos)</span><span class="comment">//pos位置删除</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> erase = pos - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (erase &lt; ps-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		ps-&gt;a[erase] = ps-&gt;a[erase + <span class="number">1</span>];</span><br><span class="line">		erase++;</span><br><span class="line">	&#125;</span><br><span class="line">	ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>顺序表的查找需要遍历整个表，故时间复杂度为O(n)，代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* ps, SLDateType x)</span><span class="comment">//查找</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> find = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (find &lt; ps-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ps-&gt;a[find] == x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> find + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		find++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果没找到，返回一个不可能是数组下标的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>由于顺序表可以支持随机访问的特点，所以他的数据的修改比较简单，在这里不多赘述。</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种<strong>物理存储结构上非连续</strong>、非顺序的存储结构，数据元素的<strong>逻辑顺序</strong>是通过链表中的<strong>指针链接</strong>次序实现的。链表的结构非常多样，具有的特征有：</p>
<ol>
<li>单向、双向</li>
<li>带头、不带头</li>
<li>循环、非循环</li>
</ol>
<p>以上的情况组合起来就有23 = 8 种链表结构。实际中最常用的是无头单项非循环链表以及带头双向循环链表</p>
<h3 id="不带头单向非循环链表"><a href="#不带头单向非循环链表" class="headerlink" title="不带头单向非循环链表"></a>不带头单向非循环链表</h3><ol>
<li>链表的实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLTDateType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SLTDateType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;SListNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个节点以及打印数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态申请一个节点</span></span><br><span class="line">SListNode* <span class="title function_">BuySListNode</span><span class="params">(SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* new = (SListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SListNode));</span><br><span class="line">	new-&gt;data = x;</span><br><span class="line">	new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单链表打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPrint</span><span class="params">(SListNode* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* cur = plist;</span><br><span class="line">	<span class="keyword">while</span> (cur)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>插入节点，头插：O(1)、尾插O(n)、任意位置之后插入O(1)。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表的头插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushFront</span><span class="params">(SListNode** pplist, SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* new = BuySListNode(x);</span><br><span class="line">	<span class="keyword">if</span> (*pplist == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*pplist = new;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	new-&gt;next = *pplist;</span><br><span class="line">	*pplist = new;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单链表尾插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushBack</span><span class="params">(SListNode** pplist, SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* new = BuySListNode(x);</span><br><span class="line">	<span class="keyword">if</span> (*pplist == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*pplist = new;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SListNode* cur = *pplist;</span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cur-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单链表在pos位置之后插入x</span></span><br><span class="line"><span class="comment">//单向的特性导致它只能从头到尾走，所以获得一个位置的同时只能知道它的下一个位置，而不能知道它前一个位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListInsertAfter</span><span class="params">(SListNode* pos, SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SListNode* new = BuySListNode(x);</span><br><span class="line">	SListNode* next = pos-&gt;next;</span><br><span class="line">	pos-&gt;next = new;</span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>删除节点，头删O(1)、尾删O(n)、任意位置删除O(1)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表头删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPopFront</span><span class="params">(SListNode** pplist)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* first = *pplist;</span><br><span class="line">	<span class="keyword">if</span> (first == <span class="literal">NULL</span> || first-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(first);</span><br><span class="line">		*pplist = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SListNode* after = first-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(first);</span><br><span class="line">	*pplist = after;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单链表的尾删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPopBack</span><span class="params">(SListNode** pplist)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* back = *pplist;</span><br><span class="line">	SListNode* before = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (back == <span class="literal">NULL</span> || back-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(back);</span><br><span class="line">		*pplist = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (back-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		before = back;</span><br><span class="line">		back = back-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(back);</span><br><span class="line">	back = <span class="literal">NULL</span>;</span><br><span class="line">	before-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单链表删除pos位置之后的值,原因同任意位置插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListEraseAfter</span><span class="params">(SListNode* pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SListNode* del = pos-&gt;next;</span><br><span class="line">	SListNode* del_next = del-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(del);</span><br><span class="line">	pos-&gt;next = del_next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>查找</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表查找</span></span><br><span class="line">SListNode* <span class="title function_">SListFind</span><span class="params">(SListNode* plist, SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	SListNode* find = plist;</span><br><span class="line">	<span class="keyword">while</span> (find)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (find-&gt;data == x)</span><br><span class="line">			<span class="keyword">return</span> find;</span><br><span class="line">		find = find-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>链表的修改较为简单，只需要找到该位置并修改数值即可，在此不多赘述。</li>
</ol>
<h3 id="带头双向循环列表"><a href="#带头双向循环列表" class="headerlink" title="带头双向循环列表"></a>带头双向循环列表</h3><ol>
<li>链表的实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LTDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LTDataType _data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* _<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* _<span class="title">prev</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"><span class="comment">//初始化一个循环结构，也是该链表的头节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;<span class="comment">//它的头节点不存储有效数据</span></span><br><span class="line">	pHead-&gt;_data = <span class="number">0</span>;</span><br><span class="line">	pHead-&gt;_next = pHead;</span><br><span class="line">	pHead-&gt;_prev = pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个节点以及打印</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="title function_">ListCreate</span><span class="params">(LTDataType x)</span><span class="comment">//创建新的节点</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* Newnode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	Newnode-&gt;_data = x;</span><br><span class="line">	Newnode-&gt;_prev = <span class="literal">NULL</span>;</span><br><span class="line">	Newnode-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListPrint</span><span class="params">(ListNode* pHead)</span><span class="comment">//打印</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead-&gt;_next;</span><br><span class="line">	<span class="keyword">while</span> (cur != pHead)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cur-&gt;_data);</span><br><span class="line">		cur = cur-&gt;_next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>插入数据，头插O(1)、尾插O(1)、任意位置之前插入O(1)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListPushFront</span><span class="params">(ListNode* pHead, LTDataType x)</span><span class="comment">//头插</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* Newnode = ListCreate(x);</span><br><span class="line">	ListNode* Front = pHead-&gt;_next;</span><br><span class="line"></span><br><span class="line">	Newnode-&gt;_next = Front;</span><br><span class="line">	Front-&gt;_prev = Newnode;</span><br><span class="line"></span><br><span class="line">	pHead-&gt;_next = Newnode;</span><br><span class="line">	Newnode-&gt;_prev = pHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListPushBack</span><span class="params">(ListNode* pHead, LTDataType x)</span><span class="comment">//尾插</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* Newnode = ListCreate(x);</span><br><span class="line">	ListNode* last = pHead-&gt;_prev;</span><br><span class="line"></span><br><span class="line">	last-&gt;_next = Newnode;</span><br><span class="line">	Newnode-&gt;_prev = last;</span><br><span class="line"></span><br><span class="line">	Newnode-&gt;_next = pHead;</span><br><span class="line">	pHead-&gt;_prev = Newnode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(ListNode* pos, LTDataType x)</span><span class="comment">//pos位置之前插入</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* Newnode = ListCreate(x);</span><br><span class="line">	ListNode* before = pos-&gt;_prev;</span><br><span class="line"></span><br><span class="line">	Newnode-&gt;_prev = before;</span><br><span class="line">	Newnode-&gt;_next = pos;</span><br><span class="line"></span><br><span class="line">	before-&gt;_next = Newnode;</span><br><span class="line">	pos-&gt;_prev = Newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>删除数据，头删O(1)、尾删O(1)、任意位置删除O(1)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListPopFront</span><span class="params">(ListNode* pHead)</span><span class="comment">//头删</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* Front = pHead-&gt;_next;</span><br><span class="line">	pHead-&gt;_next = Front-&gt;_next;</span><br><span class="line">	Front-&gt;_next-&gt;_prev = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(Front);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListPopBack</span><span class="params">(ListNode* pHead)</span><span class="comment">//尾删</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* last = pHead-&gt;_prev;</span><br><span class="line">	pHead-&gt;_prev = last-&gt;_prev;</span><br><span class="line">	last-&gt;_prev-&gt;_next = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListErase</span><span class="params">(ListNode* pos)</span><span class="comment">//pos位置删除</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* before = pos-&gt;_prev;</span><br><span class="line">	ListNode* after = pos-&gt;_next;</span><br><span class="line"></span><br><span class="line">	before-&gt;_next = after;</span><br><span class="line">	after-&gt;_prev = before;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>查找</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="title function_">ListFind</span><span class="params">(ListNode* pHead, LTDataType x)</span><span class="comment">//查找</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead-&gt;_next;</span><br><span class="line">	<span class="keyword">while</span> (cur != pHead)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;_data == x)</span><br><span class="line">			<span class="keyword">return</span> cur;</span><br><span class="line">		cur = cur-&gt;_next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>链表的修改较为简单，只需要找到该位置并修改数值即可，在此不多赘述。</li>
</ol>
<h2 id="顺序表和链表各自的特点"><a href="#顺序表和链表各自的特点" class="headerlink" title="顺序表和链表各自的特点"></a>顺序表和链表各自的特点</h2><p><strong>顺序表：</strong></p>
<ul>
<li>优点：支持随机访问，尾插尾删时间复杂度O(1)，连续的结构，实现简单。</li>
<li>缺点：其他位置的插入删除时间复杂度都为O(n)，并且在插入时有增容代价。</li>
<li>适用场景：适合频繁访问的场景</li>
</ul>
<p><strong>链表（指双向链表）：</strong></p>
<ul>
<li>优点：任意位置插入删除时间复杂度都是O(1)。</li>
<li>缺点：不支持随机访问，实现比较复杂（但用起来简单），非连续结构。</li>
<li>适用场景：频繁插入删除的场景。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>小白的自我修养</title>
    <url>/2019/12/20191206.html</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="小白的自我修养"><a href="#小白的自我修养" class="headerlink" title="小白的自我修养"></a>小白的自我修养</h3><p>一开始仅是好奇而已，忘记了自己从什么时候对计算机，编程这些东西感兴趣的，但自从一次偶然的读到_Brian W.Kernighan,Dennis M.Ritchie_所著的《C程序设计语言》之后，对于这些东西有了些初步的了解，遂起了学习的念头，但是后来又因为没有系统的计划性的学习而放弃，但是从今天开始，我想重新拾起过去的所学，首先把卸载的VS安装回来（笑），再次从头开始学习，这一次我想更加深入的学习，或者说我觉得我找到了我喜欢的行业，我更喜欢做一个创造者，按照自己的想法创作出东西来。我想利用我的一切空余时间学习它，从今天起，我要做到一下内容：</p>
<ol>
<li>通过知识的学习与实践来学习计算机语言</li>
<li>每周至少用二十小时来学习与实践</li>
<li>尝试用博客来记录自己的学习历程，也算是对自己的一种鞭策</li>
<li>努力奋斗，争取在这个行业拿到一个好的offer（当然BAT最好 heihei~）</li>
</ol>
<p>_<strong>小舟从此逝，江海寄余生。——苏轼《临江仙·夜饮东坡醒复醉》</strong>_<br>与君共勉</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构中常见的排序</title>
    <url>/2020/05/20200511.html</url>
    <content><![CDATA[<h2 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h2><ul>
<li><strong>排序</strong>：使一串记录，按照其中某个或某些关键字的大小，递增或递减的排列起来的操作</li>
<li><strong>稳定性</strong>：假定在待排序的记录序列中，存在多个具有相同关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，arr[ i ]=arr[ j ，且]arr[ i ]在arr[ j ]之前，而在排序后的序列中，arr[ i ]仍然在arr[ j ]之前，则称这种排序算法是稳定的，反之则不稳定。</li>
<li><strong>内部排序</strong>：数据元素全部放在内存中的排序</li>
<li><strong>外部排序</strong>：数据元素太多，不能同时存放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</li>
</ul>
<p>常见的排序有：</p>
<ul>
<li>插入排序：直接插入排序，希尔排序</li>
<li>选择排序：选择排序，堆排序</li>
<li>交换排序：冒泡排序，快速排序</li>
<li>归并排序：归并排序</li>
<li>非比较排序：计数排序</li>
</ul>
<span id="more"></span>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止。</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>当插入第 i (i &gt;= 1)个元素时，前边的arr[ 0 ],arr[ 1 ],…,arr[ i - 1]已经排好序，此时用arr[ i ]的排序码与arr[ i - 1 ]，arr[ i - 2 ] …的排序码进行比较，找到插入位置即将其插入，原来的元素顺序后移，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> end = i;</span><br><span class="line">		<span class="type">int</span> key = arr[end + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; arr[end] &gt; key)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[end + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间复杂度：最坏O(N<sup>2</sup>)，平均O(N<sup>2</sup>)，最好O(N)</li>
<li>空间复杂度O(1)</li>
<li>稳定性：稳定</li>
<li>数据敏感性：敏感</li>
</ol>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>直接插入排序的优化版本，在直接插入排序的基础上增加了步长这一概念，将待排序序列按照步长分成小组，组内进行插入排序，缩短步长，进行多轮排序。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> gap = size;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - gap; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> end = i;</span><br><span class="line">			<span class="type">int</span> key = arr[end + gap];</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; arr[end] &gt; key)</span><br><span class="line">			&#123;</span><br><span class="line">				arr[end + gap] = arr[end];</span><br><span class="line">				end -= gap;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[end + gap] = key;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间按复杂度：最坏O(N<sup>1.3</sup>)，平均O(N<sup>1.3</sup>)，最好O(N)</li>
<li>空间复杂度O(1)</li>
<li>稳定性，不稳定，分组时相同值元素不一定可以分到同一组，预排序时可能导致相对位置发生变化</li>
<li>数据敏感性：敏感</li>
</ol>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>从待排序的数据元素中，选出一个最小/最大的元素，存放在序列的起始位置，直到全部待排序的数据元素排完</p>
<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>在元素集合array[i]–array[n-1]中选择关键码最大(小)的数据元素，若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交，在剩余的array[ i ]–array[n-2]（array[i+1]–array[n-1]）集合中，重复上述步骤，直到集合剩余1个元素<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">select_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> start = i;</span><br><span class="line">		<span class="type">int</span> min = start;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = start + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">				min = j;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr, start, min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间复杂度：最坏O(N<sup>2</sup>)，平均O(N<sup>2</sup>)，最好O(N<sup>2</sup>)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
<li>敏感性：不敏感</li>
</ol>
<p>优化版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">select2_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> end = size - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (end &gt; begin)</span><br><span class="line">	&#123;<span class="comment">//每次选择一个最大值和最小值</span></span><br><span class="line">		<span class="type">int</span> min = begin;</span><br><span class="line">		<span class="type">int</span> max = end;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = begin + <span class="number">1</span>; i &lt;= end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt;= arr[max])</span><br><span class="line">				max = i;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt; arr[min])</span><br><span class="line">				min = i;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr, begin, min);<span class="comment">//最小值放在begin</span></span><br><span class="line">		<span class="keyword">if</span> (max == begin)</span><br><span class="line">			max = min;<span class="comment">//如果最大值位置发生变化，需要更新位置</span></span><br><span class="line">		swap(arr, end, max);<span class="comment">//最大值放在end</span></span><br><span class="line">		begin++;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>建堆进行排序，升序建大堆，降序建小堆，通过循环删除堆顶元素进行排序<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shiftDown</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size, <span class="type">int</span> parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//小堆</span></span><br><span class="line">	<span class="comment">//int child = 2 * parent + 1;</span></span><br><span class="line">	<span class="comment">//while (child &lt; size)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])</span></span><br><span class="line">	<span class="comment">//		child++;</span></span><br><span class="line">	<span class="comment">//	if (a[child] &lt; a[parent])</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		Swap(a, child, parent);</span></span><br><span class="line">	<span class="comment">//		parent = child;</span></span><br><span class="line">	<span class="comment">//		child = 2 * parent + 1;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	else</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		break;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//大堆</span></span><br><span class="line">	<span class="type">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="keyword">if</span> (arr[child] &gt; arr[parent])</span><br><span class="line">		&#123;</span><br><span class="line">			swap(arr, child, parent);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> parent = (size - <span class="number">2</span>) / <span class="number">2</span>; parent &gt;= <span class="number">0</span>; parent--)</span><br><span class="line">	&#123;</span><br><span class="line">		shiftDown(arr, size, parent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (size &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">		size--;<span class="comment">//循环删除堆顶元素并向下调整</span></span><br><span class="line">		shiftDown(arr, size, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间复杂度：恒为O(N*Log<sub>2</sub>N)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定，调整的过程中相对位置可能发生变化</li>
<li>数据敏感性：不敏感</li>
</ol>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>进行多轮比较，每次将最值移到末端，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> end = size;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(arr, i - <span class="number">1</span>, i);</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间复杂度：最坏O(N<sup>2</sup>)，平均O(N<sup>2</sup>)，最好O(N)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
<li>敏感性：敏感</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。常见的划分方式有，hoare划分，挖坑法，前后指针法。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMid</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">&#123;<span class="comment">//快排优化：三数取中</span></span><br><span class="line">	<span class="type">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (arr[begin] &lt; arr[mid])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &lt; arr[end])</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> arr[begin] &gt; arr[end] ? begin : end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[end] &lt; arr[mid])</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> arr[begin] &lt; arr[end] ? begin : end;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partion</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//hora划分</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//int key = arr[begin];//基准值</span></span><br><span class="line">	<span class="type">int</span> mid = getMid(arr, begin, end);</span><br><span class="line">	swap(arr, mid, begin);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> key = arr[begin];<span class="comment">//基准值</span></span><br><span class="line">	<span class="type">int</span> start = begin;</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (end &gt; begin &amp;&amp; arr[end] &gt;= key)</span><br><span class="line">			end--;<span class="comment">//从后往前找到第一个小于key的值</span></span><br><span class="line">		<span class="keyword">while</span> (end &gt; begin &amp;&amp; arr[begin] &lt;= key)</span><br><span class="line">			begin++;<span class="comment">//从前向后找到第一个大于key的值</span></span><br><span class="line">		swap(arr, begin, end);<span class="comment">//交换二者</span></span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr, start, begin);<span class="comment">//交换基准值和相遇位置</span></span><br><span class="line">	<span class="keyword">return</span> begin;<span class="comment">//返回改变后的基准值的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partion2</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//挖坑法</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = getMid(arr, begin, end);</span><br><span class="line">	swap(arr, mid, begin);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> key = arr[begin];<span class="comment">//挖掉基准值</span></span><br><span class="line">	<span class="keyword">while</span> (end &gt; begin)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (end &gt; begin &amp;&amp; arr[end] &gt;= key)</span><br><span class="line">			end--;<span class="comment">//先从后往前找到第一个小于key的值</span></span><br><span class="line">		arr[begin] = arr[end];<span class="comment">//填补基准值挖出来的坑</span></span><br><span class="line">		<span class="keyword">while</span> (end &gt; begin &amp;&amp; arr[begin] &lt;= key)</span><br><span class="line">			begin++;<span class="comment">//从前往后找到第一个大于key的值</span></span><br><span class="line">		arr[end] = arr[begin];<span class="comment">//填补上一步挖的坑</span></span><br><span class="line">	&#125;</span><br><span class="line">	arr[begin] = key;<span class="comment">//相遇时把基准值塞进来</span></span><br><span class="line">	<span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partion3</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//前后指针法</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = getMid(arr, begin, end);</span><br><span class="line">	swap(arr, mid, begin);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> prev = begin;<span class="comment">//prev：最后一个小于基准值的位置</span></span><br><span class="line">	<span class="type">int</span> cur = prev + <span class="number">1</span>;<span class="comment">//cur：新发现的下一个小于基准值的位置</span></span><br><span class="line">	<span class="type">int</span> key = arr[begin];<span class="comment">//基准值</span></span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[cur] &lt; key &amp;&amp; ++prev != cur)<span class="comment">//新发现的小于基准值的数据和prev不连续，说明中间含有大于基准值的数据，故交换</span></span><br><span class="line">			swap(arr, cur, prev);<span class="comment">//小数据向前，大数据向后</span></span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr, begin, prev);</span><br><span class="line">	<span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//快速排序</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> keyPos = partion2(arr, begin, end);</span><br><span class="line">	quick_Sort(arr, begin, keyPos - <span class="number">1</span>);</span><br><span class="line">	quick_Sort(arr, keyPos + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间复杂度：最坏O(N<sup>2</sup>)（优化后可以避免），平均O(N* Log<sub>2</sub>N)，最好O(N* Log<sub>2</sub>N)</li>
<li>空间复杂度：O( Log<sub>2</sub>N) 函数调用栈，极端情况O(N)(优化后可避免)</li>
<li>稳定性：不稳定</li>
<li>敏感性：敏感</li>
</ol>
<p>非递归实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈实现非递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_Sort_NoR_Stack</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack st;</span><br><span class="line">	StackInit(&amp;st);</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		StackPush(&amp;st, size - <span class="number">1</span>);</span><br><span class="line">		StackPush(&amp;st, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!StackEmpty(&amp;st))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> begin = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line">		<span class="type">int</span> end = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> keyPos = partion2(arr, begin, end);</span><br><span class="line">		 </span><br><span class="line">		<span class="keyword">if</span> (keyPos + <span class="number">1</span> &lt; end)</span><br><span class="line">		&#123;</span><br><span class="line">			StackPush(&amp;st, end);</span><br><span class="line">			StackPush(&amp;st, keyPos + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (begin &lt; keyPos - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			StackPush(&amp;st, keyPos - <span class="number">1</span>);</span><br><span class="line">			StackPush(&amp;st, begin);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列实现非递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_Sort_NoR_Queue</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	Queue q;</span><br><span class="line">	QueueInit(&amp;q);</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		QueuePush(&amp;q, <span class="number">0</span>);</span><br><span class="line">		QueuePush(&amp;q, size - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!QueueEmpty(&amp;q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> begin = QueueFront(&amp;q);</span><br><span class="line">		QueuePop(&amp;q);</span><br><span class="line">		<span class="type">int</span> end = QueueFront(&amp;q);</span><br><span class="line">		QueuePop(&amp;q);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> keyPos = partion2(arr, begin, end);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (begin &lt; keyPos - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			QueuePush(&amp;q, begin);</span><br><span class="line">			QueuePush(&amp;q, keyPos - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (end &gt; keyPos + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			QueuePush(&amp;q, keyPos + <span class="number">1</span>);</span><br><span class="line">			QueuePush(&amp;q, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有 序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> mid, <span class="type">int</span> end, <span class="type">int</span>* tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> begin1 = begin, end1 = mid, begin2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">	<span class="type">int</span> idx = begin;</span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[begin1] &lt;= arr[begin2])</span><br><span class="line">			tmp[idx++] = arr[begin1++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmp[idx++] = arr[begin2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (begin1 &lt;= end1)</span><br><span class="line">		<span class="built_in">memcpy</span>(tmp + idx, arr + begin1, <span class="keyword">sizeof</span>(<span class="type">int</span>)* (end1 - begin1 + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (begin2 &lt;= end2)</span><br><span class="line">		<span class="built_in">memcpy</span>(tmp + idx, arr + begin2, <span class="keyword">sizeof</span>(<span class="type">int</span>)*(end2 - begin2 + <span class="number">1</span>));</span><br><span class="line">	<span class="built_in">memcpy</span>(arr + begin, tmp + begin, <span class="keyword">sizeof</span>(<span class="type">int</span>)* (end - begin + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_SortR</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span>* tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	merge_SortR(arr, begin, mid, tmp);</span><br><span class="line">	merge_SortR(arr, mid + <span class="number">1</span>, end, tmp);</span><br><span class="line"></span><br><span class="line">	merge(arr, begin, mid, end, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* size);</span><br><span class="line"></span><br><span class="line">	merge_SortR(arr, <span class="number">0</span>, size - <span class="number">1</span>, tmp);</span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间按复杂度：(N* Log<sub>2</sub>N)</li>
<li>空间复杂度：O(N)</li>
<li>稳定性：稳定</li>
<li>敏感性：不敏感</li>
</ol>
<p>非递归实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_Sort_NoR</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* size);</span><br><span class="line">	<span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (k &lt; size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> begin = i;</span><br><span class="line">			<span class="type">int</span> mid = i + k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (mid &gt;= size - <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> end = i + <span class="number">2</span> * k - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (end &gt;= size)</span><br><span class="line">				end = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			merge(arr, begin, mid, end, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		k *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>计数排序，统计相同元素出现次数，根据统计结果将序列回收到原有序列中，它适合小范围数据，若范围大，则空间复杂度较高。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">count_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; min)</span><br><span class="line">			min = arr[i];</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">			max = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* countArr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* range);</span><br><span class="line">	<span class="built_in">memset</span>(countArr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)* range);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		countArr[arr[i] - min]++;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (countArr[i]--)</span><br><span class="line">			arr[idx++] = i + min;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(countArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>时间复杂度：O(MAX(N，范围))</li>
<li>空间复杂度：O(范围)</li>
<li>稳定性：一般来说稳定</li>
<li>敏感性：不敏感</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言数据转发处理框架Benthos基础结构及配置</title>
    <url>/2025/05/20250506.html</url>
    <content><![CDATA[<h1 id="Go语言数据转发处理框架Benthos基础结构及配置"><a href="#Go语言数据转发处理框架Benthos基础结构及配置" class="headerlink" title="Go语言数据转发处理框架Benthos基础结构及配置"></a>Go语言数据转发处理框架<code>Benthos</code>基础结构及配置</h1><h2 id="benthos基本配置"><a href="#benthos基本配置" class="headerlink" title="benthos基本配置"></a>benthos基本配置</h2><p>benthos的配置文件格式为<code>yaml</code>, 按照逻辑基本可以划分为三个段落, <code>input</code>, <code>processor</code>, <code>output</code>, 数据自<code>input</code>接收, 经过 <code>processor</code>处理, 通过<code>output</code>产出, 另外还有一些<code>logger</code>等其余配置, 各个常用内容大致如下:</p>
<ul>
<li><code>input</code>: 数据的输入源</li>
<li><code>processors</code>: 一系列处理器</li>
<li><code>caches</code>: 一种键/值存储，可供某些组件用于诸如重复数据删除或数据连接等应用, 一般使用 <code>cache_resources</code> 配置</li>
<li><code>rate limits</code>: 限速器, 一般使用 <code>rate_limit_resources</code> 配置</li>
<li><code>buffers</code>: 缓冲区, 一般紧接着 <code>input</code>, 用于缓冲输入到下游之间的数据</li>
<li><code>metrics</code>: 审计内容</li>
<li><code>tracers</code>: 追踪器, 用于消息的跟踪</li>
</ul>
<p>一个基础的<code>benthos</code>配置文件可以参考如下</p>
<span id="more"></span>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span> <span class="comment"># 为benthos开启一个HTTP服务, 包含一些基础的请求访问, 例如 /ping /ready /version三个api, 可以通过访问/endpoints获取所有api</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:4195</span></span><br><span class="line">  <span class="attr">debug_endpoints:</span> <span class="literal">false</span> <span class="comment"># 是否开启debug模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据的输入, 这里使用了kafka组件</span></span><br><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">addresses:</span> [ <span class="string">TODO</span> ]</span><br><span class="line">    <span class="attr">topics:</span> [ <span class="string">foo</span>, <span class="string">bar</span> ]</span><br><span class="line">    <span class="attr">consumer_group:</span> <span class="string">foogroup</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># buffer用于在input之后的缓冲, 可以在此对数据分组或其他操作</span></span><br><span class="line"><span class="attr">buffer:</span></span><br><span class="line">  <span class="attr">none:</span> {}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道, 表示数据的处理流程, 数据将会按照processors中数组定义的顺序依次执行</span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      root.message = this</span></span><br><span class="line"><span class="string">      root.meta.link_count = this.links.length()</span></span><br><span class="line"><span class="string"></span>  <span class="bullet">-</span> <span class="attr">custom_process:</span> {}</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">resources:</span> <span class="string">some_processor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出器, 数据最终将通过此组件输出</span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">aws_s3:</span></span><br><span class="line">    <span class="attr">bucket:</span> <span class="string">TODO</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">'${! meta("kafka_topic") }/${! json("message.id") }.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各种resources定义, 以下的命名是benthos的关键字, 不能随便改</span></span><br><span class="line"><span class="comment"># 在这里可以预先定义好input, processor等, 并使用label标记, 随后在对应组件位置使用</span></span><br><span class="line"><span class="attr">input_resources:</span> []</span><br><span class="line"><span class="attr">cache_resources:</span> []</span><br><span class="line"><span class="attr">processor_resources:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lable:</span> <span class="string">some_processor</span></span><br><span class="line">    <span class="attr">do_something:</span> {}</span><br><span class="line"><span class="attr">rate_limit_resources:</span> []</span><br><span class="line"><span class="attr">output_resources:</span> []</span><br><span class="line"></span><br><span class="line"><span class="attr">logger:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">INFO</span></span><br><span class="line">  <span class="attr">static_fields:</span></span><br><span class="line">    <span class="string">'@service'</span><span class="string">:</span> <span class="string">benthos</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metrics:</span></span><br><span class="line">  <span class="attr">prometheus:</span> {}</span><br><span class="line"></span><br><span class="line"><span class="attr">shutdown_timeout:</span> <span class="string">20s</span></span><br><span class="line"><span class="attr">shutdown_delay:</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>http.debug_endpoints 开关开启后, 将包含一下接口</p>
<ul>
<li><code>/debug/config/json</code>以 JSON 形式返回已加载的配置。</li>
<li><code>/debug/config/yaml</code>以 YAML 形式返回已加载的配置。</li>
<li><code>/debug/pprof/block</code>以 pprof 格式的块配置文件进行响应。</li>
<li><code>/debug/pprof/heap</code>以 pprof 格式的堆配置文件进行响应。</li>
<li><code>/debug/pprof/mutex</code>以 pprof 格式的互斥配置文件进行响应。</li>
<li><code>/debug/pprof/profile</code>以 pprof 格式的 CPU 配置文件进行响应。</li>
<li><code>/debug/pprof/goroutine</code>以 pprof 格式的 goroutine 配置文件进行响应。</li>
<li><code>/debug/pprof/symbol</code>查找请求中列出的程序计数器，并以将程序计数器映射到函数名称的表进行响应。</li>
<li><code>/debug/pprof/trace</code>以二进制形式响应执行跟踪。跟踪持续时间（以秒为单位，由 GET 参数指定），如果未指定，则为 1 秒。</li>
<li><code>/debug/stack</code>返回当前服务堆栈跟踪的快照。</li>
</ul>
</blockquote>
<h2 id="input组件"><a href="#input组件" class="headerlink" title="input组件"></a><code>input</code>组件</h2><p><code>input</code>组件分为<code>input</code>和<code>batchInput</code>, 定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AckFunc 是一个通用函数，由输入组件返回，用于消费消息的确认，每个消息被消费后必须调用一次。</span></span><br><span class="line"><span class="comment">// 这个函数的作用是确保消息来源接收到要么是确认（err 为 nil），要么是一个错误，错误要么作为 nack 传播到上游，要么触发重新投递相同消息的机制。</span></span><br><span class="line"><span class="comment">// 如果你的输入组件实现中没有具体处理 nack 的机制，那么你可以包装你的输入组件实现 AutoRetryNacks，以获得自动重试。</span></span><br><span class="line"><span class="keyword">type</span> AckFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Closer 由支持停止和清理其底层资源的组件实现</span></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// 关闭组件，直到底层资源被清理或上下文被取消时阻塞。若上下文被取消，则返回一个错误。</span></span><br><span class="line">	Close(ctx context.Context) <span class="type">error</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Input 是由 Benthos 输入实现的接口。对 Read 的调用应当阻塞，直到接收到消息、连接丢失或提供的上下文被取消。 </span></span><br><span class="line"><span class="keyword">type</span> Input <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// 建立与上游服务的连接。在实例化读取器时，将始终首先调用 Connect，并将连续调用，直到返回 nil 错误。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="comment">// 提供的上下文仅在连接阶段期间保持打开，不应用于建立连接本身的生命周期。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="comment">// 一旦 Connect 返回 nil 错误，将调用 Read 方法，直到返回 ErrNotConnected 或读取器被关闭。</span></span><br><span class="line">	Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从源中读取单个消息，以及在消息可以被确认（成功发送或故意过滤）或否定（未能处理或发送到输出）时调用的函数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="comment">// AckFunc 将至少为每条消息调用一次，但没有保证会在何时发生。如果您的输入实现没有特定的机制来处理 nack，您可以将输入实现包装在 AutoRetryNacks 中，以获得自动重试。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如果此方法返回 ErrNotConnected，则在 Connect 返回 nil 错误之前将不会再次调用 Read。如果返回 ErrEndOfInput，则不再调用 Read，处理管道将优雅地终止。</span></span><br><span class="line">	Read(context.Context) (*Message, AckFunc, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">	Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchInput 是一个接口，由 Benthos 输入实现，该输入以批量方式生成</span></span><br><span class="line"><span class="comment">// 消息，在处理和发送整个批次时希望作为一个逻辑组，而不是单个消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ReadBatch 的调用应该阻塞，直到准备好处理一批消息、连接丢失或</span></span><br><span class="line"><span class="comment">// 提供的上下文被取消。</span></span><br><span class="line"><span class="keyword">type</span> BatchInput <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// 建立与上游服务的连接。Connect 在读取器实例化时总是</span></span><br><span class="line">	<span class="comment">// 首先被调用，并将持续调用，采用退避策略，直到返回 nil 错误。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 提供的上下文仅在连接阶段持续有效，不应用于建立</span></span><br><span class="line">	<span class="comment">// 连接本身的生命周期。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 一旦 Connect 返回 nil 错误，将会调用 Read 方法，直到</span></span><br><span class="line">	<span class="comment">// 返回 ErrNotConnected，或关闭读取器。</span></span><br><span class="line">	Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从源读取一批消息，以及一个函数，该函数将在整个批次</span></span><br><span class="line">	<span class="comment">// 可以被成功确认（已成功发送或故意过滤）或被否认（处理失败或</span></span><br><span class="line">	<span class="comment">// 无法发送到输出）时被调用。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// AckFunc 将至少为每个消息批次调用一次，但没有保证</span></span><br><span class="line">	<span class="comment">// 何时会发生。如果您的输入实现没有特定的机制来处理 nack，</span></span><br><span class="line">	<span class="comment">// 则可以使用 AutoRetryNacksBatched 来包装您的输入实现</span></span><br><span class="line">	<span class="comment">// 以获得自动重试。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如果此方法返回 ErrNotConnected，则 ReadBatch 不会</span></span><br><span class="line">	<span class="comment">// 再次被调用，直到 Connect 返回 nil 错误。如果返回 ErrEndOfInput，</span></span><br><span class="line">	<span class="comment">// 则将不再调用 Read，管道将优雅地终止。</span></span><br><span class="line">	ReadBatch(context.Context) (MessageBatch, AckFunc, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">	Closer</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>自定义的<code>Input</code>组件应该实现以上两种方法之一, 并在包的<code>init</code>方法中注册, 使用 <code>RegisterInput</code> 或 <code>RegisterBatchInput</code>, <code>Input</code>组件的工作流程大致如下:</p>
<ol>
<li>不断调用<code>Connect</code>方法, 直到其返回<code>nil</code></li>
<li>不断调用<code>Read</code>/<code>ReadBatch</code>方法, 直到其返回 <code>ErrNotConnected</code>, 此时将会重新从第一步开始, 返回<code>ErrEndOfInput</code>则会终止整个流水线, 或者当ctx超时</li>
<li>在退出时调用 <code>Close</code>方法</li>
</ol>
<p>一个<code>input</code>组件可参考如下, 其从<code>Redis</code>的<code>stream</code>中接收数据并处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">my_redis_input</span> <span class="comment"># 这个标签和input_resources中不是一个东西, 这个是方便做metric用的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用benthos自带的redis_streams组件</span></span><br><span class="line">  <span class="attr">redis_streams:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">tcp://localhost:6379</span></span><br><span class="line">    <span class="attr">streams:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">benthos_stream</span></span><br><span class="line">    <span class="attr">body_key:</span> <span class="string">body</span></span><br><span class="line">    <span class="attr">consumer_group:</span> <span class="string">benthos_group</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Optional list of processing steps</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">       root.document = this.without("links")</span></span><br><span class="line"><span class="string">       root.link_count = this.links.length()</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="关于input组件所返回的ackfun"><a href="#关于input组件所返回的ackfun" class="headerlink" title="关于input组件所返回的ackfun"></a>关于<code>input</code>组件所返回的ackfun</h3><h5 id="ackfunc的调用时机"><a href="#ackfunc的调用时机" class="headerlink" title="ackfunc的调用时机"></a>ackfunc的调用时机</h5><p>在Benthos中，消息确认函数(ackfunc)的调用时机与消息处理流程密切相关。当消息成功到达输出目的地并被确认后，ackfunc才会被调用, 这遵循Benthos的严格传递保证机制。</p>
<p>例如，在同步响应场景中，文档明确指出：</p>
<p>然而，重要的是要记住，由于Redpanda Connect的严格传递保证，响应消息实际上不会被返回，直到消息已经到达其输出目的地并且可以进行确认。</p>
<h5 id="错误处理与ackfunc的关系"><a href="#错误处理与ackfunc的关系" class="headerlink" title="错误处理与ackfunc的关系"></a>错误处理与ackfunc的关系</h5><p>当处理器中发生错误时，Benthos不会简单地丢弃消息，而是会标记这些消息并继续尝试发送它们：</p>
<p>一些处理器有可能失败的条件, Benthos不会丢弃失败的消息，而是仍然尝试将这些消息发送出去，并且有过滤、恢复或死信队列处理失败消息的机制。</p>
<h5 id="处理器错误与ackfunc"><a href="#处理器错误与ackfunc" class="headerlink" title="处理器错误与ackfunc"></a>处理器错误与ackfunc</h5><p>当处理器返回非nil的错误时，消息会被标记为失败，但仍会继续通过管道传递。这些错误不会直接传递到input的ackfunc中，而是会：</p>
<ol>
<li>增加相应处理器的错误指标</li>
<li>生成描述错误的调试级别日志</li>
<li>为消息添加错误标志</li>
</ol>
<h5 id="ackfunc捕获链路中错误信息"><a href="#ackfunc捕获链路中错误信息" class="headerlink" title="ackfunc捕获链路中错误信息"></a>ackfunc捕获链路中错误信息</h5><p>需要保证一下几点</p>
<ol>
<li>中间processor不重置消息</li>
<li>在output组件中将message中的错误信息返回</li>
</ol>
</blockquote>
<h3 id="broker包装器"><a href="#broker包装器" class="headerlink" title="broker包装器"></a><code>broker</code>包装器</h3><p>在正常情况下, 一个配置文件只允许存在一个<code>Input</code>组件, 如果有多个, 需要使用包装器<code>broker</code>来组合多个输入</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># All config fields, showing default values</span></span><br><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">copies:</span> <span class="number">1</span> <span class="comment"># 如果副本数大于零，则列表将被复制该次数。例如，如果您的输入类型为 foo 和 bar，且“copies”设置为“2”，则最终将得到两个“foo”输入和两个“bar”输入</span></span><br><span class="line">    <span class="attr">inputs:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">amqp_0_9:</span> <span class="comment"># 这个是官网配置, 总是这就是一个组件</span></span><br><span class="line">          <span class="attr">urls:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">amqp://guest:guest@localhost:5672/</span></span><br><span class="line">          <span class="attr">consumer_tag:</span> <span class="string">benthos-consumer</span></span><br><span class="line">          <span class="attr">queue:</span> <span class="string">benthos-queue</span></span><br><span class="line">          <span class="comment"># Optional list of input specific processing steps</span></span><br><span class="line">        <span class="attr">processors:</span> <span class="comment"># 这里可以紧接一个processor来对数据做处理, 不影响接下来的流程</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              root.message = this</span></span><br><span class="line"><span class="string">              root.meta.link_count = this.links.length()</span></span><br><span class="line"><span class="string">              root.user.age = this.user.age.number()</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">kafka:</span> <span class="comment"># 第二个输入源, kafka</span></span><br><span class="line">          <span class="attr">addresses:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">localhost:9092</span></span><br><span class="line">          <span class="attr">client_id:</span> <span class="string">benthos_kafka_input</span></span><br><span class="line">          <span class="attr">consumer_group:</span> <span class="string">benthos_consumer_group</span></span><br><span class="line">          <span class="attr">topics:</span> [ <span class="string">benthos_stream:0</span> ]</span><br><span class="line">    <span class="attr">batching:</span> <span class="comment"># 可以使用批处理字段为代理配置批处理策略。执行此作时，将合并来自所有子 Importing 的源。某些内置的 inputs 组件不支持基于代理的批处理，并在其文档中指定了这一点。</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">0</span> <span class="comment"># 指定批次应刷新的消息数量。如果设置为 0 则禁用基于计数的批次。</span></span><br><span class="line">      <span class="attr">byte_size:</span> <span class="number">0</span> <span class="comment"># 指定批次刷新的字节数。如果设置为 0 则禁用基于大小的批次刷新。</span></span><br><span class="line">      <span class="attr">period:</span> <span class="string">""</span> <span class="comment"># 无论批次大小如何，都应刷新不完整批次的时间段。其实就是超时时间, 可以使1s 1m, 15s这样的字符串</span></span><br><span class="line">      <span class="attr">check:</span> <span class="string">""</span> <span class="comment"># Bloblang 查询应返回一个布尔值，指示消息是否应结束批处理。</span></span><br><span class="line">      <span class="attr">processors:</span> [] <span class="comment"># No default (optional) # 刷新批次时应用的处理器列表。这允许您以合适的方式聚合和归档批次。请注意，所有生成的消息都将作为单个批次刷新，因此使用这些处理器将批次拆分为更小的批次是无操作的。这里可以接一些简短的处理组件, 例如format之类的</span></span><br></pre></td></tr></table></figure>
<h3 id="grnrtate组件"><a href="#grnrtate组件" class="headerlink" title="grnrtate组件"></a><code>grnrtate</code>组件</h3><p>使用无需上下文即可执行的Bloblang映射，按给定间隔生成消息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Config fields, showing default values</span></span><br><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">generate:</span></span><br><span class="line">    <span class="attr">mapping:</span> <span class="string">root</span> <span class="string">=</span> <span class="string">"hello world"</span> <span class="comment"># No default (required), 用于生成消息</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">1s</span> <span class="comment"># 时间间隔, 还可以是 1m, 1h, 0,30 */2 * * * *, '@every 1s' TZ=Europe/London 30 3-6,20-23 * * * 的形式</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">0</span> <span class="comment"># 可选生成的消息数量，如果设置为 0 以上，则会生成指定数量的消息，然后输入将关闭。</span></span><br><span class="line">    <span class="attr">batch_size:</span> <span class="number">1</span> <span class="comment"># 按照指定的时间间隔刷新到每批中应累积的生成消息的数量</span></span><br><span class="line">    <span class="attr">auto_replay_nacks:</span> <span class="literal">true</span> <span class="comment"># 是否应无限期地自动重放输出级别被拒绝（nack）的消息，如果拒绝的原因持续存在，最终会导致背压。如果设置为“否”，false这些消息将被删除。禁用自动重放可以大大提高高吞吐量流的内存效率，因为数据的原始形状可以在消费和更改时立即丢弃。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多组件参考 <a href="https://docs.redpanda.com/redpanda-connect/components/inputs/about/">https://docs.redpanda.com/redpanda-connect/components/inputs/about/</a></p>
</blockquote>
<h2 id="processor组件"><a href="#processor组件" class="headerlink" title="processor组件"></a><code>processor</code>组件</h2><p>processor组件分为<code>Processor</code>和<code>BatchProcessor</code>, 定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Processor 是 Benthos 处理器的一种实现，用于处理单个消息。</span></span><br><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// Process 将一个消息处理成一个或多个结果消息，或在消息无法被处理时返回错误。若返回零条消息且错误为 nil，则表明该消息已被过滤。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 当返回错误时，输入消息将继续沿管道传递但会带有错误标记（通过 *message.SetError），同时会记录指标和日志。失败的消息可以按照 https://docs.redpanda.com/redpanda-connect/configuration/error_handling 中的模式进行处理。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 返回的 Message 类型必须来源于提供的消息，且不可自定义 Message 实例。如需复制提供的消息，请使用 Copy 方法。</span></span><br><span class="line">	Process(context.Context, *Message) (MessageBatch, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">	Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchProcessor 是 Benthos 处理器的一种实现，用于处理消息批次，这使得滑动窗口处理得以实现。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 消息批次必须由上游组件（如输入组件、缓冲组件等）创建，否则该处理器将只能处理包含单个消息的批次。</span></span><br><span class="line"><span class="keyword">type</span> BatchProcessor <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// Process a batch of messages into one或多个结果 batches，若整个批次无法被处理则返回错误。若返回零条消息且错误为 nil，则表明所有消息均被过滤。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 提供的 MessageBatch 不得被修改，如需返回修改后的批次 Tortoise，必须创建一个切片的副本。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 当返回错误时，所有输入消息将继续沿管道传递但会带有错误标记（通过 *message.SetError），同时会记录指标和日志。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如需向批次中的单个消息添加供下游处理的错误，使用 *message.SetError(err) 方法，并在结果批次中将其返回，同时错误参数为 nil。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 返回的 Message 类型必须来源于所提供的消息，不可自定义 Message 实例。如需复制提供的消息，请使用 Copy 方法。</span></span><br><span class="line">	ProcessBatch(context.Context, MessageBatch) ([]MessageBatch, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">	Closer</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果想要实现自定义<code>processor</code>直接实现以上两种方法之一即可, 需要注意的一些点为</p>
<ol>
<li><p>整个流程中, 如果某个或多个<code>Process</code>或<code>ProcessBatch</code>返回了非<code>nil</code>的<code>error</code>, <strong>不会导致数据处理流程中断,</strong> <strong>而是会继续流转</strong>, 直到最终走到<code>output</code>组件后, 层层返回<code>Ack</code>, 如果想要实现中间一个流程失败, 后续处理器都不处理或做其他处理等可以参考以下写法</p>
<ol>
<li><p>在<code>Process</code>方法中处理, 存在错误则直接跳过消息处理</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *myPerssor)</span></span> Process(ctx context.Context, msg *service.Message) (service.MessageBatch, <span class="type">error</span>) {</span><br><span class="line">	err := msg.GetError() <span class="comment">// 从消息中获取错误, 如果获取到的非空, 就直接返回, 跳过该消息的处理</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置中通过<code>catch</code>或<code>try</code>处理, 通过<code>catch</code>捕获失败的处理, 或通过<code>try</code>尝试处理</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">foo</span> <span class="comment"># 先使用 foo 处理器处理</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">catch:</span> <span class="comment"># 如果上一步处理错误, 将会执行 bar 和 baz</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">bar</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">baz</span></span><br><span class="line">    <span class="comment">#当消息离开 catch 块时, 错误标记将会被清除</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">try:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Skip if processor_1 fails</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_3</span> <span class="comment"># Skip if processor_1 or processor_2 fails</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">try:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_3</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">catch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">log:</span></span><br><span class="line">          <span class="attr">message:</span> <span class="string">"Processor ${!error_source_label()} failed due to: ${!error()}"</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_3</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">catch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          root = this</span></span><br><span class="line"><span class="string">          root.meta.error = error()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>switch</code>处理器检查错误</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">switch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">errored()</span></span><br><span class="line">        <span class="attr">processors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Processes rerouted messages</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更错错误处理等参考 <a href="https://docs.redpanda.com/redpanda-connect/configuration/error_handling/">https://docs.redpanda.com/redpanda-connect/configuration/error_handling/</a></p>
</li>
</ol>
</li>
<li><p>在整个流程中, 消息始终存在一份, 如果没有特殊情况, 应该将输入修改后直接传出, 不能在消息内直接新建消息返回</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *myPerssor)</span></span> Process(ctx context.Context, msg *service.Message) (service.MessageBatch, <span class="type">error</span>) {</span><br><span class="line">	err := msg.GetError()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回消息中存储的结构化数据, 其中 Mut 后缀代表你可以直接对返回值进行修改</span></span><br><span class="line">    tmpTask, err := msg.AsStructuredMut()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    task := tmpTask.(*types.TaskProcess)</span><br><span class="line">    task.SomeVal = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接返回原始消息</span></span><br><span class="line">    <span class="keyword">return</span> service.MessageBatch{msg}, <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新set数据</span></span><br><span class="line">    msg.SetStructuredMut(newTask())</span><br><span class="line">    msg.SetStructuredMut(task)</span><br><span class="line">    <span class="keyword">return</span> service.MessageBatch{msg}, <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// !!! 不能这么干 !!!</span></span><br><span class="line">    <span class="keyword">return</span> service.MessageBatch{service.NewMessage([]<span class="type">byte</span>(<span class="string">"xxx"</span>))}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="processor常见配置"><a href="#processor常见配置" class="headerlink" title="processor常见配置"></a><code>processor</code>常见配置</h3><p>处理器是通过 config 设置的，根据它们在配置中的位置，它们将在特定输入之后（在 input 部分中设置）、所有消息（在 pipeline 部分中设置）或特定输出之前（在 output 部分中设置）立即运行。大多数处理器适用于所有消息，并且可以放置在 pipeline 部分中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">my_cool_mapping</span></span><br><span class="line">      <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this</span></span><br><span class="line"><span class="string">        root.meta.link_count = this.links.length()</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 <code>pipeline</code>:</p>
<p>在 Redpanda Connect 配置中，<code>input</code>和<code>output</code>之间是一个<code>pipeline</code>部分。本节介绍将应用于所有消息且不绑定到任何特定 input 或 output 的处理器数组。</p>
<p>如果处理器占用大量 CPU，并且不依赖于某个特定的输入或输出，则它们最适合 pipeline 部分。使用 pipeline 部分是有利的，因为它允许您设置并行执行线程的显式数量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">resource:</span> <span class="string">foo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">4</span> <span class="comment"># 如果字段 threads 设置为 -1（默认值），它将自动匹配可用的逻辑 CPU 数量</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root = this</span></span><br><span class="line"><span class="string">        fans = fans.map_each(match {</span></span><br><span class="line"><span class="string">          this.obsession &gt; 0.5 =&gt; this</span></span><br><span class="line"><span class="string">          _ =&gt; deleted()</span></span><br><span class="line"><span class="string">        })</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">resource:</span> <span class="string">bar</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>也可以使用<code>processor</code>作为输出并配合<code>reject</code>, 前提是<code>processor</code>可以返回错误并且是唯一错误, 例如<code>Redis</code>的插入失败等, 配置如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">reject:</span> <span class="string">'failed to send data: ${! error() }'</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">try:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">redis:</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">tcp://localhost:6379</span></span><br><span class="line">            <span class="attr">command:</span> <span class="string">sadd</span></span><br><span class="line">            <span class="attr">args_mapping:</span> <span class="string">'root = [ this.key, this.value ]'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">root</span> <span class="string">=</span> <span class="string">deleted()</span></span><br></pre></td></tr></table></figure>
<p>以上配置描述的执行流程为</p>
<ol>
<li>如果<code>redis</code>处理器执行成功, 则执行 <code>mapping</code>处理器</li>
<li>如果<code>redis</code>处理器执行失败, <code>mapping</code>处理器将不会执行, 消息路由到<code>reject</code>输出, 其将会返回一个<code>Nack</code></li>
</ol>
<h4 id="switch组件"><a href="#switch组件" class="headerlink" title="switch组件"></a><code>switch</code>组件</h4><p>根据消息的内容有条件地处理消息, 对于每个 switch case，将执行一个 <code>Bloblang</code>查询 ，如果结果为 true（或检查为空），则对消息执行子处理器, 其字段如下</p>
<ul>
<li><code>[].check</code> 一个<code>bloblang</code>查询, 应返回 <code>true</code>/<code>false</code>, 如果留空，则 case 始终通过。如果检查映射引发错误，则消息将被标记为失败 ，并且不会针对任何其他case进行测试。</li>
<li><code>[].processors</code> 处理器集合, 将要对消息执行处理的处理器列表, 将会按顺序处理</li>
<li><code>[].fallthrough</code> 布尔值 如果此 case 通过消息，是否还应执行下一个 case</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">switch:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">this.user.name.first</span> <span class="type">!=</span> <span class="string">"George"</span></span><br><span class="line">          <span class="attr">processors:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">metric:</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">MessagesWeCareAbout</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">processors:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">metric:</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">GeorgesAnger</span></span><br><span class="line">                <span class="attr">value:</span> <span class="string">${!</span> <span class="string">json("user.anger")</span> <span class="string">}</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">root</span> <span class="string">=</span> <span class="string">deleted()</span></span><br></pre></td></tr></table></figure>
<h4 id="branch组件"><a href="#branch组件" class="headerlink" title="branch组件"></a><code>branch</code>组件</h4><p><code>branch</code>组件可以通过<code>bloblang mapping</code>创建新的请求消息, 对请求消息执行一些列处理器后, 将结果映射回原始消息, 可以用于在替换内容时需要保留原始消息内容, 字段如下</p>
<ul>
<li><code>request_map</code> 字符串, 描述如何创建分支内的消息, 如果留空则表示将原始消息复制一份传进来</li>
<li><code>processors</code> array, 处理器列表</li>
<li><code>result_map</code> 字符串, 用于描述将<code>branch</code>处理器中一系列<code>processor</code>处理完毕后的消息映射回原始消息, 如果留空则原始消息不会改变</li>
</ul>
<p>如果 <code>request_map</code> 失败，则不会执行子处理器。如果子处理器本身导致 （未捕获的） 错误，则不会执行 <code>result_map</code>。如果 <code>result_map</code> 失败，则消息将保持不变</p>
<hr>
<p>更多组件参照</p>
<p><a href="https://docs.redpanda.com/redpanda-connect/components/processors/about/">https://docs.redpanda.com/redpanda-connect/components/processors/about/</a></p>
<h2 id="Output组件"><a href="#Output组件" class="headerlink" title="Output组件"></a><code>Output</code>组件</h2><p><code>output</code>组件为消息最终的输出端, 在 Redpanda Connect 配置的根目录中仅配置了一个输出。但是，输出可以是在所选代理模式下组合多个输出的<code>broker</code> ，也可以是用于多路复用不同输出的 <code>switch</code>, 其结构定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Output 是一个由 Benthos 实现的接口，用于支持单条消息的写入操作。每个调用 Write 的次数</span></span><br><span class="line"><span class="comment">// 安排应阻塞直到消息成功或不成功发送，或上下文被取消。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 支持并行调用的最大并发数由输出组件的构造函数提供的 MaxInFlight 参数</span></span><br><span class="line"><span class="comment">// 指示。</span></span><br><span class="line"><span class="keyword">type</span> Output <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// 与下游服务建立连接。Connect 总是会在输出组件实例化时被首次调用，</span></span><br><span class="line">	<span class="comment">// 并会循环调用（带有回退机制）直到返回 nil 错误。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 提供的上下文仅在连接阶段有效，不应用于控制连接本身的生命周期。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 当 Connect 返回 nil 错误后，Write 方法会被调用，直到返回 ErrNotConnected</span></span><br><span class="line">	<span class="comment">// 错误或输出组件被关闭。</span></span><br><span class="line">	Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write 将消息写入目标，若传递失败则返回相应的错误。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 若该方法返回 ErrNotConnected，则表示输出组件已断开连接，此时 Write</span></span><br><span class="line">	<span class="comment">// 方法不会再被调用，直到 Connect 返回 nil 错误。</span></span><br><span class="line">	Write(context.Context, *Message) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchOutput 是一个由 Benthos 实现的接口，用于支持批量消息的写入操作。每个调用 WriteBatch 的次数</span></span><br><span class="line"><span class="comment">// 安排应阻塞直到该批次中的所有消息成功或不成功发送，或上下文被取消。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 支持并行调用的最大并发数由输出组件的构造函数提供的 MaxInFlight 参数</span></span><br><span class="line"><span class="comment">// 指示。</span></span><br><span class="line"><span class="keyword">type</span> BatchOutput <span class="keyword">interface</span> {</span><br><span class="line">	<span class="comment">// 连接方法，如返回 nil 则表示连接成功，否则可能会重复调用并会进行回退</span></span><br><span class="line">	<span class="comment">// 尝试，直到成功结束连接操作</span></span><br><span class="line">	Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// WriteBatch 将消息批次写入目标，若传递失败则返回相应的错误。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 若该方法返回 ErrNotConnected，则表示输出组件已断开连接，此时 WriteBatch</span></span><br><span class="line">	<span class="comment">// 方法不会再被调用，直到 Connect 返回 nil 错误。</span></span><br><span class="line">	WriteBatch(context.Context, MessageBatch) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	Closer</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="output的一些机制"><a href="#output的一些机制" class="headerlink" title="output的一些机制"></a><code>output</code>的一些机制</h3><h4 id="背压机制-Back-pressure"><a href="#背压机制-Back-pressure" class="headerlink" title="背压机制 (Back pressure)"></a>背压机制 (Back pressure)</h4><p>输出端的压力将会传递到上游, 例如把水管的出口堵死, 入口就冲不进水, 当<code>output</code>被阻塞时(可能是网络问题或者是什么怪问题), 整个流水线将会停止, 直到<code>output</code>变得正常</p>
<h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>当<code>output</code>无法发送消息时(可以是<code>output</code>本身的问题, 或者上游某个步骤失败走到了这里)，错误将传递回<code>input</code>，根据协议，它将被作为 Nack 推送回源（例如 AMQP），或者将无限期地重新尝试提交直到成功（例如 Kafka）。也可以使用<code>retey</code>包装器让其无限重试, 直到成功, <code>broker</code>也可以这么操作, 常见用法如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># All config fields, showing default values</span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="attr">max_retries:</span> <span class="number">0</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">    <span class="attr">backoff:</span></span><br><span class="line">      <span class="attr">initial_interval:</span> <span class="string">500ms</span> <span class="comment"># 退避时间的初始等待时间</span></span><br><span class="line">      <span class="attr">max_interval:</span> <span class="string">3s</span> <span class="comment"># 最大退避时间</span></span><br><span class="line">      <span class="attr">max_elapsed_time:</span> <span class="string">0s</span> <span class="comment"># 整个退避操作的整体超时时间, 如果为0则不限制</span></span><br><span class="line">    <span class="attr">output:</span> <span class="literal">null</span> <span class="comment"># No default (required) # output组件</span></span><br></pre></td></tr></table></figure>
<h4 id="死信队列-Dead-letter-queues"><a href="#死信队列-Dead-letter-queues" class="headerlink" title="死信队列 (Dead letter queues)"></a>死信队列 (Dead letter queues)</h4><p>可以使用<code>fallback</code>包装器指定当原输出目标失败时的回退输出, 并按照给定好的顺序依次执行, 例如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">fallback:</span> <span class="comment"># 表示如果 aws_sqs 失败, 则使用 http_client 输出</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">aws_sqs:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">https://sqs.us-west-2.amazonaws.com/TODO/TODO</span></span><br><span class="line">        <span class="attr">max_in_flight:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http_client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://backup:1234/dlq</span></span><br><span class="line">        <span class="attr">verb:</span> <span class="string">POST</span></span><br></pre></td></tr></table></figure>
<h4 id="多路复用输出-Multiplexing-outputs"><a href="#多路复用输出-Multiplexing-outputs" class="headerlink" title="多路复用输出 (Multiplexing outputs)"></a>多路复用输出 (Multiplexing outputs)</h4><h5 id="插值多路复用"><a href="#插值多路复用" class="headerlink" title="插值多路复用"></a>插值多路复用</h5><p>配置中支持直接使用配置插值, 例如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">addresses:</span> [ <span class="string">TODO:6379</span> ]</span><br><span class="line">    <span class="attr">topic:</span> <span class="string">${!</span> <span class="string">meta("target_topic")</span> <span class="string">}</span> <span class="comment"># 使用消息的 meta 中存放的 target_topic 作为 kafka 输出 topic</span></span><br></pre></td></tr></table></figure>
<h5 id="switch多路复用"><a href="#switch多路复用" class="headerlink" title="switch多路复用"></a><code>switch</code>多路复用</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">switch:</span></span><br><span class="line">    <span class="attr">cases:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">this.type</span> <span class="string">==</span> <span class="string">"foo"</span></span><br><span class="line">        <span class="attr">output:</span></span><br><span class="line">          <span class="attr">amqp_1:</span></span><br><span class="line">            <span class="attr">urls:</span> [ <span class="string">amqps://guest:guest@localhost:5672/</span> ]</span><br><span class="line">            <span class="attr">target_address:</span> <span class="string">queue:/the_foos</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">this.type</span> <span class="string">==</span> <span class="string">"bar"</span></span><br><span class="line">        <span class="attr">output:</span></span><br><span class="line">          <span class="attr">gcp_pubsub:</span></span><br><span class="line">            <span class="attr">project:</span> <span class="string">dealing_with_mike</span></span><br><span class="line">            <span class="attr">topic:</span> <span class="string">mikes_bars</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面都没匹配上, 就会走到这里</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">output:</span></span><br><span class="line">          <span class="attr">redis_streams:</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">tcp://localhost:6379</span></span><br><span class="line">            <span class="attr">stream:</span> <span class="string">everything_else</span></span><br><span class="line">          <span class="attr">processors:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">                root = this</span></span><br><span class="line"><span class="string">                root.type = this.type.not_null() | "unknown"</span></span><br></pre></td></tr></table></figure>
<hr>
<p><code>output</code>相关组件及包装器参照 <a href="https://docs.redpanda.com/redpanda-connect/components/outputs/about/">https://docs.redpanda.com/redpanda-connect/components/outputs/about/</a></p>
]]></content>
      <categories>
        <category>benthos</category>
      </categories>
      <tags>
        <tag>benthos</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊类设计</title>
    <url>/2020/08/20200820.html</url>
    <content><![CDATA[<h1 id="只能在堆上创建对象的类"><a href="#只能在堆上创建对象的类" class="headerlink" title="只能在堆上创建对象的类"></a>只能在堆上创建对象的类</h1><ol>
<li>构造函数私有</li>
<li>提供一个静态的堆上创建对象的方法</li>
<li>防止拷贝（拷贝构造声明为私有且不实现，或者声明为delete）<span id="more"></span>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> HeapOnly* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HeapOnly;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">HeapOnly</span>()</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp; H) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testHeaponly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HeapOnly* ptr = HeapOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="只能在栈上创建对象的类"><a href="#只能在栈上创建对象的类" class="headerlink" title="只能在栈上创建对象的类"></a>只能在栈上创建对象的类</h1><ol>
<li>构造函数私有</li>
<li>提供一个静态的栈上创建对象的方法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> StackOnly <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">StackOnly</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">StackOnly</span>()	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testStackOnly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StackOnly so = StackOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：屏蔽new</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StackOnly2</span>()</span><br><span class="line">	&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="对象不能被拷贝的类"><a href="#对象不能被拷贝的类" class="headerlink" title="对象不能被拷贝的类"></a>对象不能被拷贝的类</h1><p>将拷贝构造与赋值运算符声明为delete函数或者声明为私有且不实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyBan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CopyBan</span>() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">CopyBan</span>(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">	CopyBan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="不能被继承的类"><a href="#不能被继承的类" class="headerlink" title="不能被继承的类"></a>不能被继承的类</h1><ol>
<li>父类构造声明为私有</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">NoSon</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>加上final关键字</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span> <span class="keyword">final</span></span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类只能创建一个对象，该模式可以保证该类中只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享</p>
<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><ol>
<li>构造函数私有</li>
<li>提供一个静态的方法返回单例</li>
<li>声明一个静态的单例成员</li>
<li>拷贝构造和赋值声明为delete函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;_single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> Singleton _single;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line">Singleton Singleton::_single;</span><br></pre></td></tr></table></figure>
<p>特点：实现简单，多线程情境下效率高</p>
<p>缺陷：程序启动比较满，多个单例对象初始化的顺序无法控制</p>
<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><ol>
<li>构造函数私有</li>
<li>提供一个静态的方法返回单例，第一次调用创建对象，后续调用直接返回</li>
<li>声明一个静态指针，指针初始化为nullptr</li>
<li>拷贝构造和赋值声明为delete</li>
<li>保证线程安全（修改指针），双检查提高效率</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton2* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;<span class="comment">//双检查</span></span><br><span class="line">			_mtx.<span class="built_in">lock</span>();</span><br><span class="line">			<span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//第一次调用， 创建对象</span></span><br><span class="line">				_ptr = <span class="keyword">new</span> Singleton2;</span><br><span class="line">			&#125;</span><br><span class="line">			_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> _ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">GC</span></span><br><span class="line">	&#123;</span><br><span class="line">		~<span class="built_in">GC</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(_ptr)</span><br><span class="line">				<span class="keyword">delete</span> _ptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton2</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Singleton2</span>(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> Singleton2* _ptr;</span><br><span class="line">	<span class="type">static</span> mutex _mtx;</span><br><span class="line">	<span class="type">static</span> GC _gc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton2* Singleton2::_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton2::_mtx;</span><br><span class="line">Singleton2::GC Singleton2::_gc;</span><br></pre></td></tr></table></figure>
<p>特点：延迟加载，程序启动快，可以指定多个单例对象的初始化顺序</p>
<p>缺陷：实现较为复杂</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>-C++ -类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2020/04/20200412.html</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种特殊的线性表，其只允许在固定的一端进行插入删除，进行数据的插入和删除操作的一段称为栈顶，而另一端称为栈底。栈之中的元素遵循后进先出的原则。</p>
<span id="more"></span>
<ul>
<li>压栈：栈的插入操作叫做进栈 / 压栈 / 入栈，入数据在栈顶。</li>
<li>出栈：栈的删除操作叫出栈，出数据也在栈顶。<br><img src="https://img-blog.csdnimg.cn/20200412123007232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEwNTMyMw==,size_16,color_FFFFFF,t_70" alt="栈示意图"></li>
</ul>
<h4 id="C语言中栈的实现"><a href="#C语言中栈的实现" class="headerlink" title="C语言中栈的实现"></a>C语言中栈的实现</h4><p>栈的实现一般可用数组或链表形式实现，相对而言，数组的结构更好一些，因为数组的尾插时间复杂度为O(1)。<br>此处用数组实现，代码如下：</p>
<ul>
<li>头文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持动态增长的栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> STDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	STDataType* _a;</span><br><span class="line">	<span class="type">int</span> _top;		<span class="comment">// 栈顶</span></span><br><span class="line">	<span class="type">int</span> _capacity;  <span class="comment">// 容量 </span></span><br><span class="line">&#125;Stack;</span><br><span class="line"><span class="comment">// 初始化栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(Stack* ps)</span>;</span><br><span class="line"><span class="comment">// 入栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(Stack* ps, STDataType data)</span>;</span><br><span class="line"><span class="comment">// 出栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(Stack* ps)</span>;</span><br><span class="line"><span class="comment">// 获取栈顶元素 </span></span><br><span class="line">STDataType <span class="title function_">StackTop</span><span class="params">(Stack* ps)</span>;</span><br><span class="line"><span class="comment">// 获取栈中有效元素个数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(Stack* ps)</span>;</span><br><span class="line"><span class="comment">// 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(Stack* ps)</span>;</span><br><span class="line"><span class="comment">// 销毁栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestroy</span><span class="params">(Stack* ps)</span>;</span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Realo</span><span class="params">(Stack* ps)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>函数部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(Stack* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">	ps-&gt;_capacity = <span class="number">20</span>;</span><br><span class="line">	ps-&gt;_a = (STDataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STDataType) * ps-&gt;_capacity);</span><br><span class="line">	ps-&gt;_top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Realo</span><span class="params">(Stack* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">	ps-&gt;_capacity *= <span class="number">2</span>;</span><br><span class="line">	ps-&gt;_a = (STDataType*)<span class="built_in">realloc</span>(ps-&gt;_a, <span class="keyword">sizeof</span>(STDataType)* ps-&gt;_capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(Stack* ps, STDataType data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ps-&gt;_top == ps-&gt;_capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		Realo(ps);</span><br><span class="line">	&#125;</span><br><span class="line">	ps-&gt;_a[ps-&gt;_top] = data;</span><br><span class="line">	ps-&gt;_top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(Stack* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ps-&gt;_top)</span><br><span class="line">		ps-&gt;_top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈顶元素 </span></span><br><span class="line">STDataType <span class="title function_">StackTop</span><span class="params">(Stack* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ps-&gt;_top)</span><br><span class="line">		<span class="keyword">return</span> ps-&gt;_a[ps-&gt;_top - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈中有效元素个数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(Stack* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ps-&gt;_top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(Stack* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ps-&gt;_top == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestroy</span><span class="params">(Stack* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(ps-&gt;_a);</span><br><span class="line">	ps-&gt;_a = <span class="literal">NULL</span>;</span><br><span class="line">	ps-&gt;_capacity = <span class="number">0</span>;</span><br><span class="line">	ps-&gt;_top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列也是一种特殊的线形表，其只允许在一段插入数据，在另一端删除数据，遵循<strong>先进先出</strong>的原则</p>
<ul>
<li>入队：从队尾进行插入数据的操作。</li>
<li>出队：从队头进行数据删除的操作。<br><img src="https://img-blog.csdnimg.cn/20200412130059754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEwNTMyMw==,size_16,color_FFFFFF,t_70" alt="队列示意图"></li>
</ul>
<h4 id="C语言中队列的实现"><a href="#C语言中队列的实现" class="headerlink" title="C语言中队列的实现"></a>C语言中队列的实现</h4><p>队列的实现可以使用数组和链表，但是使用一个带尾指针的单链表效果更优。<br>代码如下：</p>
<ul>
<li>头文件部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QDataType;</span><br><span class="line"><span class="comment">// 链式结构：表示队列 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span>* _<span class="title">next</span>;</span></span><br><span class="line">	QDataType _data;</span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QNode* _front;</span><br><span class="line">	QNode* _rear;</span><br><span class="line">	<span class="type">size_t</span> size;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* q)</span>;</span><br><span class="line"><span class="comment">// 队尾入队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* q, QDataType data)</span>;</span><br><span class="line"><span class="comment">// 队头出队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* q)</span>;</span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line">QNode* <span class="title function_">CreatNode</span><span class="params">(QDataType data)</span>;</span><br><span class="line"><span class="comment">// 获取队列头部元素 </span></span><br><span class="line">QDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>;</span><br><span class="line"><span class="comment">// 获取队列队尾元素 </span></span><br><span class="line">QDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>;</span><br><span class="line"><span class="comment">// 获取队列中有效元素个数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>;</span><br><span class="line"><span class="comment">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>;</span><br><span class="line"><span class="comment">// 销毁队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Queue* q)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>函数部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qnode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* q)</span></span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;_front = <span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line">QNode* <span class="title function_">CreatNode</span><span class="params">(QDataType data)</span></span><br><span class="line">&#123;</span><br><span class="line">	QNode* newNode = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	newNode-&gt;_data = data;</span><br><span class="line">	newNode-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾入队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* q, QDataType data)</span></span><br><span class="line">&#123;</span><br><span class="line">	QNode* newNode = CreatNode(data);</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;_rear == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q-&gt;_front = newNode;</span><br><span class="line">		q-&gt;_rear = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		q-&gt;_rear-&gt;_next = newNode;</span><br><span class="line">		q-&gt;_rear = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队头出队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;_front)</span><br><span class="line">	&#123;</span><br><span class="line">		QNode* next = q-&gt;_front-&gt;_next;</span><br><span class="line">		<span class="built_in">free</span>(q-&gt;_front);</span><br><span class="line">		q-&gt;_front = next;</span><br><span class="line">		<span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)</span><br><span class="line">			q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">		q-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取队列头部元素 </span></span><br><span class="line">QDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> empty = QueueEmpty(q);</span><br><span class="line">	<span class="keyword">if</span> (!empty)</span><br><span class="line">		<span class="keyword">return</span> q-&gt;_front-&gt;_data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取队列队尾元素 </span></span><br><span class="line">QDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> empty = QueueEmpty(q);</span><br><span class="line">	<span class="keyword">if</span> (!empty)</span><br><span class="line">		<span class="keyword">return</span> q-&gt;_rear-&gt;_data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取队列中有效元素个数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> q-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁队列 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Queue* q)</span></span><br><span class="line">&#123;</span><br><span class="line">	QNode* cur = q-&gt;_front;</span><br><span class="line">	<span class="keyword">while</span> (cur)</span><br><span class="line">	&#123;</span><br><span class="line">		QNode* next = cur-&gt;_next;</span><br><span class="line">		<span class="built_in">free</span>(cur);</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;_front = <span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的Boost文档搜索引擎--基于jieba分词和HTTP协议</title>
    <url>/2020/08/20200826.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更方便的使用Boost库，于是想到实现一个基于Boost离线文档的搜索引擎，对离线的HTML文件进行分析，、并对查询词进行分词（借用第三方库），然后根据相关性（简陋的相关性公式）进行排序，最终将查询结果用JSON的数据格式进行组织打包，最终通过对外的http服务将查询结果返回</p>
<span id="more"></span>
<h2 id="成品效果以及GitHub链接"><a href="#成品效果以及GitHub链接" class="headerlink" title="成品效果以及GitHub链接"></a>成品效果以及GitHub链接</h2><blockquote>
<p>由于不怎么会前端的一些语法，所以页面比较简陋</p>
</blockquote>
<p><img src="/2020/08/20200826/007S8ZIlly1gi49kgwwqmj31hc0u01a0.jpg" alt="IMG_7552"></p>
<p><img src="/2020/08/20200826/007S8ZIlly1gi49kbll6kj30rx06wwg2.jpg" alt="IMG_7553"></p>
<p>详细代码于 - GitHub链接：<a href="https://github.com/Latsummer/Boost-search-engine">GitHub  Boost-search-engine</a></p>
<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>按照处理流程，整个项目的结构可以被分为，预处理模块，索引模块，搜索模块以及服务器模块</p>
<ol>
<li>预处理模块：读取原始的HTML文档内容，进行预处理操作：解析一些重要的信息，如文档标题、文档的URL，文档的正文，即去除HTML标签，只保留正文；在预处理完毕之后，将结果整理成一个行文本文件，用以之后的模块使用</li>
<li>索引模块：将预处理好的行文本文件输入，根据预处理结果，在内存中构造正排索引（文档ID =&gt; 文档正文）和倒排索引（文档正文 =&gt; 文档ID）</li>
<li>搜索模块：输入查询词，先对查询词进行分词，然后实现触发，将查询结果按照相关性进行排序，依次拼装，按照JSON数据格式进行组织</li>
<li>服务器模块：加载搜索引擎模块，对外提供HTTP服务</li>
</ol>
<p><img src="/2020/08/20200826/007S8ZIlly1gi49l0rlk0j317m0csgnf.jpg" alt="IMG_7551"></p>
<h1 id="预处理模块"><a href="#预处理模块" class="headerlink" title="预处理模块"></a>预处理模块</h1><p>该模块核心功能为：读取并分析Boost文档的.html文件内容，解析出每个文档的标题，URL，正文，最终把结果输出为一个行文版文件</p>
<p>首先根据核心功能，定义一个可以表示一个文章的结构体，以及一些全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string g_input_path = <span class="string">&quot;../data/input/&quot;</span>;<span class="comment">//表示从哪个目录中读取boost文档中的html</span></span><br><span class="line">string g_output_path = <span class="string">&quot;../data/tmp/raw_input&quot;</span>;<span class="comment">//表示预处理模块的输出结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  string tittle;<span class="comment">//标题</span></span><br><span class="line">  string url;<span class="comment">//url</span></span><br><span class="line">  string content;<span class="comment">//正文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="枚举路径"><a href="#枚举路径" class="headerlink" title="枚举路径"></a>枚举路径</h2><p>使用Boost中的filesystem的递归文档迭代器来对每一个文件进行枚举，使用一个vector来临时存储，用于之后的解析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnumFile</span><span class="params">(<span class="type">const</span> string&amp; input_path, vector&lt;string&gt;* file_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">filesystem::path <span class="title">root_path</span><span class="params">(input_path)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">exists</span>(root_path) )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;目录不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个迭代器使用循环的时候可以自动完成递归（对文件）</span></span><br><span class="line">  boost::filesystem::recursive_directory_iterator end_iter;</span><br><span class="line">  <span class="keyword">for</span>(boost::filesystem::recursive_directory_iterator <span class="built_in">it</span>(root_path);  it != end_iter; it++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//当前路径对应的如果是目录则跳过</span></span><br><span class="line">    <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">is_regular_file</span>(*it) )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//当前路径对应的文件如果不是html文件，跳过</span></span><br><span class="line">    <span class="keyword">if</span>( it-&gt;<span class="built_in">path</span>().<span class="built_in">extension</span>() != <span class="string">&quot;.html&quot;</span> )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//把得到的路径加入到vector中</span></span><br><span class="line">    file_list-&gt;<span class="built_in">push_back</span>(it-&gt;<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h2><ol>
<li>遍历上一步vector中存放的文件路径，读取文件内容，将读取内容写入到string类型变量<code>html</code>中</li>
<li>根据读取到的内容，首先解析出标题，按照html中的标签<code>&lt;title&gt;&lt;/title&gt;</code>，调用string类成员函数<code>substr</code>获取文章标题</li>
<li>根据读取到的内容，构造对应的URL，由于网络路径和文件路径一致，所以只需要在文件的路径前加上前缀<code>https://www.boost.org/doc/libs/1_53_0/doc/</code>即可</li>
<li>根绝读取到的内容，解析正文片段，跳过字符<code>&lt;</code>和字符<code>&gt;</code>中的内容，同时将内容中的<code>\n</code>替换为空格（因为最终结果要对应到原始的html文档）</li>
<li>对于2、3、4步骤，解析出的三个内容使用不可见字符<code>\3</code>分割，然后写入删除文件<code>raw_put</code>中</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFile</span><span class="params">(<span class="type">const</span> string&amp; file_path, DocInfo* doc_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//1. 先读取文件内容</span></span><br><span class="line">  string html;</span><br><span class="line">  <span class="type">bool</span> ret = common::Util::<span class="built_in">Read</span>(file_path, &amp;html);</span><br><span class="line">  <span class="keyword">if</span>(!ret)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解析文件失败!&quot;</span> &lt;&lt; file_path &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 根据文件内容解析出标题</span></span><br><span class="line">  ret = <span class="built_in">ParseTitle</span>(html, &amp;doc_info-&gt;tittle);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;标题解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3. 根据文件路径，构造出对应的在线文档</span></span><br><span class="line">  ret = <span class="built_in">ParseUrl</span>(file_path, &amp;doc_info-&gt;url);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;url 解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4. 根据文件内容，去标签，作为doc_info中的content字段内容</span></span><br><span class="line">  ret = <span class="built_in">ParseContent</span>(html, &amp;doc_info-&gt;content);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正文解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h1><p>索引使用了正排索引和倒排索引，其结构体分别如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正排索引：给定doc_id映射到文档内容（DocInfo对象）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;</span><br><span class="line">  string _title;</span><br><span class="line">  string _url;</span><br><span class="line">  string _content;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒排索引：给定词，映射到包含该词语的文档id列表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weight</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;<span class="comment">//该词在哪个文档出现</span></span><br><span class="line">  <span class="type">int</span> _weight;<span class="comment">//对应的权重</span></span><br><span class="line">  string _word;<span class="comment">//什么词</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建一个类来表示整个索引结构，并提供外部调用的API</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Index</span>();</span><br><span class="line">    <span class="comment">//1. 查正排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> DocInfo* <span class="title">GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span>;</span><br><span class="line">    <span class="comment">//2. 查倒排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>;</span><br><span class="line">    <span class="comment">//3. 构建索引</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Build</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">DocInfo* <span class="title">BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span>;</span><br><span class="line">    cppjieba::Jieba jieba;<span class="comment">//jieba分词</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//正排索引，数组下标对应到doc_id</span></span><br><span class="line">    vector&lt;DocInfo&gt; _forward_index;</span><br><span class="line">    <span class="comment">//倒排索引，使用一个hash表来表示映射关系</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;Weight&gt; &gt; _inverted_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="创建正排索引"><a href="#创建正排索引" class="headerlink" title="创建正排索引"></a>创建正排索引</h2><p>正排索引使用vector来存放，文章的ID就是其所在位置的下标，元素内容就是预处理模块中的输出内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DocInfo* <span class="title">Index::BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vector&lt;string&gt; tokens;</span><br><span class="line">  common::Util::<span class="built_in">Split</span>(line, <span class="string">&quot;\3&quot;</span>, &amp;tokens);</span><br><span class="line">  <span class="keyword">if</span>( tokens.<span class="built_in">size</span>() != <span class="number">3</span> )<span class="comment">//如果没有被切分为3份，说明节分结果有问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//把切分结果填充到DocInfo对象中</span></span><br><span class="line">  DocInfo doc_info;</span><br><span class="line">  doc_info._doc_id = _forward_index.<span class="built_in">size</span>();</span><br><span class="line">  doc_info._title = tokens[<span class="number">0</span>];</span><br><span class="line">  doc_info._url = tokens[<span class="number">1</span>];</span><br><span class="line">  doc_info._content = tokens[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">  _forward_index.<span class="built_in">push_back</span>(<span class="built_in">move</span>(doc_info));<span class="comment">//转化为右值引用，移动语义复制赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index.<span class="built_in">back</span>();<span class="comment">//防止野指针问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建倒排索引"><a href="#创建倒排索引" class="headerlink" title="创建倒排索引"></a>创建倒排索引</h2><p>依次对标题与正文进行分词，建立统计词频的结构体，根据统计结果，填充<code>Weight</code>对象，其中成员<code>_weight</code>(权重)简单的设计了一个公式：权重 == 10 * 标题出现次数 + 正文出现次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//倒排是一个hash表</span></span><br><span class="line">  <span class="comment">//key是词（针对文档分词结果）</span></span><br><span class="line">  <span class="comment">//value是倒排拉链（包含若干个Weight对象）</span></span><br><span class="line">  <span class="comment">//每次遍历到一个文档，分析之后把信息更新到倒排结构中</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Index::BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//0. 创建专门统计词频的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">WordCnt</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> _title_cnt;</span><br><span class="line">      <span class="type">int</span> _content_cnt;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">WordCnt</span>() </span><br><span class="line">          : _title_cnt(<span class="number">0</span>)</span><br><span class="line">          , _content_cnt(<span class="number">0</span>) </span><br><span class="line">      &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    unordered_map&lt;string, WordCnt&gt; word_cnt_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 对标题进行分词</span></span><br><span class="line">    vector&lt;string&gt; title_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.title, &amp;title_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="comment">//次数要考虑大小写问题，大小写应该都算成小写</span></span><br><span class="line">    <span class="keyword">for</span>(string&amp; word : title_token)</span><br><span class="line">    &#123;</span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">      ++word_cnt_map[word]._title_cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对正文分词</span></span><br><span class="line">    vector&lt;string&gt; content_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.content, &amp;content_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (string word : content_token) </span><br><span class="line">    &#123;</span><br><span class="line">       boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">       ++word_cnt_map[word]._content_cnt;                      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 根据统计结果，整个出Weight对象，把结果更新到倒排索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; word_pair : word_cnt_map)</span><br><span class="line">    &#123;</span><br><span class="line">      Weight weight;</span><br><span class="line">      weight._doc_id = doc_info.doc_id;</span><br><span class="line">      weight._weight = <span class="number">10</span> * word_pair.second._title_cnt + word_pair.second._content_cnt;</span><br><span class="line">      weight._word = word_pair.first;</span><br><span class="line"></span><br><span class="line">      vector&lt;Weight&gt;&amp; inverted_list = _inverted_index[word_pair.first];</span><br><span class="line">      inverted_list.<span class="built_in">push_back</span>(<span class="built_in">move</span>(weight));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Index::CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    jieba.<span class="built_in">CutForSearch</span>(input, *output);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个索引模块建立完成，内存中即存在了正排索引结构和倒排索引结构，等待搜索模块去调用</p>
<h2 id="查询正排-倒排索引"><a href="#查询正排-倒排索引" class="headerlink" title="查询正排/倒排索引"></a>查询正排/倒排索引</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> DocInfo* <span class="title">Index::GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( doc_id &lt; <span class="number">0</span> || doc_id &gt;= _forward_index.<span class="built_in">size</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index[doc_id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">Index::GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = _inverted_index.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span>( it == _inverted_index.<span class="built_in">end</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Searcher</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//搜索过程中依赖索引，需要持有索引指针</span></span><br><span class="line">    Index* index;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Searcher</span>() </span><br><span class="line">        :<span class="built_in">index</span>(<span class="keyword">new</span> <span class="built_in">Index</span>())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* results)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="function">string <span class="title">GenerateDesc</span><span class="params">(<span class="type">const</span> string&amp; content, <span class="type">const</span> string&amp; word)</span></span>;<span class="comment">//生成描述</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在使用搜索模块时，创建<code>Searcher</code>对象，即<code>new</code>了一个Index对象，接着调用成员函数<code>Init</code>，它会调用Index的成员函数<code>Build</code>，来创建正排索引和倒排索引，在需要查询时，调用成员函数<code>Search</code>，完成查询过程，将结果写入string类对象<code>results</code>中</p>
<h2 id="搜索函数"><a href="#搜索函数" class="headerlink" title="搜索函数"></a>搜索函数</h2><p>搜索模块先对查询词进行分词，再根据分词结果去调用索引模块的查询正排，倒排成员函数，接着将查询结果按照权重降序排列，最后调用JSONCPP库函数来包装查询结果（同时调用相关函数来生成描述），序列化为字符串输出结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Searcher::Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//1. [分词] 针对查询结果进行分词</span></span><br><span class="line">    vector&lt;string&gt; tokens;</span><br><span class="line">    index-&gt;<span class="built_in">CutWord</span>(query, &amp;tokens);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. [触发] 根据分词结果，查询倒排，把相关文档都获取到</span></span><br><span class="line">    vector&lt;Weight&gt; all_token_result;</span><br><span class="line">    <span class="keyword">for</span>(string word : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//做索引的时候，已经把其中的词统一转成小写了</span></span><br><span class="line">      <span class="comment">//查询到排的时候，也需要把查询词统一转成小写</span></span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span>* inverted_list = index-&gt;<span class="built_in">GetInvertedList</span>(word);</span><br><span class="line">      <span class="keyword">if</span>( inverted_list == <span class="literal">nullptr</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//说明该词在倒排索引中不存在，如果这个词比较生僻，</span></span><br><span class="line">        <span class="comment">//在所有文档中都没有出现过。此时得到的倒排拉链就是nullptr</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//tokens 包含多个结果，需要把多个结果合并到一起，才能进行统一排序</span></span><br><span class="line">      all_token_result.<span class="built_in">insert</span>(all_token_result.<span class="built_in">end</span>(), </span><br><span class="line">                              inverted_list-&gt;<span class="built_in">begin</span>(), inverted_list-&gt;<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. [排序] 把刚才查到的文档的倒排拉链合并到一起并按照权重进行降序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(all_token_result.<span class="built_in">begin</span>(), all_token_result.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> Weight&amp; w1, <span class="type">const</span> Weight&amp; w2)&#123;</span><br><span class="line">      <span class="comment">//实现降序排序 w1 &gt; w2</span></span><br><span class="line">      <span class="keyword">return</span> w1.weight &gt; w2.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. [包装结果] 把得到的这些倒排拉链中的文档id获取到，然后去查正排，</span></span><br><span class="line">    <span class="comment">//             再把doc_info中的内容构造成最终的预期格式(JSON)</span></span><br><span class="line">    <span class="comment">//使用JSONCPP库来实现</span></span><br><span class="line">    Json::Value results;<span class="comment">//包含若干个结果，每个结果就是一个JSON对象对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; weight : all_token_result)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//根据weight中的结果查询正排序</span></span><br><span class="line">      <span class="type">const</span> DocInfo* doc_info = index-&gt;<span class="built_in">GetDocInfo</span>(weight.doc_id);</span><br><span class="line">      <span class="comment">//把doc_info对象进一步包装成一个JSON对象</span></span><br><span class="line">      Json::Value result;</span><br><span class="line">      result[<span class="string">&quot;title&quot;</span>] = doc_info-&gt;title;</span><br><span class="line">      result[<span class="string">&quot;url&quot;</span>] = doc_info-&gt;url;</span><br><span class="line">      result[<span class="string">&quot;desc&quot;</span>] = <span class="built_in">GenerateDesc</span>(doc_info-&gt;content, weight.word);</span><br><span class="line">      results.<span class="built_in">append</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一步，把得到的results这个JSON对象序列化为字符串，写入output中</span></span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    *output = writer.<span class="built_in">write</span>(results);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>至此，搜索模块就搭建好了，等待最终的服务器模块调用</p>
<h1 id="服务器模块"><a href="#服务器模块" class="headerlink" title="服务器模块"></a>服务器模块</h1><p>首先初始化Searcher对象，调用<code>Init</code>成员函数初始化索引结构，然后调用Server对象中的Get方法，接收网页端请求，分析参数调用查询函数，然就将结果返回给网页端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> httplib;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建Searcher对象</span></span><br><span class="line">    searcher::Searcher searcher;</span><br><span class="line">    <span class="type">bool</span> ret = searcher.<span class="built_in">Init</span>(<span class="string">&quot;../data/tmp/raw_input&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Searcher初始化失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server;</span><br><span class="line">    server.<span class="built_in">Get</span>(<span class="string">&quot;/searcher&quot;</span>, [&amp;searcher](<span class="type">const</span> Request&amp; req, Response&amp; resp)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!req.<span class="built_in">has_param</span>(<span class="string">&quot;query&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            resp.<span class="built_in">set_content</span>(<span class="string">&quot;请求参数错误&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string query = req.<span class="built_in">get_param_value</span>(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        cout  &lt;&lt; <span class="string">&quot;收到查询词：&quot;</span> &lt;&lt; query &lt;&lt; endl;</span><br><span class="line">        string results;</span><br><span class="line">        searcher.<span class="built_in">Search</span>(query, &amp;results);</span><br><span class="line">        resp.<span class="built_in">set_content</span>(results, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.<span class="built_in">set_base_dir</span>(<span class="string">&quot;./www&quot;</span>);</span><br><span class="line">    server.<span class="built_in">listen</span>(<span class="string">&quot;x.x.x.x&quot;</span>, [port]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个搜索引擎已经搭建完成，只需要运行起来即可</p>
]]></content>
      <categories>
        <category>小作品</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>（C++）static、友元、内部类</title>
    <url>/2020/05/20200527.html</url>
    <content><![CDATA[<h1 id="再谈构造函数"><a href="#再谈构造函数" class="headerlink" title="再谈构造函数"></a>再谈构造函数</h1><p>初始化列表：：成员（初始化/表达式），成员2（）…</p>
<p>每个成员变量只能在初始化列表中出现一次</p>
<p>对象成员必须在定义时初始化的地方：初始化列表</p>
<p>如果有引用成员、const成员、没有默认构造的自定义成员，必须在初始化列表中进行初始化</p>
<p>其他成员可以不进行显示初始化</p>
<!---more-->
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Time</span>(<span class="type">int</span> a)</span><br><span class="line">  &#123;</span><br><span class="line">    _a = a;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> y = <span class="number">1</span>, <span class="type">int</span> m = <span class="number">1</span>, <span class="type">int</span> d = <span class="number">1</span>)</span><br><span class="line">    :_a(d)</span><br><span class="line">    ,_b(d)</span><br><span class="line">    ,_time(<span class="number">10</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">      _year = y;</span><br><span class="line">      _month = m;</span><br><span class="line">      _day = d;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//成员变量声明的地方，此处不是定义的地方</span></span><br><span class="line">  <span class="type">int</span> _year;</span><br><span class="line">  <span class="type">int</span> _month;</span><br><span class="line">  <span class="type">int</span> _day;</span><br><span class="line">  <span class="type">int</span>&amp; _a;<span class="comment">//引用在定义时必须初始化</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> _b;<span class="comment">//const变量在定义时必须初始化</span></span><br><span class="line">  Time _time;<span class="comment">//没有默认构造的自定义成员在定义时必须初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于自定义成员，最好在初始化列表中初始化，即使不在初始化列表中显示初始化，编译器也会在初始化列表中自动调用自定义成员的默认构造完成初始化</p>
</blockquote>
<p>成员变量在初始化列表中的初始化顺序：<strong>和声明顺序一致，与其在初始化列表中的顺序无关</strong></p>
<p>注意：最好初始化列表中的成员顺序和声明顺序保持一致</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// explicit: //可以禁止掉单参构造函数的隐式类型转化</span></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">    :_a(a)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">    :_a(a._a)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//创建对象</span></span><br><span class="line">  A a2 = <span class="number">2</span>;<span class="comment">//创建对象：单参构造函数的隐式类型转换 ---&gt; 调用构造创建一个匿名对象，+拷贝构造（通过匿名对象拷贝构造a2对象）</span></span><br><span class="line">  <span class="comment">//此时用2创建了一个匿名对象，在调用拷贝构造创建a2</span></span><br><span class="line">  a2 = <span class="number">3</span>;<span class="comment">//3作为参数传入构造函数， 创建匿名对象，调用赋值重载函数，使用匿名对象给a2赋值</span></span><br><span class="line">  <span class="comment">//只支持单参构造函数的隐式类型转换，下面的代码不支持</span></span><br><span class="line">  <span class="comment">//a3 = (1, 2);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>explicit: 可以禁止掉单参构造函数的隐式类型转化</p>
</blockquote>
<h1 id="static-成员"><a href="#static-成员" class="headerlink" title="static 成员"></a>static 成员</h1><p>static可以修饰类的成员变量，成为<strong>静态成员变量</strong>，也可以修饰成员函数，称为<strong>静态成员函数</strong></p>
<p>_静态的成员<strong>变量</strong>，必须要在类外进行初始化_，定义时不加static关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()</span><br><span class="line">  &#123;_count++;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; t)</span><br><span class="line">  &#123;_count++;&#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> _count;&#125;</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">0</span>; <span class="comment">//静态的成员变量，必须要在类外进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl;</span><br><span class="line">  A a1, a2;</span><br><span class="line">  <span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;</span><br><span class="line">  cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>静态成员变量，所有对象共享此成员变量，可以看成类成员，使用时类名：：静态成员变量或对象</li>
<li>静态成员变量不能在声明时给默认值</li>
<li>静态成员变量不在对象模型中，一般放在数据段，<strong>不能再初始化列表中初始化</strong></li>
<li>静态成员函数<strong>没有this指针</strong>，不能访问任何非静态成员（因为非静态成员需要this指针）</li>
</ol>
<blockquote>
<p>普通成员只能通过对象访问，不能通过类名访问</p>
</blockquote>
<h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元函数：friend + 正常函数的定义 / 声明</p>
<p>友元函数可以访问类的私有成员</p>
<p>友元函数不是类的成员函数，它是普通的非成员函数（<strong>没有this指针</strong>）</p>
<p>只需要在<strong>类中声明</strong>友元函数，不需要在类中定义</p>
<p>友元函数可以声明在类的任何地方，不受访问限定符的约束</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, A&amp; a);<span class="comment">//返回输出流类型是为了支持连续输出</span></span><br><span class="line">  <span class="built_in">A</span>()</span><br><span class="line">  &#123;_count++;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; t)</span><br><span class="line">  &#123;_count++;&#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> _count;&#125;</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">0</span>; <span class="comment">//静态的成员变量，必须要在类外进行初始化</span></span><br><span class="line">  ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, A&amp; a)</span><br><span class="line">  &#123;_cout &lt;&lt; a._count &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl;</span><br><span class="line">  A a1, a2;</span><br><span class="line">  <span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;</span><br><span class="line">  cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; a1 &lt;&lt; a2 &lt;&lt; a3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽量少用，它是一种突破封装的语法</p>
</blockquote>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>如果一个类是另外一个类的友元类，则此类中的所有成员函数即为另一个类的友元函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//DisPlay, Fun1, Fun2都为A类的友元函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DisPlay</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; a._a &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; a._a &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="function"><span class="type">void</span> <span class="title">Fun2</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; a._a &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>友元关系是单向的！！！</strong>，友元关系也不能传递</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的内部定义一个类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> _c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类天然的作为一其外部类的友元类，即内部类可以访问外部类的成员</p>
<p>可通过外部类对象访问外部类的私有成员</p>
<p>可直接访问外部类的static成员</p>
<blockquote>
<p>内部类独立存在，不附属于外部类</p>
</blockquote>
<p>外部类不能看作内部类的友元类，对于内部类的成员没有特殊的访问权限，需要遵循访问限定符的限制</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>静态成员: static +成员变量/函数：<br><strong>静态成员函数：</strong></p>
<ol>
<li><p>静态成员函数:函数内部没有this指针</p>
</li>
<li><p>静态成员函数不能访问非静态成员函数变量–&gt;因为非静态成员需要this指针，但是静态成员函数内部缺少this指针,所以不能访问3.非静态成员函数可以访问静态成员函数变量</p>
</li>
</ol>
<p><strong>静态成员变量：</strong></p>
<ol>
<li><p>静态成员变量，所有对象共享此成员变量，可以看成类成员</p>
</li>
<li><p>静态成员变量不能在声明的时候给默认</p>
</li>
<li><p>静态成员不在对象模型中，一般存放在数据段, 不能在初始化列表中初始化</p>
</li>
<li><p>静态成员必须在类外初始化</p>
</li>
</ol>
<p><strong>静态成员变量/静态成员函数访问方式：</strong></p>
<ol>
<li><p>对象访问</p>
</li>
<li><p>类名+作用域限定符</p>
</li>
<li><p>普通成员只能通过对象访问,不能通过类名访问</p>
</li>
</ol>
<p><strong>友元函数: friend +函数定义：</strong></p>
<ol>
<li><p>友元函数尽量少用，它是一-种突破封装的语法</p>
</li>
<li><p>友元函数可以访问类的私有成员</p>
</li>
<li><p>友元函数不是类的成员函数,它是普通的非成员函数</p>
</li>
<li><p>只需要在类中声明友元函数，不需要在类中定义</p>
</li>
<li><p>友元函数可以声明在类的任何地方，不受访问限定符的限制</p>
</li>
</ol>
<p><strong>友元类: friend class 类名：</strong></p>
<ol>
<li><p>友元关系是单向的</p>
</li>
<li><p>如果一个类是另一个类的友元类，则此类中的所有成员函数即为另一个类的友元函数</p>
</li>
<li><p>友元关系不能传递，类似于朋友的朋友不一定是自己的朋友</p>
</li>
</ol>
<p><strong>内部类：在一个类内部定义一个新的类</strong></p>
<ol>
<li><p>内部类天然的作为外部类的友元类</p>
</li>
<li><p>内部类作为一-个独立的类存在，不附属于外部类</p>
</li>
<li><p>外部类不能看作内部类的友元类，对于内部类的成员没有特殊的访问权限，需要遵循访问限定符的限制</p>
</li>
<li><p>.可以通过外部类对象访问外部类的私有成员</p>
</li>
<li><p>可以直接访问外部类的static成员</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title>初识模板</title>
    <url>/2020/05/20200531.html</url>
    <content><![CDATA[<h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>编写与类型无关的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> / <span class="keyword">class</span> 泛型参数<span class="number">1</span>, <span class="keyword">typename</span> / <span class="keyword">class</span> 泛型参数<span class="number">2</span> ...... &gt;</span><br></pre></td></tr></table></figure>
<p>告诉编译器一个模板，让编译器根据不同的类型利用该模板生成代码</p>
<span id="more"></span>
<h1 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; left, T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T tmp = left;</span><br><span class="line">  left = right;</span><br><span class="line">  right = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">10</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>, d = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2020</span>)</span></span>;</span><br><span class="line">  <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">1010</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//隐式实例化：编译器根据参数进行自动推导，产生直接可执行的代码</span></span><br><span class="line">  <span class="built_in">Swap</span>(a, b);</span><br><span class="line">  <span class="built_in">Swap</span>(c, d);</span><br><span class="line">  <span class="built_in">Swap</span> (d1, d2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//显示实例化：函数名 + &lt;类型&gt; + （参数列表）</span></span><br><span class="line">  <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line">  <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(a, c);</span><br><span class="line">  <span class="built_in">add</span>&lt;<span class="type">char</span>&gt;(a, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模版实例化：用实际参数类型，生成可执行的函数</p>
<blockquote>
<p>实际上并没有减少实际的代码量，只是把重复的代码交给机器自动生成</p>
<p>减少开发人员重复的工作量，提高工作效率</p>
</blockquote>
<h2 id="模版参数的匹配规则"><a href="#模版参数的匹配规则" class="headerlink" title="模版参数的匹配规则"></a>模版参数的匹配规则</h2><ul>
<li><p>普通函数与模版函数可以共存；共存时，如果普通函数的参数类型可以完全匹配，则执行普通函数，不进行模版函数的实例化</p>
</li>
<li><p>普通函数与模版函数共存时，普通函数的参数类型不能完全匹配，但是实例化的函数可以完全匹配，则进行实例化</p>
</li>
<li><p>普通函数与模版函数共存时，指定了需要实例化（<code>Add&lt;int&gt;(a, b);</code>）,则进行实例化</p>
</li>
</ul>
<h1 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, <span class="keyword">class</span> <span class="title class_">T3</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(T1 year, T2 month, T3 day)</span><br><span class="line">    : _year(year)</span><br><span class="line">    , _month(month)</span><br><span class="line">    , _day(day)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T1 _year;</span><br><span class="line">  T2 _month;</span><br><span class="line">  T3 _day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, <span class="keyword">class</span> <span class="title class_">T3</span>&gt;</span><br><span class="line"><span class="type">void</span> Date&lt;T1, T2, T3&gt;::<span class="built_in">Display</span>()</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Date&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  d.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类模版只能显示实例化，不能进行隐式实例化</p>
<ul>
<li>类型和类名不同；类型：类名\&lt;模版实际参数类型&gt;</li>
</ul>
<blockquote>
<p>如果在类外定义类模版的成员函数，需要加上泛型的声明</p>
<p>作用域为 “类名\&lt;泛型参数&gt;”</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title>（C语言）内存的动态管理</title>
    <url>/2020/03/20200320.html</url>
    <content><![CDATA[<h2 id="内存的区域"><a href="#内存的区域" class="headerlink" title="内存的区域"></a>内存的区域</h2><p>在计算机中，内存可以被粗略的划分成，代码段、数据段、堆区以及栈区，</p>
<span id="more"></span>
<p>如下图所示<br><img src="https://img-blog.csdnimg.cn/20200320145201848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEwNTMyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>栈区一般用于存放代码中定义的生命周期较短的局部变量，而堆区则是内存管理函数所开辟内存的对象</p>
<h2 id="内存动态管理函数"><a href="#内存动态管理函数" class="headerlink" title="内存动态管理函数"></a>内存动态管理函数</h2><ul>
<li>malloc</li>
<li>calloc</li>
<li>realloc</li>
<li>free</li>
</ul>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>malloc函数可以申请一块连续的内存空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>它的参数类型是一个无符号整型，返回一个void * 类型的指针，参数size代表申请字节数，如果申请空间过大，或没有足够的空间，就可能会申请失败，申请失败时返回NULL。</p>
<p>理论上来讲，在使用malloc函数时，应该需要判断返回值是否为NULL，如果是，则程序退出。</p>
<p><strong>由malloc申请的内存，必须释放，否则就会出现“内存泄漏”的情况。</strong><br>如果程序中反复使用malloc而没有释放，那么就会导致系统内存下一直被申请，而没有被释放，内存越来越少，最终就会内存不足。</p>
<p>malloc函数申请的内存会一直持续存在到程序结束（生命周期长，跟随整个程序），除非显示使用free来进行释放。</p>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h3><p>calloc函数和malloc函数用法类似，功能也类似，最大的区别是calloc在申请到内存空间之后，会将其初始化为全0，而malloc则不会对内存进行初始化</p>
<h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>realloc函数的功能是对已申请到的内存空间进行扩容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span>* ptr , <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">p = <span class="built_in">realloc</span>(p, <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>realloc的参数分别是一个指向内存空间首地址的指针和一个数值为扩容后字节数大小的无符整型，如果当前的内存空间不足以容纳扩容后的大小，那么realloc会自动找到一块足以容纳扩容后大小的连续内存空间，将原内存中内容拷贝过去，再释放原内存空间，<strong>所以返回值和参数不一定相等！</strong></p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>释放当前内存空间，它的参数是一个指向由malloc等函数开辟的内存空间的首地址的指针。</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>内存泄漏是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<ul>
<li>判断是否存在内存泄漏可以通过稳定性测试来进行，让被测试逻辑重复执行几十万次，记录开始运行时占用的内存数，再记录结束时占用的内存数。</li>
<li>如果程序中存在内存泄漏，可以使用一些内存泄漏检测工具，或者根据以往经验推测，也可以通过二分法查找问题</li>
</ul>
<p>在使用malloc等内存管理函数时，务必记得使用free函数释放掉所申请的内存，即使有的程序不需要释放内存或者不释放内存也不会造成内存泄漏。我们需要养成良好的习惯，这样能大大减少问题发生的概率。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>（C++）类的六大默认成员函数</title>
    <url>/2020/05/20200524.html</url>
    <content><![CDATA[<h1 id="类的-6-个默认成员函数"><a href="#类的-6-个默认成员函数" class="headerlink" title="类的 6 个默认成员函数"></a>类的 6 个默认成员函数</h1><p>初始化和清理：</p>
<ol>
<li>构造函数主要完成初始化工作</li>
<li>析构函数主要完成清理工作</li>
</ol>
<p>拷贝复制：</p>
<ol>
<li>拷贝构造是使用同类对象初始化创建对象</li>
<li>复制重载主要是把一个对象赋值给另一个对象</li>
</ol>
<p>取地址重载：</p>
<p> 主要是普通对象和const对象取地址，这两个很少会自己实现</p>
<span id="more"></span>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数：函数名和类型名相同，无返回值，可以重载，编译器在创建时自动调用</p>
<p>默认构造：</p>
<ol>
<li>编译器默认生成</li>
<li>显示定义的无参构造</li>
<li>全缺省构造函数（常用）</li>
</ol>
<p>一旦显示定义构造函数，编译器不会再自动生成了，只有当类没有定义任何构造函数时，编译器才会自动生成一个无参构造</p>
<blockquote>
<p>如果类中存在自定义成员，则构造函数会自动调用自定义成员的<strong>默认构造</strong>，完成自定义成员的初始化</p>
<p>如果自定义成员没有默认构造函数（无参构造或全缺省构造或自动生成的无参构造），则会产生编译错误</p>
</blockquote>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>与构造函数功能相反，对象在销毁时会自动调用析构函数，完成类的一些资源清理工作，free，打开的文件等（不是完成对象的销毁）</p>
<p>清理资源，不是销毁对象，在对象生命周期结束时，编译器自动调用，如果没有资源需要清理，可以不用显式的写析构函数，直接用编译器默认生成的</p>
<blockquote>
<p>~函数名（）</p>
</blockquote>
<ol>
<li>无参数无返回值</li>
<li>一个类有且只有一个析构函数，若未定义，系统会自动生成默认的析构函数</li>
<li>对象生命周期结束时，C++编译系统自动调用析构函数</li>
<li>如果类中存在自定义成员，则类在销毁时会调用它的析构函数，完成自定义类型的类的资源清理工作</li>
</ol>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>构造函数的一种重载形式，也是在创建对象时自动调用</p>
<blockquote>
<p>调用场景：用一个已经存在的对象去创建一个新的对象，创建的新对象和当前内容相同</p>
<ol>
<li>拷贝构造是构造函数的一个重载形式</li>
<li>拷贝构造函数的参数只有一个且必须使用<strong>引用传参（可以加const）</strong>，_使用传值方式会引发无穷递归调用_</li>
<li>若没有显式的定义，系统生成默认的拷贝函数，为浅拷贝，或者值拷贝（只拷贝对象模型的内容，不拷贝资源）</li>
</ol>
</blockquote>
<p><strong>匿名对象具有常性，在引用时需要加const</strong></p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>增强代码可读性。</p>
<p>函数名字：关键字<strong>operator后面接需要重载的运算符符号</strong></p>
<p>函数原型：返回值类型 operator操作符（参数列表）</p>
<h2 id="普通运算符重载函数"><a href="#普通运算符重载函数" class="headerlink" title="普通运算符重载函数"></a>普通运算符重载函数</h2><blockquote>
<ol>
<li>不能创建新的操作符，如operator\@</li>
<li>重载操作符必须有一个类类型或者枚举类型的操作符</li>
<li>用于内置类型的操作符，其含义不能改变</li>
<li>运算符重载函数如果是成员函数，则参数的个数比运算符需要的个数少一个，这里编译器会传入this指针作为第一个参数</li>
<li>普通的运算符重载函数，参数的个数和运算符需要的个数一致</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> Date&amp; d1, <span class="type">const</span> Date&amp; d2)</span><br><span class="line">&#123;</span><br><span class="line">	rerurn d1._year == d2._year</span><br><span class="line">    &amp;&amp; d1._month == d1._month</span><br><span class="line">    &amp;&amp; d1._day == d2._day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> Date&amp; d)<span class="comment">//成员函数</span></span><br><span class="line">&#123;</span><br><span class="line">	rerurn _year == d._year</span><br><span class="line">    &amp;&amp; _month == d._month</span><br><span class="line">    &amp;&amp; _day == d._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符重载函数"><a href="#赋值运算符重载函数" class="headerlink" title="赋值运算符重载函数"></a>赋值运算符重载函数</h2><p>用一个对象修改已经存在对象的内容，不是去创建新的对象，修改之后，两个对象的内容一致</p>
<blockquote>
<ol>
<li>可以通过检查是否给自己赋值，进行优化</li>
<li>如果需要连续赋值，返回值不能是void，一般为引用类型</li>
<li>返回值一般是 *this</li>
<li>编译器默认生成的赋值运算符为字节拷贝，即浅拷贝，如果资源需要拷贝，需要显示定义，完成深拷贝</li>
</ol>
<p>\=调用：如果对象都存在，调用赋值运算符重载函数</p>
<p> 如果左边对象不存在，调用拷贝构造创建左边对象</p>
</blockquote>
<p>_赋值是从右向左进行的_</p>
<p>如果不写，编译器会自动生成，默认生成的也是字节拷贝，浅拷贝</p>
<p>如果当前类中有资源，则必须显示定义运算符重载函数，完成深拷贝</p>
<p>通过一个int参数来区分前后缀运算符，有int为后缀，反之为前缀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)<span class="comment">//判断是不是在给自身赋值</span></span><br><span class="line">  &#123;</span><br><span class="line">    _year = d._year;</span><br><span class="line">    _month = d._month;</span><br><span class="line">    _day = d._day;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; d)<span class="comment">//此时可以连续赋值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)<span class="comment">//判断是不是在给自身赋值</span></span><br><span class="line">  &#123;</span><br><span class="line">    _year = d._year;</span><br><span class="line">    _month = d._month;</span><br><span class="line">    _day = d._day;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>.*（成员指针访问运算符） , :: , sizeof , \? : , . 五个运算符不能被重载</strong></p>
<h1 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h1><p>const 修饰类的成员函数</p>
<blockquote>
<p>成员函数 + const</p>
</blockquote>
<p>将const修饰的类成员函数称为const修饰类成员函数，<strong>实际修饰该成员函数隐含的this指针</strong>，表明在该成员函数中，<strong>不能</strong>对类的<strong>任何成员</strong>进行<strong>修改</strong></p>
<p>非const对象（即可读可写）调用非const成员函数，也可以调用const成员函数，原因：读写权限没有被放大</p>
<p>const对象（只读）调用const成员函数，不能调用非const成员函数，原因：读写权限不能被放大</p>
<ol>
<li>非const对象可以调用非const成员函数，也可以调用const成员函数</li>
<li>const只能调用const成员函数</li>
<li>非const成员函数既可以调用非const成员函数，也可以调用const成员函数</li>
<li>const成员函数只能调用const成员函数</li>
<li>原则：只要不放大读写权限，就可以调用，缩小读写权限是被允许的</li>
<li>非成员函数不能用const修饰，因为非成员函数没有this指针</li>
</ol>
<blockquote>
<p>非const成员函数：函数() —&gt; 底层接口 —&gt; 函数(类类型* const this) —&gt;this指向不变</p>
<p>const成员函数：函数()const —&gt; 底层接口 —&gt;函数(const 类类型* const this) —&gt;this指向不变，且指向的内存中的内容也不变</p>
</blockquote>
<h1 id="取地址及const取地址操作符重载"><a href="#取地址及const取地址操作符重载" class="headerlink" title="取地址及const取地址操作符重载"></a>取地址及const取地址操作符重载</h1><p>一般不用重新定义，编译器默认会生成</p>
<blockquote>
<p>类类型 operator\&amp;（）</p>
<p>\{</p>
<p> return this;</p>
<p>\}</p>
<p>const 类类型 operator\&amp; （） const</p>
<p>\{</p>
<p> return this;</p>
<p>\}</p>
</blockquote>
<p>特殊情况下，才需要重载，比如：想让别人获取到指定的内容</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1. 构造函数：在已有的空间上初始化对象成员变量</strong></p>
<ol>
<li>如果没有定义，编译器自动生成，如果定义了任何一个构造函数，编译器不再自动生成</li>
<li>支持重载</li>
<li>默认构造函数：无参构造，全缺省构造，编译器自动生成的，三者之能存在一个</li>
<li>创建对象时自动调用</li>
<li>如果有自定义成员，构造函数自动调用自定义成员的默认构造，如果自定义成员没有默认构造，编译不通过</li>
</ol>
<p><strong>2.析构函数：对象销毁之前，清理对象的资源，不是销毁对象</strong></p>
<ol>
<li>如果没有定义，编译器自动生成</li>
<li>不支持重载，只能有一个</li>
<li>对象生命周期结束时，编译器会自动调用</li>
<li>如果有自定义成员，析构函数会自动调用自定义成员的析构函数，完成自定义成员的资源清理</li>
</ol>
<p><strong>3.拷贝构造函数：用一个对象创建一个内容完全一样的新对象</strong></p>
<ol>
<li>其属于构造函数的一种重载形式，如果没有定义，编译器会自动生成</li>
<li>拷贝构造函数的参数必须为引用，不能为值，否则会引发无穷递归</li>
<li>编译器自动生成的拷贝构造完成的是字节拷贝，即浅拷贝，只拷贝对象模型中的成员，不拷贝资源</li>
<li>如果类中有资源，则需要显示定义拷贝构造，完成深拷贝</li>
</ol>
<p><strong>4.赋值运算符重载函数：用一个对象修改已存在对象的内容，让其内容一致</strong></p>
<ol>
<li>如果没有定义，编译器自动存生成</li>
<li>如果需要连续赋值，一般函数的返回类型为当前类类型的引用</li>
<li>可以通过if(this ！= \&amp;对象)来判断是否给自己赋值</li>
<li>返回值一般为 *this</li>
<li>编译器自动生成的赋值重载函数完成字节拷贝，即浅拷贝，只拷贝对象模型中的成员，不拷贝资源</li>
<li>如果类中有资源，则需要显示定义拷贝构造，完成深拷贝</li>
</ol>
<p><strong>5.取地址运算符重载函数 / const取地址运算符重载函数：获取对象的地址</strong></p>
<ol>
<li>一般不需要显示定义，直接使用编译器自动生成的即可</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
</search>
