<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小赵的学习笔记</title>
  
  
  <link href="http://zhaozhuolin.com/atom.xml" rel="self"/>
  
  <link href="http://zhaozhuolin.com/"/>
  <updated>2024-05-25T03:47:44.550Z</updated>
  <id>http://zhaozhuolin.com/</id>
  
  <author>
    <name>Latsummer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在MIPS及LoongArch的架构下编译go语言二进制</title>
    <link href="http://zhaozhuolin.com/2024/05/20240520.html"/>
    <id>http://zhaozhuolin.com/2024/05/20240520.html</id>
    <published>2024-05-20T01:47:50.000Z</published>
    <updated>2024-05-25T03:47:44.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在MIPS及LoongArch的架构下编译go语言二进制"><a href="#在MIPS及LoongArch的架构下编译go语言二进制" class="headerlink" title="在MIPS及LoongArch的架构下编译go语言二进制"></a>在<code>MIPS</code>及<code>LoongArch</code>的架构下编译go语言二进制</h1><h3 id="首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境"><a href="#首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境" class="headerlink" title="首先需要找到一个已经安装go的机器, 可以是X86或ARM等任何可以执行go的环境"></a>首先需要找到一个已经安装go的机器, 可以是<code>X86</code>或<code>ARM</code>等任何可以执行go的环境</h3><p>其次准备好go源码</p><p>接着进行如下操作</p><ol><li><p>解压go源码</p></li><li><p>设定环境变量 <code>GOROOT_BOOTSTRAP</code>/<code>GOOS</code>/<code>GOARCH</code><br> 其中 <code>GOROOT_BOOTSTRAP</code> 为当前可以执行 go 文件的安装目录, 例如当前环境的 go 可执行文件为<code>/usr/local/go/bin/go</code>, 则 <code>GOROOT_BOOTSTRAP</code> 应设置为 <code>/usr/local/go</code><br> <code>GOOS</code> 为目标环境系统<br> <code>GOARCH</code> 为目标架构<br> 关于 <code>GOOS</code> 以及 <code>GOARCH</code>, 可以使用命令, go tool dist list 查看, 版本越高的go支持的越多</p> <span id="more"></span></li><li><p><img src="/2024/05/20240520/image-20240416195706201.png" alt="image-20240416195706201"></p></li><li><p>设定好环境变量后, 进入源码目录下的<code>src</code>目录, 执行脚本 <code>bootstrap.bash</code></p></li></ol><p>​    <img src="/2024/05/20240520/image-20240416195943599.png" alt="image-20240416195943599">    </p><ol><li><p>等待脚本执行完毕, 会在<code>src</code>目录的上层的上层目录 即 <code>../../</code> 目录 (脚本最后一般会输出文件路径)下生成 一个<code>tbz</code>文件, 将此文件拷贝至目标机器, 并解压</p></li><li><p>解压后, 进入 <code>$&#123;解压后的目录&#125;/bin</code> , 此时应该存在 <code>go</code>,  <code>gofmt</code> 两个二进制文件, 执行以下 <code>./go version</code> , 看看能否正常运行</p><ol><li><p>这里在<code>loongarrch</code>架构碰到一个问题, 执行后出现 段错误</p><p> <img src="/2024/05/20240520/image-20240416200939524.png" alt="image-20240416200939524"></p></li><li><p><code>gdb</code>了一下发现是在编译的时候似乎把依赖路径硬编码进去了(也可能是没有设置好环境变量)</p></li><li><p>将解压后的文件放到与编译时的文件同一个路径即可</p></li></ol></li></ol><ol><li><p>在目标机器设定环境变量, <code>GOROOT_BOOTSTRAP</code> , <code>GOROOT</code>, 将源码文件解压到任何你想解压到的地方, 其中</p><ol><li><p><code>GOROOT_BOOTSTRAP</code> 为之前编译出来的<code>tbz</code>文件的解压路径</p></li><li><p><code>GOROOT</code> 为解压后的go源码文件路径</p></li></ol></li><li><p>进入 <code>$GOROOT/scr</code>, 执行 <code>./all.bash</code>, 此步骤耗时较久, 会测试一些东西</p></li><li><p>执行完毕后, <code>$GOROOT</code>目录即会多出一个bin目录, 此时将整个<code>$GOROOT</code>目录挪到任何你想挪到的地方, 并将 <code>$GOROOT/bin</code> 添加到环境变量即可</p></li></ol><h3 id="如果在进行测试时失败-可以看一下有没有超时-测试项完成后会显示使用时间-默认为3分钟-类似下图"><a href="#如果在进行测试时失败-可以看一下有没有超时-测试项完成后会显示使用时间-默认为3分钟-类似下图" class="headerlink" title="如果在进行测试时失败, 可以看一下有没有超时, 测试项完成后会显示使用时间, 默认为3分钟, 类似下图"></a>如果在进行测试时失败, 可以看一下有没有超时, 测试项完成后会显示使用时间, 默认为3分钟, 类似下图</h3><p><img src="/2024/05/20240520/image2023-2-17_11-24-37.png" alt="image2023-2-17_11-24-37"></p><p>解决方式是设定环境变量 <code>GO_TEST_TIMEOUT_SCALE</code> = 2, 这会将超时时间倍乘二, 变为 6 分钟</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;在MIPS及LoongArch的架构下编译go语言二进制&quot;&gt;&lt;a href=&quot;#在MIPS及LoongArch的架构下编译go语言二进制&quot; class=&quot;headerlink&quot; title=&quot;在MIPS及LoongArch的架构下编译go语言二进制&quot;&gt;&lt;/a&gt;在&lt;code&gt;MIPS&lt;/code&gt;及&lt;code&gt;LoongArch&lt;/code&gt;的架构下编译go语言二进制&lt;/h1&gt;&lt;h3 id=&quot;首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境&quot;&gt;&lt;a href=&quot;#首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境&quot; class=&quot;headerlink&quot; title=&quot;首先需要找到一个已经安装go的机器, 可以是X86或ARM等任何可以执行go的环境&quot;&gt;&lt;/a&gt;首先需要找到一个已经安装go的机器, 可以是&lt;code&gt;X86&lt;/code&gt;或&lt;code&gt;ARM&lt;/code&gt;等任何可以执行go的环境&lt;/h3&gt;&lt;p&gt;其次准备好go源码&lt;/p&gt;
&lt;p&gt;接着进行如下操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解压go源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设定环境变量 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt;/&lt;code&gt;GOOS&lt;/code&gt;/&lt;code&gt;GOARCH&lt;/code&gt;&lt;br&gt; 其中 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 为当前可以执行 go 文件的安装目录, 例如当前环境的 go 可执行文件为&lt;code&gt;/usr/local/go/bin/go&lt;/code&gt;, 则 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 应设置为 &lt;code&gt;/usr/local/go&lt;/code&gt;&lt;br&gt; &lt;code&gt;GOOS&lt;/code&gt; 为目标环境系统&lt;br&gt; &lt;code&gt;GOARCH&lt;/code&gt; 为目标架构&lt;br&gt; 关于 &lt;code&gt;GOOS&lt;/code&gt; 以及 &lt;code&gt;GOARCH&lt;/code&gt;, 可以使用命令, go tool dist list 查看, 版本越高的go支持的越多&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信创系统-凝思606替换GLIBC库以运行QT的可行性调查</title>
    <link href="http://zhaozhuolin.com/2024/05/20240518.html"/>
    <id>http://zhaozhuolin.com/2024/05/20240518.html</id>
    <published>2024-05-18T01:47:50.000Z</published>
    <updated>2024-05-25T03:28:46.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信创系统-凝思606替换GLIBC库以运行QT的可行性调查"><a href="#信创系统-凝思606替换GLIBC库以运行QT的可行性调查" class="headerlink" title="信创系统-凝思606替换GLIBC库以运行QT的可行性调查"></a>信创系统-凝思606替换GLIBC库以运行QT的可行性调查</h1><ol><li><p>安装CentOS7编译的带UI的QT程序，其中systemctl相关服务已被替换为service</p><p> 由于606系统libc.so.6版本过低，无法正常运行</p></li><li><p>尝试替换其他高版本的libc.so至本地的lib目录，同时替换其依赖</p><p> <img src="/2024/05/20240518/image-20240508143943090.png" alt="image-20240508143943090"></p><p> <img src="/2024/05/20240518/image-20240508143957295-17151504030681.png" alt="image-20240508143957295"></p> <span id="more"></span></li><li><p>替换完成后，碰到一些系统命令调用的问题，由于eps_service脚本会指定LD_LIBRARY_PATH，所以在该脚本中执行的系统调用命令会优先使用刚在替换的库，先在尝试将这些命令也替换为高版本gcc编译出的可执行文件，为了避免造成系统出错，这里将脚本中的系统命令换位执行本地目录的命令</p><ol><li><p>替换/增加的文件有</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span>、ln、sleep、pidof、mkdir、dirname</span><br><span class="line"><span class="attribute">ld</span>-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> -&gt; ld-<span class="number">2</span>.<span class="number">17</span>.so</span><br><span class="line"><span class="attribute">libtinfo</span>.so.<span class="number">5</span> -&gt; libtinfo.so.<span class="number">5</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">libgcc_s</span>.so.<span class="number">1</span> -&gt; libgcc_s-<span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span>-<span class="number">20150702</span>.so.<span class="number">1</span></span><br><span class="line"><span class="attribute">libm</span>.so.<span class="number">6</span> -&gt; libm-<span class="number">2</span>.<span class="number">17</span>.so</span><br><span class="line"><span class="attribute">libstdc</span>++.so.<span class="number">6</span> -&gt; libstdc++.so.<span class="number">6</span>.<span class="number">0</span>.<span class="number">19</span></span><br><span class="line"><span class="attribute">libc</span>.so.<span class="number">6</span> -&gt; libc-<span class="number">2</span>.<span class="number">17</span>.so</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol><li><p>替换这些文件后， 报错信息仍然如下</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relocation error: /opt/apps/xxx/lib/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference</span><br></pre></td></tr></table></figure></li><li><p>经查阅(<a href="https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host">https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host</a>)</p><p> <code>ld-linux-x86-64.so.2</code>所指向的ld-2.17.so是一个链接器，他是可执行的，并且可执行文件所需要的链接器路径是写死在文件头信息中的，可通过工具<code>patchelf</code>来修改文件头部信息，命令如下</p><p> <code>patchelf --set-interpreter $&#123;从别处拷贝的链接器(ld-linux-x86-64.so.2)&#125; --set-rpath $&#123;自己的lib目录&#125; $&#123;文件名&#125;</code></p><p> 例如<code>patchelf --set-interpreter /opt/apps/xxx/lib/ld-linux-x86-64.so.2 --set-rpath /opt/apps/xxx/lib/ /opt/apps/xxx/bin/bash</code></p><p> 同时，也可直接使用<code>ld-linux-x86-64.so.2</code>文件本身来单次指定链接器，<strong>仅当次生效</strong>，这在设置了<code>LD_LIBRARY_PATH</code>后想要执行系统自身命令，如想要使用gdb看看情况时==非常有用==。可以用低版本系统本身的<code>ld-linux-x86-64.so.2</code>指向系统本身的库，如下</p><p> <code>/lib64/ld-linux-x86-64.so.2 --library-path /lib64 /usr/bin/gdb ./edr_monitor</code></p></li><li><p>当做完这些后，发现仍然无法启动程序，启动报段错误，使用<code>/lib64/ld-linux-x86-64.so.2 --library-path /lib64 /usr/bin/gdb ./app</code>调试，未能发现其他问题，而==导入环境变量后直接执行程序会段错误==</p></li></ol><h2 id="改变思路"><a href="#改变思路" class="headerlink" title="改变思路"></a>改变思路</h2><ol><li><p>在凝思606上安装gcc4.8.5编译器</p> <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -<span class="keyword">enable</span>-checking=<span class="keyword">release</span> -<span class="keyword">enable</span>-languages=c,c++ -<span class="keyword">disable</span>-multilib</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>编译QT5.9.8</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -<span class="keyword">confirm</span>-license -opensource -release -prefix <span class="string">&quot;/tmp/qt&quot;</span> -nomake tests -nomake examples -<span class="keyword">no</span>-compile-examples -qt-xcb -<span class="keyword">no</span>-openssl -skip webengine -skip tools -skip <span class="number">3</span>d -skip gamepad -skip multimedia -skip doc -skip location -skip sensors -skip androidextras -<span class="keyword">c</span>++std <span class="keyword">c</span>++<span class="number">11</span> -<span class="keyword">no</span>-static -<span class="keyword">no</span>-use-gold-linker -<span class="keyword">no</span>-glib -<span class="keyword">no</span>-<span class="built_in">iconv</span> -<span class="keyword">no</span>-icu -qt-freetype -qt-harfbuzz -<span class="keyword">no</span>-fontconfig -<span class="keyword">no</span>-xkbcommon-evdev -<span class="keyword">no</span>-gtk -qt-libjpeg -qt-libpng -<span class="keyword">no</span>-libinput -<span class="keyword">no</span>-cups -dbus-<span class="keyword">runtime</span> -<span class="keyword">no</span>-eglfs -skip wayland -optimize-size -skip serialport -skip virtualkeyboard -skip connectivity -skip activeqt -<span class="keyword">no</span>-avx2</span><br></pre></td></tr></table></figure><p> 其中<code>-no-avx2</code>这个参数很重要, <strong>指定编译用的CPU指令集不包含avx2</strong>, qt的configure在这个环境下无法自动检测, 会造成一些编译错误, 例如下图</p><p> <img src="/2024/05/20240518/image-20240508144334144.png" alt="image-20240508144334144"></p></li><li><p>编译代码(部分三方库需要重编, 因为glibc库此时还是低版本的)</p></li><li><p>此时编译出来的终端除了ui外其他都可以正常运行, 经排查, 是系统libstdc++.so版本问题, 尝试将高版本库放入终端lib目录</p></li><li><p>引入高版本libstdc++.so此时UI程序报 段错误，经排查，是由于其中一个list进行push_back操作导致</p><p> <img src="/2024/05/20240518/image-20240508144424382.png" alt="image-20240508144424382"></p><p> 虽然不能找出具体原因，但是替换为vector后即可正常使用</p></li><li><p>此时QT的画笔模块出现问题</p><p> <img src="/2024/05/20240518/image-20240508144450629.png" alt="image-20240508144450629"></p></li><li><p>对比了可以正常运行版本的依赖，发现依赖数量相差九个</p><p> <img src="/2024/05/20240518/image-20240508144503912.png" alt="image-20240508144503912"></p></li><li><p>经排查多出来的为libGL.so的依赖，属于OpenGL库，遂安装mesa-10.1.0，此时安装后，依赖数量仍差两个，此时UI仍然无法正常启动，问题同之前，通过gdb调试得到其崩溃是因为QT库的问题，程序异常退出并存在信号SIGFPE</p></li><li><p>编译debug版本的QT，重新编译UI准备调试，此时托盘图标页无法弹出，通过gdb运行发现有信号SIGABRT，经过追踪，确定问题出在加载托盘图标，实例化QIcon这一步，其中有一个函数获取系统不透明度格式时返回了非法值，触发了接下来的一个assert，从而导致出现问题，通过将QT源码改写，将原来出问题的函数中的连续三次指针调用成员函数改为分三句执行，发现最重要的第三步无法跟进去，同时gdb报<code>RTTI symobl not found for class &#39;QXcbScreen&#39;</code>，怀疑其和QXcbScreen这个类有关，同时也在该类中找到了同名函数format</p></li></ol><p><img src="/2024/05/20240518/image-20240508144536501.png" alt="image-20240508144536501"></p><p><img src="/2024/05/20240518/image-20240508144549717.png" alt="image-20240508144549717"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;信创系统-凝思606替换GLIBC库以运行QT的可行性调查&quot;&gt;&lt;a href=&quot;#信创系统-凝思606替换GLIBC库以运行QT的可行性调查&quot; class=&quot;headerlink&quot; title=&quot;信创系统-凝思606替换GLIBC库以运行QT的可行性调查&quot;&gt;&lt;/a&gt;信创系统-凝思606替换GLIBC库以运行QT的可行性调查&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装CentOS7编译的带UI的QT程序，其中systemctl相关服务已被替换为service&lt;/p&gt;
&lt;p&gt; 由于606系统libc.so.6版本过低，无法正常运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试替换其他高版本的libc.so至本地的lib目录，同时替换其依赖&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/2024/05/20240518/image-20240508143943090.png&quot; alt=&quot;image-20240508143943090&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/2024/05/20240518/image-20240508143957295-17151504030681.png&quot; alt=&quot;image-20240508143957295&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Rust-枚举与模式匹配</title>
    <link href="http://zhaozhuolin.com/2023/05/20230512.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230512.html</id>
    <published>2023-05-12T01:47:50.000Z</published>
    <updated>2024-05-25T03:28:46.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>结构体将字段与数据聚合，而枚举可以将同一类型的东西（同时你可以将它可能的情况列举出来）作为一个集合，使用IP地址举例如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">v4,</span><br><span class="line">v6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>可使用<code>::</code>访问枚举值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ipv4</span> = IpAddrKind::v4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ipv6</span> = IpAddrKind::v6;</span><br></pre></td></tr></table></figure><p>也可将其传入函数，如<code>func(IpAddrKind::v4)</code></p><span id="more"></span><p>也可结合结构体使用如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可直接指定枚举值类型如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><p>此时，<code>IpAddr::V4()</code>实际上为一个获取<code>String</code>参数并返回<code>IpAddr</code>类型示例的函数调用，而这些构造函数会被自动定义，枚举可以为每个值指定不同的数据类型，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>可以将任意类型的数据放入枚举成员中，例如字符串，数字或者结构体，甚至可以嵌套枚举</p></blockquote><p>以下为一个多种成员类型的枚举类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该枚举类型有四个成员，分别为：</p><ul><li><code>Quit</code> 没有关联任何数据。</li><li><code>Move</code> 类似结构体包含命名字段。</li><li><code>Write</code> 包含单独一个 <code>String</code>。</li><li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li></ul><p>如果使用结构体的话，他将会是这样，如果不能使用枚举类型的话，使用结构体需要定义四个不同的结构体类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QuitMessage</span>; <span class="comment">// 类单元结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MoveMessage</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteMessage</span>(<span class="type">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChangeColorMessage</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></table></figure><p>枚举同结构体一样可以使用<code>impl</code>来定义方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure><h2 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a><code>Option</code>枚举</h2><p><code>Option</code>是标准库定义的另一个枚举，这个枚举可以表示一个空值，Rust没有<code>nil</code>，<code>nullptr</code>，<code>NULL</code>那样的空值，取而代之为如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="literal">None</span>,</span><br><span class="line"><span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以不使用<code>Option::</code>前缀来直接使用<code>Some</code>与<code>None</code>，但即便如此<code>Option&lt;T&gt;</code>也是常规的枚举， <code>Some&lt;T&gt;</code>与<code>None</code>是其成员，以下是一些例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_num</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure><p>在上述例子中，<code>some_num</code>的类型是<code>Option&lt;i32&gt;</code>，<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>，对于<code>absent_num</code>则通过<code>: Option&lt;i32&gt;</code>显示的指明其类型</p><p>当有一个<code>Some</code>值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。这样做会比空值更好，因为<code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = x + y; <span class="comment">//这两个值不能相加，因为不是同一个类型</span></span><br></pre></td></tr></table></figure><h1 id="match控制流"><a href="#match控制流" class="headerlink" title="match控制流"></a><code>match</code>控制流</h1><p>允许讲一个值与一系列的模式相比较，并根据与相匹配的模式执行相应的代码。模式可以由字面值、变量以及通配符等其他内容构成，以下为一个案例，利用<code>match</code>语法获取对应衣服尺码的袖长</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ClothingSize</span> &#123;</span><br><span class="line">    Size_XS,</span><br><span class="line">    Szie_S,</span><br><span class="line">    Size_M,</span><br><span class="line">    Size_L,</span><br><span class="line">    Size_XL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_sleeve_len</span>(clothing_size: ClothingSize) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> clothing_size &#123;</span><br><span class="line">        ClothingSize::Size_XS =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;This is XS&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125; <span class="comment">//使用 &#123;&#125; 形式时 逗号可写可不写</span></span><br><span class="line">        ClothingSize::Szie_S =&gt; <span class="number">20</span>,</span><br><span class="line">        ClothingSize::Size_M =&gt; <span class="number">30</span>,</span><br><span class="line">        ClothingSize::Size_L =&gt; <span class="number">40</span>,</span><br><span class="line">        ClothingSize::Size_XL =&gt; <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h2><p>匹配分支的另一个功能是可以绑定匹配模式的部分值，这也就是如何从枚举成员中提取值的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    AAA,</span><br><span class="line">    BBB</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ClothingSize</span> &#123;</span><br><span class="line">    Size_XS,</span><br><span class="line">    Szie_S,</span><br><span class="line">    Size_M,</span><br><span class="line">    <span class="title function_ invoke__">Size_L</span>(Brand),</span><br><span class="line">    Size_XL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_sleeve_len</span>(clothing_size: ClothingSize) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> clothing_size &#123;</span><br><span class="line">        ClothingSize::Size_XS =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;This is XS&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125; <span class="comment">//使用 &#123;&#125; 形式时 逗号可写可不写</span></span><br><span class="line">        ClothingSize::Szie_S =&gt; <span class="number">20</span>,</span><br><span class="line">        ClothingSize::Size_M =&gt; <span class="number">30</span>,</span><br><span class="line">        ClothingSize::<span class="title function_ invoke__">Size_L</span>(brand) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;clothing brand is &#123;:?&#125;&quot;</span>, brand);</span><br><span class="line">            <span class="number">40</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ClothingSize::Size_XL =&gt; <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上场景中，调用<code>get_sleeve_len(ClothingSize::Size_L(Brand::AAA))</code>，传入函数内部的<code>clothing_size</code>遇到<code>ClothingSize::Size_L(brand)</code>会匹配上，接着就可以直接使用<code>AAA</code>这个值</p><h2 id="匹配Option-lt-T-gt"><a href="#匹配Option-lt-T-gt" class="headerlink" title="匹配Option&lt;T&gt;"></a>匹配<code>Option&lt;T&gt;</code></h2><p><code>Option&lt;T&gt;</code>也可以被用作<code>match</code>匹配，例如一个函数，接受一个类型为<code>Option&lt;T&gt;</code>的参数，如果其中有值，则将其加一，如果没有则不进行操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure><h2 id="匹配的穷尽性，通配模式与占位符"><a href="#匹配的穷尽性，通配模式与占位符" class="headerlink" title="匹配的穷尽性，通配模式与占位符_"></a>匹配的穷尽性，通配模式与占位符<code>_</code></h2><p>匹配需要列出所有的可能，所有可能出现的值都必须能匹配到，在<code>Rust</code>中可以使用通配模式与<code>_</code>占位符来实现穷尽例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">rand</span>();</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">deal_seven</span>(),</span><br><span class="line">    <span class="number">9</span> =&gt; <span class="title function_ invoke__">deal_nine</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">deal_other</span>(other),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_seven</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_nine</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_other</span>(num: <span class="type">u8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于前两个分支，匹配模式是字面值 <code>7</code> 和 <code>9</code>，最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 <code>other</code> 的一个变量。<code>other</code> 分支的代码通过将其传递给 <code>deal_other</code> 函数来使用这个变量。</p><blockquote><p>通配模式应该放在最后一位，因为<code>match</code>是按照分支顺序依次匹配的</p></blockquote><p>如果不想使用通配模式获取的值，使用<code>_</code>来替代，其可以匹配任意值而不绑定到该值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">rand</span>();</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">deal_seven</span>(),</span><br><span class="line">    <span class="number">9</span> =&gt; <span class="title function_ invoke__">deal_nine</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">deal_other</span>(),</span><br><span class="line">    <span class="comment">// 如果不想做任何事，可以使用以下写法，返回一个空的元组</span></span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_seven</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_nine</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_other</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="if-let简洁控制流"><a href="#if-let简洁控制流" class="headerlink" title="if let简洁控制流"></a><code>if let</code>简洁控制流</h1><p>如果有以下类似的逻辑</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅关心<code>Some</code>得值，其余不做任何操作，可使用<code>if let</code>来简写</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h1&gt;&lt;p&gt;结构体将字段与数据聚合，而枚举可以将同一类型的东西（同时你可以将它可能的情况列举出来）作为一个集合，使用IP地址举例如下&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;IpAddrKind&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	v4,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	v6,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;枚举值&quot;&gt;&lt;a href=&quot;#枚举值&quot; class=&quot;headerlink&quot; title=&quot;枚举值&quot;&gt;&lt;/a&gt;枚举值&lt;/h2&gt;&lt;p&gt;可使用&lt;code&gt;::&lt;/code&gt;访问枚举值&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;ipv4&lt;/span&gt; = IpAddrKind::v4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;ipv6&lt;/span&gt; = IpAddrKind::v6;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也可将其传入函数，如&lt;code&gt;func(IpAddrKind::v4)&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-结构体</title>
    <link href="http://zhaozhuolin.com/2023/05/20230509.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230509.html</id>
    <published>2023-05-09T07:20:20.000Z</published>
    <updated>2024-05-25T03:28:46.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体的定义与实例化"><a href="#结构体的定义与实例化" class="headerlink" title="结构体的定义与实例化"></a>结构体的定义与实例化</h1><p>举例如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">active: <span class="type">bool</span>,</span><br><span class="line">username: <span class="type">String</span>,</span><br><span class="line">email: <span class="type">String</span>,</span><br><span class="line">sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">active: <span class="literal">true</span>,</span><br><span class="line">username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;email@email.com&quot;</span>),</span><br><span class="line">sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//若要使用值，则同C/C++</span></span><br><span class="line"><span class="comment">//若要修改值，则示例需是可变的，如下</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user2</span> = User &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">user2.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><p>作为函数返回值如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果函数参数和字段名相同，则可以使用简化写法</strong>如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用结构体更新语法从其他实例创建"><a href="#使用结构体更新语法从其他实例创建" class="headerlink" title="使用结构体更新语法从其他实例创建"></a>使用结构体更新语法从其他实例创建</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    active: user1.active,</span><br><span class="line">    username: user1.username,</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可使用简化写法，使用<code>..</code>来指定剩余没有变化的值，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>..user1</code>必须放在最后</strong></p><blockquote><p>请注意，转移与克隆的规则在此处仍然适用，例如用<code>user1</code>的<code>username</code>与<code>email</code>字段更新<code>user2</code>之后，这两个字段被转移到<code>user2</code>中，其余值则拷贝了一份，此时<code>user1</code>不能再使用。</p><p>而如果<code>user2</code>的那两个字段使用<code>String::from()</code>来进行赋值，其余从<code>user1</code>更新，那二者都可使用</p></blockquote><h2 id="元组结构体-匿名结构体"><a href="#元组结构体-匿名结构体" class="headerlink" title="元组结构体/匿名结构体"></a>元组结构体/匿名结构体</h2><p>类似如下形式，使用时同元组，使用下标</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有字段名称的类单元结构体"><a href="#没有字段名称的类单元结构体" class="headerlink" title="没有字段名称的类单元结构体"></a>没有字段名称的类单元结构体</h2><p>即元组类型中的<code>unit</code>类型，类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。形式如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h2><p>在上面的示例中，<code>User</code>结构体中的字符串类型使用了<code>String</code>而非<code>&amp;str</code>，这是因为想要这个结构体拥有它所有的数据，由此，只要整个结构体是有效的，那其中的数据也一定有效。</p><p>也可以是结构体存储被其他对象拥有的数据的引用（切片类型），不过需要用上生命周期标识符。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的</p><h1 id="结构体的示例程序"><a href="#结构体的示例程序" class="headerlink" title="结构体的示例程序"></a>结构体的示例程序</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rectangle: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过派生trait增加实用功能"><a href="#通过派生trait增加实用功能" class="headerlink" title="通过派生trait增加实用功能"></a>通过派生<code>trait</code>增加实用功能</h2><p>在上面实现的结构体，无法直接通过<code>println!</code>，但可通过以下方式进行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">//定义外部属性</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">    dbg!(&amp;rect1); <span class="comment">//另一种方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法语句"><a href="#方法语句" class="headerlink" title="方法语句"></a>方法语句</h1><p>关键字为<code>impl</code>，<code>impl</code>块中所有内容都将与结构体类型相关联，如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数<code>area</code>中，<code>&amp;self</code>实际上是<code>self: &amp;self</code>的缩写，他会借用调用对象的值，而不获取他的所有权</p><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>所有在<code>impl</code>块中定义的函数被称为 <strong>关联函数</strong> （静态成员函数），因为其与<code>impl</code>后面命名的类型先关。可以定义不以<code>self</code>为第一参数的关联函数，因此他不是方法，不是方法的关联函数通常会被用作返回一个结构体新实例的构造函数，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sq</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>使用<code>::</code>来使用结构体的关联函数，<code>::</code>语法用于关联函数和模块创建的命名空间</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;结构体的定义与实例化&quot;&gt;&lt;a href=&quot;#结构体的定义与实例化&quot; class=&quot;headerlink&quot; title=&quot;结构体的定义与实例化&quot;&gt;&lt;/a&gt;结构体的定义与实例化&lt;/h1&gt;&lt;p&gt;举例如下&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;User&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	active: &lt;span class=&quot;type&quot;&gt;bool&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	username: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	email: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sign_in_count: &lt;span class=&quot;type&quot;&gt;u64&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例化如下&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;user1&lt;/span&gt; = User &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	active: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	username: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	email: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;email@email.com&amp;quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sign_in_count: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//若要使用值，则同C/C++&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//若要修改值，则示例需是可变的，如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;user2&lt;/span&gt; = User &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;user2.email = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-所有权、引用与Slice</title>
    <link href="http://zhaozhuolin.com/2023/05/20230508.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230508.html</id>
    <published>2023-05-08T12:12:50.000Z</published>
    <updated>2024-05-25T03:28:46.299Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 通过所有权系统管理内存，编译器在编译时会根据一系列规则进行检查，如果违反了这些规则，程序不能通过编译。在运行时，所有权系统的任何功能都不会减缓程序的运行</p><h1 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h1><blockquote><ol><li>Rust 中的每一个值都有一个<strong>所有者</strong></li><li>值在任意时刻有且仅有一个所有者</li><li>当所有者（变量）离开作用域，这个值将被丢弃</li></ol></blockquote><span id="more"></span><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>同C语言，以 Rust 中的<code>String</code>类型举例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量<code>str</code>离开作用域时，会自动调用一个名为<code>drop</code>的函数，类似C++中的<code>RAII</code></p><h2 id="变量与数据交互的方式：移动"><a href="#变量与数据交互的方式：移动" class="headerlink" title="变量与数据交互的方式：移动"></a>变量与数据交互的方式：移动</h2><p>对于以下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>其将5绑定到<code>x</code>，接着生成一个<code>x</code>的拷贝并绑定到<code>y</code>，两个变量都在栈上</p><p>而对于以下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p>变量<code>s1</code>实际内容是存放在堆中，<code>String</code>对象由指向字符串内容的指针，一个长度与一个容量组成，这一部分数据是在栈上的，此处的操作类似于C++11中的<code>std::move()</code>操作，将<code>s1</code>中长度与容量赋值给<code>s2</code>，将<code>s2</code>的指针指向<code>s1</code>所指向的字符串内容，在C++11中，<code>std::move()</code>这一操作一般是对将亡值使用，在Rust中并无这一限制，但是在Rust中一旦使用这样的<strong>移动</strong>，则移动前的变量将不再有效，不能使用，这样就避免了变量离开作用域时的多次释放导致的未定义行为</p><p>简单来说，以上的操作是直接将<code>s1</code>认定为将亡值并使用移动语义将其内容转义到<code>s2</code>中</p><h2 id="变量与数据的交互方式：克隆"><a href="#变量与数据的交互方式：克隆" class="headerlink" title="变量与数据的交互方式：克隆"></a>变量与数据的交互方式：克隆</h2><p>如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure><p>类似C++中的拷贝构造</p><h3 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a>只在栈上的数据：拷贝</h3><p>如果数据本身大小已知，且整个存储在栈上，则在赋值时会进行拷贝操作，Rust 中存在一个 <code>Copy</code>traitde的特殊注解，可以用在类似整型这样存储在栈上的类型上，一个类型如果实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。同时，<strong>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。</strong>如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。</p><p>一下是一些实现了 <code>Copy</code> trait 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul><h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数与给变量赋值类似，可能会移动或赋值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">                                    <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处（没有调用drop析构）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure><h2 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h2><p>返回值也可以转移所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 转移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中，</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 会将</span></span><br><span class="line">                                             <span class="comment">// 返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域。</span></span><br><span class="line">    </span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string </span></span><br><span class="line">                                             <span class="comment">// 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用可以不获取所有权就可以使用值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tets&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">get_str_len</span>(&amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_str_len</span>(<span class="type">str</span>: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;s1</code>语法可以创建一个指向值<code>s1</code>的引用，但不拥有它，这种行为被称为<strong>借用，借用的变量不能进行修改</strong></p><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在增加了<code>mut</code>关键字后，可以对引用值进行修改，但需要注意的是，如果<strong>拥有一个对该变量的可变引用，那就不能再对该变量创建引用</strong>，不能同一时间多次将一个值作为可变变量借用，这样的限制可以避免数据竞争，数据竞争主要由以下三个行为造成：</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><p>当然，可以使用花括号来划分不同的作用域来实现同意值得多次借用，但在同一个作用域内，这样的行为不被允许。<strong>而可变引用与不可变引用也不能在同一个作用域中出现，但不可变引用可以在同一作用域出现多个</strong>，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p3</span> = &amp;<span class="keyword">mut</span> <span class="type">str</span>;<span class="comment">//有毛病</span></span><br></pre></td></tr></table></figure><p>不过，<strong>一个引用的作用域是从声明的地方到最后一次使用位置</strong>，所以可以进行如下改造</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p3</span> = &amp;<span class="keyword">mut</span> <span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p3);</span><br></pre></td></tr></table></figure><h2 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h2><p>我习惯称为野引用，指被借用的值的生命周期小于引用，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">str</span> = <span class="title function_ invoke__">get_str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_str</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效的。</li></ul><h1 id="Slice类型"><a href="#Slice类型" class="headerlink" title="Slice类型"></a>Slice类型</h1><p><code>slice</code>允许引用集合中一段连续的元素序列，而不是引用整个集合，它是一类引用，所以没有所有权。</p><p>现在假设一个场景，在一个以空格为分隔符的字符串中，找到第一个子串并返回，如果没有空格则返回其本身，在不使用<code>slice</code>的情况下，我们没有办法真正获取<strong>部分</strong>字符串，但可以返回索引，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s); <span class="comment">// word 的值为 5</span></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 这清空了字符串，使其等于 &quot;&quot;</span></span><br><span class="line">    <span class="comment">// word 在此处的值仍然是 5，</span></span><br><span class="line">    <span class="comment">// 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会引发一个问题，索引和字符串本身没什么关系，但凡字符串有改动，那么拿到的索引就会失效</p><h2 id="字符串slice"><a href="#字符串slice" class="headerlink" title="字符串slice"></a>字符串<code>slice</code></h2><p>字符串<code>slice</code>是<code>String</code>中一部分值的引用，写法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure><p>不同于<code>String</code>的引用，通过切片，将其分为了两个引用，分别是从第0个元素到第5个元素前，第6个元素到第11个元素前，形式为<code>[start_idx..end_idx]</code>，如果<code>start_idx</code>的值为0，那么也可以简写为<code>[..end_idx]</code>，如果<code>end_idx</code>的值为最后一个元素的位置，那么也可写作<code>[start_idx..]</code>，若要获取整个元素的切片，可以写作<code>[..]</code></p><p>现在，试着使用切片重写获取第一个子串的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误！</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行编译是，会发现<code>sclear()</code>会引发编译错误，这是因为<code>clear</code>想要清空字符串，需要获取一个可变的引用，而其下一句<code>println!</code>则使用了字符串中的不可变引用，rust中，可变引用和不可变引用不能同时存在，可变引用的最后一次使用应该位于不可变引用最后一次使用前</p><h2 id="字符串面值也是slice"><a href="#字符串面值也是slice" class="headerlink" title="字符串面值也是slice"></a>字符串面值也是<code>slice</code></h2><p>例如<code>let s = &quot;hello world&quot;;</code>此处<code>s</code>的类型是<code>&amp;str</code>，其是指向二进制程序特定位置的<code>slice</code>（静态区），所以<code>&amp;str</code>是一个不可变引用</p><h2 id="字符串slice做参数"><a href="#字符串slice做参数" class="headerlink" title="字符串slice做参数"></a>字符串<code>slice</code>做参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于以下函数定义</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line"><span class="comment">//也可写作</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>对第二种写法，如果有一个字符串<code>slice</code>，可以传递，如果有一个<code>String</code>，则可以传递整个<code>String</code>的引用或对<code>String</code>的引用，即这里会进行一次隐式类型转换，在使用时可如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// first_word 适用于String（的 slice），部分或全部</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line"><span class="comment">// first_word 也适用于 String 的引用，</span></span><br><span class="line"><span class="comment">// 这等价于整个 String 的 slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first_word 适用于字符串字面值，部分或全部</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为字符串字面值已经是字符串 slice 了，</span></span><br><span class="line"><span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br></pre></td></tr></table></figure><h2 id="其他类型slice"><a href="#其他类型slice" class="headerlink" title="其他类型slice"></a>其他类型<code>slice</code></h2><p>跟<code>string</code>差裘不多</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 通过所有权系统管理内存，编译器在编译时会根据一系列规则进行检查，如果违反了这些规则，程序不能通过编译。在运行时，所有权系统的任何功能都不会减缓程序的运行&lt;/p&gt;
&lt;h1 id=&quot;所有权规则&quot;&gt;&lt;a href=&quot;#所有权规则&quot; class=&quot;headerlink&quot; title=&quot;所有权规则&quot;&gt;&lt;/a&gt;所有权规则&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Rust 中的每一个值都有一个&lt;strong&gt;所有者&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;值在任意时刻有且仅有一个所有者&lt;/li&gt;
&lt;li&gt;当所有者（变量）离开作用域，这个值将被丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-变量、函数与控制流</title>
    <link href="http://zhaozhuolin.com/2023/05/20230507.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230507.html</id>
    <published>2023-05-07T11:20:01.000Z</published>
    <updated>2024-05-25T03:28:46.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-hello-world-开始"><a href="#从-hello-world-开始" class="headerlink" title="从 hello world 开始"></a>从 hello world 开始</h1><p>创建一个 <code>main.rs</code> 文件，写入以下内容</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用以下命令进行编译运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><ul><li>也可使用<code>Cargo</code>工具进行构建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo new  <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="comment">#这将会创建如下结构</span></span><br><span class="line"><span class="variable">$&#123;project_name&#125;</span></span><br><span class="line">src/main.rs</span><br><span class="line">Cargo.toml</span><br></pre></td></tr></table></figure><span id="more"></span><p>其中，<code>toml</code>文件内容如下</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;project_name&quot;</span> <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#项目版本</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#Rust版本，当前为2015 2018 2021，默认为2015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> <span class="comment">#依赖的包</span></span><br></pre></td></tr></table></figure><p>在 <code>src/main.rs</code> 中写入内容， 使用<code>cargo build/cargo build --release</code> 进行构建，编译产物将会放在<code>target/debug/$&#123;project_name&#125; or target/release/$&#123;project_name&#125;</code>下，也可使用<code>cargo run</code>直接编译运行，也可使用<code>cargo check</code>来进行编译检查</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>变量与可变性</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">//不可变</span></span><br><span class="line">x = <span class="number">6</span>; <span class="comment">//编译失败</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">6</span>; <span class="comment">//可变</span></span><br><span class="line">y = <span class="number">6</span>; <span class="comment">//正确的，没问题的</span></span><br></pre></td></tr></table></figure><ul><li>常量</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SOME_VALUE: <span class="type">u32</span> = <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>常量使用<code>const</code>关键字进行声明，常量可以在任何作用域中声明，并且声明常量时<strong>必须注明值的类型</strong></p><ul><li>隐藏</li></ul><p>当定义多个同名的变量时，只有之前的变量都会被最后一次定义的变量隐藏，直到最后一次定义的变量作用于结束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码，首先将<code>x</code>绑定到值<code>5</code>上， 接着通过<code>let x =</code>创建了新的变量<code>x</code>，获取初始值并加一，此时<code>x</code>的值变为<code>6</code>，接着在花括号创建的作用于内，<code>x</code>又被隐藏了一次，此时<code>x</code>的值为12，在作用于结束时，隐藏也结束了，<code>x</code>又变回6，因此以上程序输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.31s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure><p>隐藏实际上是创建了一个新的同名变量，可以改变变量值类型，并复用这个名字，而<code>mut</code>关键字无法做到这一点，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二次为数字类型，使用隐藏可以做到这一点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二句则尝试讲一个数字类型赋值给一个字符串类型的变量，此时编译会失败</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每一个值都属于某一个数据类型，这将高速Rust编译器它被指定为何种数据，一遍明确数据处理方式，存在两类数据源类型子集：<em>标量</em>与<em>复合</em></p><p>通常编译器可以自动推导数据类型，不过某些情况下需要显示的指定数据类型，例如数据类型可能有多种情况时，例如将字符串转为数字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number !&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>代表单独一个值，Rust中有四种基本标量类型：整形、浮点型、布尔型以及字符串类型</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>默认类型为<code>i32</code></p><div class="table-container"><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table></div><p>而对于数字面值，允许使用类型后缀，例如<code>64u8</code>为<code>u8</code>类型的64，也允许使用<code>_</code>下划线作为分隔符，例如<code>1_000</code>等价于<code>1000</code></p><div class="table-container"><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr><tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr><tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr><tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (单字节字符)(仅限于<code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table></div><blockquote><p>关于整型溢出，Debug模式下构建的二进制，在发生溢出时会panic，Release模式下构建的二进制会进行二进制补码操作，来绕回最小值，如256+1 = 0</p><p>对于整型溢出，可采用以下方式显示处理</p><ul><li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li><li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li><li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li><li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li></ul></blockquote><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p><code>f32</code>与<code>f64</code>，分别占32位于64位，默认为<code>f64</code>，浮点型数据都是有符号的</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br></pre></td></tr></table></figure><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>关键字为<code>char</code>，类型大小为4个字节，并代表了一个Unicode标量值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>可将多个值组合成一个类型，存在两种原生的复合类型：元组与数组</p><h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><p>将多个其他类型的值组合仅一个复合类型，元组长度固定，一旦声明，其长度不会变化</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当想从元组中获取单个值时， 可以使用模式匹配来结构元组值，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="comment">//创建了 x, y, z 来将 tup 分成了三个变量，</span></span><br></pre></td></tr></table></figure><p>也可使用<code>.</code>来进行访问，例如<code>tup.0</code>即为第一个值<code>500</code></p><p>不带任何值的元组有个特殊的名称，叫做 <strong>单元</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。<strong>如果表达式不返回任何其他值，则会隐式返回单元值。</strong></p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组中的每个元素类型必须相同，且数组的长度是固定的，数组在栈上分配空间</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">array2</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">//5个i32类型数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = [<span class="number">3</span>; <span class="number">5</span>];<span class="comment">//标识数组中有 5 个 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = array[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;number is &#123;one&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="函数与控制流"><a href="#函数与控制流" class="headerlink" title="函数与控制流"></a>函数与控制流</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用关键字<code>fun</code>声明，函数名与变量名使用Unix风格，小写字母，并使用下换线分割单词</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。</strong></p><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数必须声明参数类型，多个参数使用逗号分割</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><ul><li><strong>语句</strong> 执行一些操作但不返回值的指令，以分号结尾</li><li><strong>表达式</strong> 计算并产生一个值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>; <span class="comment">//语句不会返回任何值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = (<span class="keyword">let</span> <span class="variable">c</span> = <span class="number">2</span>);<span class="comment">//编译会失败 let c = 2 不会返回值</span></span><br></pre></td></tr></table></figure><p>在rust中，函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">1</span>;</span><br><span class="line">    b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时 a = 4</span></span><br></pre></td></tr></table></figure><h3 id="具有返回值的函数"><a href="#具有返回值的函数" class="headerlink" title="具有返回值的函数"></a>具有返回值的函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ret</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">ret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a><code>if</code>表达式</h3><p><strong><code>if</code>表达式使用的值必须为<code>bool</code>类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">5</span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &#123; <span class="comment">//不能这样使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>也可在<code>let</code>中使用，但是需要每个分支都必须是相同的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">flag</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="number">1</span>&#125;; <span class="comment">//可以</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num2</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;one&quot;</span>&#125; <span class="comment">//不行</span></span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h4><p>无条件的循环，可以使用<code>break</code>从循环跳出，同时可以返回一个值，也可以使用<code>continue</code>跳过循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;loopping !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> cnt * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res = 200</span></span><br></pre></td></tr></table></figure><p><code>break</code>和<code>continue</code>仅能控制当前的循环，对于嵌套的循环，可以配合标签一起使用来控制循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">&#x27;loop_start</span>&#x27;: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cnt = &#123;cnt&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;loop_start</span>&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;End cnt = &#123;cnt&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="while条件循环"><a href="#while条件循环" class="headerlink" title="while条件循环"></a><code>while</code>条件循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> num != <span class="number">0</span> &#123;</span><br><span class="line">num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for遍历集合"><a href="#for遍历集合" class="headerlink" title="for遍历集合"></a><code>for</code>遍历集合</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">one</span> <span class="keyword">in</span> a &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;one&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从-hello-world-开始&quot;&gt;&lt;a href=&quot;#从-hello-world-开始&quot; class=&quot;headerlink&quot; title=&quot;从 hello world 开始&quot;&gt;&lt;/a&gt;从 hello world 开始&lt;/h1&gt;&lt;p&gt;创建一个 &lt;code&gt;main.rs&lt;/code&gt; 文件，写入以下内容&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;使用以下命令进行编译运行&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rustc main.rs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello, world!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;也可使用&lt;code&gt;Cargo&lt;/code&gt;工具进行构建&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cargo new  &lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#这将会创建如下结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	src/main.rs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Cargo.toml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CMake语法小结</title>
    <link href="http://zhaozhuolin.com/2023/03/20230318.html"/>
    <id>http://zhaozhuolin.com/2023/03/20230318.html</id>
    <published>2023-03-18T12:55:09.000Z</published>
    <updated>2023-05-07T11:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h3><p><code>PROJECT(name)</code>指定工程名称， 默认支持所有语言</p><p><code>PROJECT(name CXX)</code>指定工程名称， 支持C++</p><p>会隐式定义两个变量</p><ul><li>${name}_BINARY_DIR</li><li>${name}_SOURCE_DIR</li></ul><p>修改工程名时会将这两个变量修改，可通过预定义两个变量<code>PROJECT_BINARY_DIR</code>以及<code>PROJECT_SOURCE_DIR</code>解决该问题</p><h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h3><p>设定值，<code>SET(SRC_LIST main.cpp a.cpp b.cpp)</code>，即设定了<code>SEC_LIST</code>的值</p><h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h3><p>输出自定义的信息，主要有三种</p><ul><li>SEND_ERROR，产生错误生成过程被跳过</li><li>STAUS，显示普通的消息</li><li>FATAL_ERROR，终止cmake过程</li></ul><span id="more"></span><h3 id="ADD-EXECUTABLE"><a href="#ADD-EXECUTABLE" class="headerlink" title="ADD_EXECUTABLE"></a>ADD_EXECUTABLE</h3><p>生成可执行文件<code>ADD_EXECUTABLE(target src)</code></p><h3 id="ADD-SUBDIRECTORY"><a href="#ADD-SUBDIRECTORY" class="headerlink" title="ADD_SUBDIRECTORY"></a>ADD_SUBDIRECTORY</h3><ul><li>添加存放源文件的子目录，并可指定中间二进制与目标二进制的存放位置</li><li><code>EXECULDE_FORM_ALL</code>可将参数从编译中排除</li><li><code>ADD_SUBDIRECTORY(src bin)</code><ul><li>将src目录加入工程并指定编译输出（包含中间结果）路径为bin目录</li><li>如果不进行 bin 目录指定， 那编译结果（包含中间文件）将会存放在指定的 执行cmake命令目录下的src</li></ul></li></ul><h3 id="关于更改二进制保存路径"><a href="#关于更改二进制保存路径" class="headerlink" title="关于更改二进制保存路径"></a>关于更改二进制保存路径</h3><ul><li><code>SET(EXECUTABLE_OUTPUT_PATH $(PROJECT_BINARY_DIR)/bin)</code></li><li><code>SET(LIBRARY_OUTPUT_PATH $(PROJECT_BINARY_DIR)/lib)</code></li></ul><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol><li>变量使用<code>$&#123;&#125;</code>取值，<strong>但在 IF 语句中直接使用变量名</strong></li><li>指令中的参数需使用<code>()</code>括起来，参数之间使用空格或分号分隔</li><li>指令大小写无关</li><li>如果参数中包含空格，则需要将参数使用双引号包括</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>INSTALL：安装指令，包括二进制，动态库，静态库以及文件，目录，脚本等</p><p>CMAKE_INSTALL_PREFIX：—prefix</p></blockquote><ul><li>安装文件：<code>INSTALL(FILES file1 file2 DESTINATION dst_dir)</code>，将<code>file1</code>以及<code>file2</code>安装到<code>dest_dir</code>中，其中<code>FILES</code>为文件，<code>DESTINATION</code>一般为：<ul><li>绝对路径</li><li>相对路径，即为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;DESTINATION&#125;</code>，<code>CMAKE_INSTALL_PREFIX</code>一般默认为<code>/usr/local/</code>，可使用<code>cmake -DCMAKE_INSTALL_PREFIX=/usr</code>指定该变量的值</li></ul></li><li>安装脚本：<code>INSTALL(PROGRAMS abc.sh bin)</code>，<code>PROGRAMS</code> 为非目标文件的可执行程序安装</li><li>安装目录：<ul><li>直接在需要安装的目录内创建CMakeList.txt，在其内写INSTALL file</li><li><code>INSTALL(DIRECTORY dir/ DESTINATION dst_dir)</code>：若为<code>dir/</code>则表示将<code>dir</code>目录下所有内容安装到<code>dst_dir</code>下，若为<code>dir</code>则表示将<code>dir</code>目录本身安装到<code>dst_dir</code></li></ul></li><li>安装库文件：<code>INSTALL(TARGET bin_name lib_name_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</code>，安装二进制，静态或动态库均需要使用<code>TARGET</code>，<code>ARCHIVE</code>特指静态库，<code>LIBRARY</code>特指动态库，<code>RUNTIME</code>特指可执行的目标二进制</li></ul><h2 id="构建静态库与动态库"><a href="#构建静态库与动态库" class="headerlink" title="构建静态库与动态库"></a>构建静态库与动态库</h2><p><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></p><ul><li>lib_name：库名称</li><li>SHARED：表示生成动态库，STATIC表示生成静态库</li><li>LIB_SRC：源文件</li></ul><blockquote><p>同时构建静态库与动态库的方式：</p><ol><li><p>使用两个名字，例如</p><ul><li><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></li><li><code>ADD_LIBRARY(lib_name_static STATIC $&#123;LIB_SRC&#125;)</code></li></ul></li><li><p>使用<code>SET_TARGET_PROPERTIES</code>，设置输出名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIB_NAME_SRC lib_src.cpp)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name_static STATIC <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">//重命名lib_name_static为lib_name</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">//在构建新的目标时，会尝试清理掉其他使用使用这个名称的库，例如构建lib_name.so时会清除掉lib_name.a</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name SHARED <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="动态库版本号设定"><a href="#动态库版本号设定" class="headerlink" title="动态库版本号设定"></a>动态库版本号设定</h3><p><code>SET_TARGET_PROPERTIES(lib_name PROPERTIES VERSION 1.2 SOVERSION 1)</code>，其中：</p><ul><li>VERSION：动态库版本</li><li>SOVERSION：API版本</li></ul><h2 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h2><p><code>INCLUDE_DIRECTORIES(head_path)</code>，指定头文件路径</p><p><code>LINK_DIRECTORIES(lib_path)</code>，指定库路径</p><p><code>TARGET_LINK_LIBRARIES(bin_name lib_name)</code>，指定二进制<code>lib_name</code>要链接的库文件</p><h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><ul><li><code>CMAKE_INCLUDE_PATH</code>，头文件路径</li><li><code>CMAKE_LIBRARY_PATH</code>，库文件路径</li><li><code>CMAKE_BUILD_TYPE</code>，release or debug等</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h1&gt;&lt;h2 id=&quot;关键字&quot;&gt;&lt;a href=&quot;#关键字&quot; class=&quot;headerlink&quot; title=&quot;关键字&quot;&gt;&lt;/a&gt;关键字&lt;/h2&gt;&lt;h3 id=&quot;PROJECT关键字&quot;&gt;&lt;a href=&quot;#PROJECT关键字&quot; class=&quot;headerlink&quot; title=&quot;PROJECT关键字&quot;&gt;&lt;/a&gt;PROJECT关键字&lt;/h3&gt;&lt;p&gt;&lt;code&gt;PROJECT(name)&lt;/code&gt;指定工程名称， 默认支持所有语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PROJECT(name CXX)&lt;/code&gt;指定工程名称， 支持C++&lt;/p&gt;
&lt;p&gt;会隐式定义两个变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${name}_BINARY_DIR&lt;/li&gt;
&lt;li&gt;${name}_SOURCE_DIR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改工程名时会将这两个变量修改，可通过预定义两个变量&lt;code&gt;PROJECT_BINARY_DIR&lt;/code&gt;以及&lt;code&gt;PROJECT_SOURCE_DIR&lt;/code&gt;解决该问题&lt;/p&gt;
&lt;h3 id=&quot;SET关键字&quot;&gt;&lt;a href=&quot;#SET关键字&quot; class=&quot;headerlink&quot; title=&quot;SET关键字&quot;&gt;&lt;/a&gt;SET关键字&lt;/h3&gt;&lt;p&gt;设定值，&lt;code&gt;SET(SRC_LIST main.cpp a.cpp b.cpp)&lt;/code&gt;，即设定了&lt;code&gt;SEC_LIST&lt;/code&gt;的值&lt;/p&gt;
&lt;h3 id=&quot;MESSAGE关键字&quot;&gt;&lt;a href=&quot;#MESSAGE关键字&quot; class=&quot;headerlink&quot; title=&quot;MESSAGE关键字&quot;&gt;&lt;/a&gt;MESSAGE关键字&lt;/h3&gt;&lt;p&gt;输出自定义的信息，主要有三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SEND_ERROR，产生错误生成过程被跳过&lt;/li&gt;
&lt;li&gt;STAUS，显示普通的消息&lt;/li&gt;
&lt;li&gt;FATAL_ERROR，终止cmake过程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://zhaozhuolin.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="cmake" scheme="http://zhaozhuolin.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://zhaozhuolin.com/2021/03/20210312.html"/>
    <id>http://zhaozhuolin.com/2021/03/20210312.html</id>
    <published>2021-03-12T05:08:09.000Z</published>
    <updated>2024-05-25T04:19:41.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的构成"><a href="#图的构成" class="headerlink" title="图的构成"></a>图的构成</h1><p><strong>顶点集合</strong>+<strong>边的集合</strong>：<code>G = (V, E)</code>，顶点集合<code>V = {x | x属于某个数据对象及}</code>是有穷非空集合</p><ul><li><p><code>E = {(x, y) | x, y属于V}</code>或者<code>E = {&lt;x, y&gt; | x, y属于V &amp;&amp; Path(x, y)}</code>是顶点间关系的有穷集合，也叫边集合</p></li><li><p><code>(x, y)</code>表示x到y的一条双向通道，即<code>(x, y)</code>是无方向的，<code>Path(x, y)</code>表示从x到y的一条单向通路，即<code>Path(x, y)是有方向的</code></p></li></ul><p>顶点和边：图中节点成为顶点，第i个顶点记作vi， 两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中第k条边记作ek，<code>ek = (vi, vj)</code>或<code>ek = &lt;vi, vj&gt;</code></p><ul><li>在有向图中，顶点对<code>&lt;x, y&gt;</code>是有序的，顶点对<code>&lt;x, y&gt;</code>称为顶点x到顶点y的一条边(弧)，<code>&lt;x, y&gt;</code>和<code>&lt;y ,x&gt;</code>是两条不同的边，如G3、G4</li><li>在无向图中，顶点对(x, y)是无序的，顶点对(x,y) 称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，如G1、G2</li><li>注意：<strong>无向边<code>(x, y)</code>等于有向边<code>&lt;x, y&gt;</code>和<code>&lt;y, x&gt;</code></strong></li></ul><span id="more"></span><p><em>可以表示</em>：社交关系</p><ul><li>社交关系中，每个人就是一个顶点，两个人是好友，他们之间就有了边，那么边的权值可以是他们的亲密度</li><li>无向图：QQ、微信类似的社交关系可以被看作是无向图（强社交关系，熟人社交）</li><li>有向图：微博（关注的关系）、抖音 （弱社交关系，陌生人社交、粉丝社交）</li><li>也可以用来表示地图（导航路线选择），网络连接（路由器选择）</li><li>vertex 顶点、edge 边、weight 权值</li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ol><li>完全图（即所有顶点相连接）：在有n个顶点的无向图中，若有<code>n * (n-1)/2</code>条边，即<em>任意两个顶点之间有且仅有一条边</em>，则称此图为<strong>无向完全图</strong>，如G1；在n个顶点的有向图中，若有<code>n * (n-1)</code>条边，即<em>任意两个顶点之间有且仅有方向</em> 相反的边，则称此图为<strong>有向完全图</strong>，如G4。</li><li>邻接顶点：在无向图中G中，若(u, v)是E(G)中的一条边，则称u和v互为邻接顶点，并称边(u,v)依附于顶点u 和v；在有向图G中，若是E(G)中的一条边，则称顶点u邻接到v，顶点v邻接自顶点u，并称边与 顶点u和顶点v相关联。</li><li>顶点的度：<u>顶点v的度是指与它相关联的边的条数</u>，记作<code>deg(v)</code>。在有向图中，顶点的度等于该顶点的入度与 出度之和，其中顶点v的入度是以v为终点的有向边的条数，记作<code>indev(v)</code>;顶点v的出度是以v为起始点的有向 边的条数，记作<code>outdev(v)</code>。因此：<code>dev(v) = indev(v) + outdev(v)</code>。注意：对于无向图，顶点的度等于该顶 点的入度和出度，即<code>dev(v) = indev(v) = outdev(v)</code>。</li><li>路径：在图<code>G = (V， E)</code>中，若从顶点vi出发有一组边使其可到达顶点vj，则称顶点vi到顶点vj的顶点序列为从 顶点vi到顶点vj的路径。</li><li>路径长度：对于不带权的图，一条路径的路径长度是指该路径上的边的条数；对于带权的图，一条路 径的路 径长度是指该路径上各个边权值的总和。</li></ol><p><img src="/2021/03/20210312/008eGmZEly1gpljuxnpgij30k00i1aby.jpg" alt="截屏2021-04-16 14.04.25"></p><ol><li>简单路径与回路：若路径上各顶点v1，v2，v3，…，vm均不重复，则称这样的路径为简单路径。若路 径上 第一个顶点v1和最后一个顶点vm重合，则称这样的路径为回路或环。即路径不重复为简单路径，重复则为回路</li><li>子图：某个图的一个部分（一部分边、一部分顶点等）称为其的子图</li><li>连通图：在<strong>无向图</strong>中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。如果图中任意一 对顶点 都是连通的，则称此图为连通图。（连通图不一定是完全图，但完全图一定是连通图，对连通图来说，仅需有路径即可，而完全图则要求两顶点邻接）</li><li>强连通图：在<strong>有向图</strong>中，若在每一对顶点vi和vj之间都存在一条从vi到vj的路径，也存在一条从vj到 vi的路 径，则称此图是强连通图</li><li>生成树（用最少的边把图连通）：一个连通图的最小连通子图称作该图的生成树。有n个顶点的连通图的生成树有n个顶点和n - 1条边。</li></ol><ul><li>图和树的区别：<ul><li>树可以认为是特殊的图，图不一定是树</li><li>联通图，且不带环（没有回路），就可以认为是树</li></ul></li></ul><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>保存节点以及边的关系</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>因为节点与节点之间的关系就是连通与否，即为0或者1，因此邻接矩阵(二维数组)即是：先用一个数组将顶点保存，然后采用矩阵来表示节点与节点之间的关系。</p><p><img src="/2021/03/20210312/008eGmZEly1gplp3axgjsj306n06wjrm.jpg" alt="截屏2021-04-16 17.05.50"></p><p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下</p><script type="math/tex; mode=display">edge = \left[ \begin{matrix}  & A & B & C & D \\ A & 0 & 1 & 0 & 1 \\ B & 1 & 0 & 1 & 0 \\ C & 0 & 1 & 0 & 1 \\ D & 1 & 0 & 1 & 0 \end{matrix} \right]</script><p><img src="/2021/03/20210312/008eGmZEly1gpltlbqflfj305i098jrl.jpg" alt="截屏2021-04-16 19.41.36"></p><p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下</p><script type="math/tex; mode=display">edge = \left[ \begin{matrix}  & A & B & C  \\ A & 0 & 1 & 0 \\ B & 1 & 0 & 1 \\ C & 0 & 0 & 0\end{matrix} \right]</script><ul><li>无向图的邻接矩阵是对称的，第i行(列)元素之和，就是顶点i的度。有向图的邻接矩阵则不一定是对称 的，第i行(列)元素之后就是顶点i 的出(入)度</li><li>如果边带有权值，并且两个节点之间是连通的，上图中的边的关系就用权值代替，如果两个顶点不通， 则使用无穷大代替</li><li>用邻接矩阵存储图的有点是能够快速知道两个顶点是否连通，缺陷是如果顶点比较多，边比较少时，矩 阵中存储了大量的0成为系数矩阵，比较浪费空间，并且要求两个节点之间的路径不是很好求。</li></ul><p><img src="/2021/03/20210312/008eGmZEly1gpluoyfacuj30m409f406.jpg" alt="截屏2021-04-16 20.18.53"></p><h3 id="邻接矩阵代码实现"><a href="#邻接矩阵代码实现" class="headerlink" title="邻接矩阵代码实现"></a>邻接矩阵代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vertex 顶点</span></span><br><span class="line"><span class="comment">//edge 边</span></span><br><span class="line"><span class="comment">//weight 权值</span></span><br><span class="line"><span class="comment">//matrix矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> matrix</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        {</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            _matrex.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                _matrex[i].<span class="built_in">resize</span>(n, <span class="built_in">W</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">"非法顶点"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            _matrex[srcIndex][dstIndex] = w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">                _matrex[dstIndex][srcIndex] = w;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;vector&lt;W&gt; &gt; _matrex;     <span class="comment">//表示邻接矩阵的边</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>使用数组表示顶点的集合，使用链表表示边的关系。</p><ul><li>图为无向图的邻接表存储</li></ul><p><img src="/2021/03/20210312/008eGmZEly1gpn1zc5fnyj30ir08adgk.jpg" alt="截屏2021-04-17 21.17.19"></p><ul><li>注意：无向图中同一条边在邻接表中出现了两次。如果想知道顶点vi的度，只需要知道顶点vi边链表集合中结点的数目即可</li><li>有向图则添加一个边的集合或者反向添加一次</li></ul><h2 id="邻接表的代码实现"><a href="#邻接表的代码实现" class="headerlink" title="邻接表的代码实现"></a>邻接表的代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> table</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> _srcIndex;</span><br><span class="line">        <span class="type">int</span> _dstIndex;</span><br><span class="line">        <span class="type">const</span> W&amp; _w;</span><br><span class="line"></span><br><span class="line">        EdgeNode&lt;W&gt;* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        {</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            _linkTable.<span class="built_in">resize</span>(n, <span class="literal">nullptr</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">"非法顶点"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">            node-&gt;_srcIndex = srcIndex;</span><br><span class="line">            node-&gt;_dstIndex = dstIndex;</span><br><span class="line">            node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//挂起头</span></span><br><span class="line">            node-&gt;_next = _linkTable[srcIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">            _linkTable[srcIndex] = node;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">            {</span><br><span class="line">                EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">                node-&gt;_srcIndex = dstIndex;</span><br><span class="line">                node-&gt;_dstIndex = srcIndex;</span><br><span class="line">                node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//挂起头</span></span><br><span class="line">                node-&gt;_next = _linkTable[dstIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">                _linkTable[dstIndex] = node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;EdgeNode&lt;W&gt;*&gt; _linkTable;<span class="comment">//邻接表</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历 一次。”遍历”即对结点进行某种操作的意思</p><h2 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h2><p>对邻接矩阵，深度优先可是使用递归的方式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _DFS(<span class="type">int</span> srcIndex, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span><br><span class="line">{</span><br><span class="line">  cout &lt;&lt; _vertexs[srcIndex] &lt;&lt; <span class="string">":"</span> &lt;&lt; srcIndex &lt;&lt; <span class="string">"-&gt;"</span>;<span class="comment">//输出当前节点</span></span><br><span class="line">  visited[srcIndex] = <span class="literal">true</span>;<span class="comment">//标记当前节点已访问</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">  {<span class="comment">//访问当前节点的相邻顶点</span></span><br><span class="line">    <span class="keyword">if</span>(_matrex[srcIndex][i] != <span class="built_in">W</span>() &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">      _DFS(i, visited);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">  _DFS(srcIndex, visited);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h2><p>对邻接矩阵，广度优先可以使用队列实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line"></span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(srcIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; _vertexs[front] &lt;&lt; <span class="string">":"</span> &lt;&lt; front &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    <span class="comment">//好友入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(visited[i] == <span class="literal">false</span> &amp;&amp; _matrex[front][i] != <span class="built_in">W</span>())</span><br><span class="line">      {</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>连通图中的每一棵生成树，都是原图的一个极大无环子图，即：从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成一条回路。 </p><p>若连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边。因此构造最小生成树的准则有三条：</p><ol><li>只能使用图中的边来构造最小生成树 </li><li>只能使用恰好n-1条边来连接图中的n个顶点</li><li>选用的n-1条边不能构成回路</li></ol><p>构造最小生成树的方法：<strong>Kruskal算法</strong>和<strong>Prim算法</strong>。</p><ul><li>这两个算法都采用了<strong>逐步求解的贪心策略</strong>。 贪心算法：是指在问题求解时，总是做出当前看起来最好的选择。也就是说贪心算法做出的不是整体最优的选择，而是某种意义上的局部最优解。贪心算法不是对所有的问题都能得到整体最优解。</li></ul><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><ol><li><p>任给一个有n个顶点的连通网络<code>N={V,E}</code></p></li><li><p>首先构造一个由这n个顶点组成、不含任何边的图<code>G={V,NULL}</code>，其中每个顶点自成一个连通分量</p></li><li>接着不断从E中取出权值最小的一条边(若有多条任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。</li><li>如此重复，直到所有顶点在同一个连通分量上为止。 </li></ol><ul><li>核心：每次迭代时，选出一条具有最小权值，且两端点不在同一连通分量上的边，加入生成树。</li></ul><blockquote><p>如何判断选出一条边以后跟已有的边是否构成回路：并查集</p><p>如果选的边在一个集合中，就不能再使用，不在一个集合才能添加</p></blockquote><h2 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a>Prime算法</h2><p>仍是贪心算法，但它先选出最小的一条边，接着并非从全局中找到最小的边，而是以最小的边为基础，选已有的边的邻接顶点链接出的边中最小的，避开了选出环路的情况</p><h1 id="单元最短路径"><a href="#单元最短路径" class="headerlink" title="单元最短路径"></a>单元最短路径</h1><p>从在带权图的某一顶点出发，找出一条通往另一顶点的最短路径，最短也就是沿路径各边的权值总和达到最小。</p><blockquote><p>Dijkstra算法和Floyd算法</p></blockquote><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>求一个点和图中的其他所有点之间的最路径</p><p><img src="/2021/03/20210312/008i3skNly1gptzx4hmntj30au0a0mxt.jpg" alt="截屏2021-04-23 21.25.02"></p><p><img src="/2021/03/20210312/008i3skNly1gpu0bcc8v9j30kv089wgk.jpg" alt="截屏2021-04-23 21.38.39"></p><div class="table-container"><table><thead><tr><th>路径</th><th>路径长度</th></tr></thead><tbody><tr><td>0，1</td><td>无穷大</td></tr><tr><td>0，2</td><td>50</td></tr><tr><td>0，3</td><td>10</td></tr><tr><td>0，4</td><td>50</td></tr></tbody></table></div><p>依次遍历所有的边，找出更短路径，找到则更新</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;图的构成&quot;&gt;&lt;a href=&quot;#图的构成&quot; class=&quot;headerlink&quot; title=&quot;图的构成&quot;&gt;&lt;/a&gt;图的构成&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;顶点集合&lt;/strong&gt;+&lt;strong&gt;边的集合&lt;/strong&gt;：&lt;code&gt;G = (V, E)&lt;/code&gt;，顶点集合&lt;code&gt;V = {x | x属于某个数据对象及}&lt;/code&gt;是有穷非空集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;E = {(x, y) | x, y属于V}&lt;/code&gt;或者&lt;code&gt;E = {&amp;lt;x, y&amp;gt; | x, y属于V &amp;amp;&amp;amp; Path(x, y)}&lt;/code&gt;是顶点间关系的有穷集合，也叫边集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(x, y)&lt;/code&gt;表示x到y的一条双向通道，即&lt;code&gt;(x, y)&lt;/code&gt;是无方向的，&lt;code&gt;Path(x, y)&lt;/code&gt;表示从x到y的一条单向通路，即&lt;code&gt;Path(x, y)是有方向的&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顶点和边：图中节点成为顶点，第i个顶点记作vi， 两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中第k条边记作ek，&lt;code&gt;ek = (vi, vj)&lt;/code&gt;或&lt;code&gt;ek = &amp;lt;vi, vj&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在有向图中，顶点对&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;是有序的，顶点对&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;称为顶点x到顶点y的一条边(弧)，&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;y ,x&amp;gt;&lt;/code&gt;是两条不同的边，如G3、G4&lt;/li&gt;
&lt;li&gt;在无向图中，顶点对(x, y)是无序的，顶点对(x,y) 称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，如G1、G2&lt;/li&gt;
&lt;li&gt;注意：&lt;strong&gt;无向边&lt;code&gt;(x, y)&lt;/code&gt;等于有向边&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;y, x&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="图" scheme="http://zhaozhuolin.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>在线的面试预约系统</title>
    <link href="http://zhaozhuolin.com/2020/08/20200827.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200827.html</id>
    <published>2020-08-26T16:05:00.000Z</published>
    <updated>2023-05-07T11:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>通过httplib库函数中的Post和Get方法来处理以下四种请求</p><ul><li><code>注册</code> ：处理浏览器传来的数据，并调用数据库函数增加列</li><li><code>登录</code> ：处理浏览器传来的数据，在数据库中进行查询，登陆成功则生成sessionID用以后续使用</li><li><code>数据页面</code>：处理浏览器传来的数据，使用sessionID查询当前登录的用户，在数据库中查询该用户信息并返回</li><li><code>数据提交</code>：处理浏览器传来的数据，根据头部的sessionID查询登陆用户，切割正文提交的信息，插入数据库</li></ul><span id="more"></span><p><img src="/2020/08/20200827/007S8ZIlly1gi4nyalqwpj31f40nijuu.jpg" alt="IMG_7559"></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><h3 id="http服务"><a href="#http服务" class="headerlink" title="http服务"></a>http服务</h3><p>创建了一个类来完成整个项目的运行，这个类用于保存登录数据库的参数、所有登录用户的sessionid、启动http服务，其结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AisSvr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AisSvr</span>()</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">OnInit</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span><span class="comment">//启动http服务</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">GetSessionId</span><span class="params">(httplib::Request res, string* session_id)</span></span>;<span class="comment">//获取当前用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span></span>;<span class="comment">//打开配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string _svr_ip;<span class="comment">//服务端监听的IP地址</span></span><br><span class="line">  <span class="type">uint16_t</span> _svr_port;<span class="comment">//服务端监听的端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据库类成员</span></span><br><span class="line">  DataBaseSvr* _db;</span><br><span class="line">  string _db_ip;</span><br><span class="line">  string _db_user;</span><br><span class="line">  string _db_passwd;</span><br><span class="line">  string _db_name;</span><br><span class="line">  <span class="type">uint16_t</span> _db_port;</span><br><span class="line"></span><br><span class="line">  AllSessionInfo* _all_session;<span class="comment">//所有登录用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  httplib::Server _http_svr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>对于数据库的操作，同样创建了一个类来完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataBaseSvr</span><span class="comment">//数据库类</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DataBaseSvr</span>(string&amp; host, string&amp; user, string&amp; passwd, string&amp; db, <span class="type">uint16_t</span> port)</span><br><span class="line">    &#123;</span><br><span class="line">      _host = host;</span><br><span class="line">      _user = user;</span><br><span class="line">      _passwd = passwd;</span><br><span class="line">      _db = db;</span><br><span class="line">      _port = port;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">mysql_init</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DataBaseSvr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">mysql_close</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QuerySql</span><span class="params">(<span class="type">const</span> string&amp; sql)</span></span>;<span class="comment">//操作数据库接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Connect2MySQL</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="type">bool</span> <span class="title">QueryUserExist</span><span class="params">(Json::Value&amp; request_json, Json::Value* result)</span></span>;<span class="comment">//数据库查询</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QueryOneStuInfo</span><span class="params">(string user_id, Json::Value* result)</span></span>;<span class="comment">//查询用户信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//MySQL就是客户端的操作句柄</span></span><br><span class="line">    MYSQL _mysql;</span><br><span class="line">    string _host;</span><br><span class="line">    string _user;</span><br><span class="line">    string _passwd;</span><br><span class="line">    string _db;</span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sessionid管理"><a href="#sessionid管理" class="headerlink" title="sessionid管理"></a>sessionid管理</h3><p>创建了一个类专门计算MD5值，用另一个类进行封装，同时管理一批sessionid</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Session</span>(Json::Value&amp; user_info)</span><br><span class="line">    &#123;</span><br><span class="line">      _origin_str.<span class="built_in">clear</span>();</span><br><span class="line">      _user_info = user_info;</span><br><span class="line"></span><br><span class="line">      _origin_str += <span class="built_in">to_string</span>(_user_info[<span class="string">&quot;stu_id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_interview_time&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SumMd5</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">string&amp; <span class="title">GetSessionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">SumMd5</span>();</span><br><span class="line">      <span class="keyword">return</span> _session_id;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//private:因为不想再写个接口获取sessionid所以直接将成员变量设为public（懒惰！）</span></span><br><span class="line">    string _session_id;<span class="comment">//保存session_id</span></span><br><span class="line">    string _origin_str;<span class="comment">//原始的串，用来生成session_id</span></span><br><span class="line">    Json::Value _user_info;<span class="comment">//原始串内容：stu_id, stu_name, stu_interview_time</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllSessionInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  ~<span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  <span class="comment">//Set Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">SetSessionValue</span><span class="params">(string&amp; session_id, Session&amp; session_info)</span></span>;</span><br><span class="line">  <span class="comment">//Get Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetSessionValue</span><span class="params">(string&amp; session_id, Session* session_info)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//key：sessionid，value：session</span></span><br><span class="line">  unordered_map&lt;string, Session&gt; _session_map;</span><br><span class="line">  <span class="type">pthread_mutex_t</span> _map_lock;<span class="comment">//所有操作均需要互斥完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>该模块主要完成对浏览器响应正文的数据进行分割和解析，输出日志信息，较为简单</p><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><h3 id="响应登录请求-Post方法"><a href="#响应登录请求-Post方法" class="headerlink" title="响应登录请求(Post方法)"></a>响应登录请求(Post方法)</h3><ol><li>解析提交的内容</li><li>先根据邮箱作为查询条件，如果邮箱不存在，则登陆失败，如果邮箱存在，则校验密码</li><li>上一步校验失败，向浏览器返回false，校验成功则进行下一步</li><li>根据登录用户信息，生成sessionid，用以表示当前用户</li><li>跳转到个人信息页面</li></ol><h3 id="个人信息也页面-Get方法"><a href="#个人信息也页面-Get方法" class="headerlink" title="个人信息也页面(Get方法)"></a>个人信息也页面(Get方法)</h3><ol><li>根据请求头部的sessionid信息，从管理sessionid的类中获取当前登录用户信息</li><li>查询数据库，获取用户信息</li><li>组织应答</li></ol><h3 id="注册请求-Post方法"><a href="#注册请求-Post方法" class="headerlink" title="注册请求(Post方法)"></a>注册请求(Post方法)</h3><ol><li>解析请求正文</li><li>将解析出的用户信息插入注册信息表(此处需要开启数据库事务，加入注册信息插入失败，则回滚)</li><li>组织应答</li></ol><h3 id="预约请求-Post方法"><a href="#预约请求-Post方法" class="headerlink" title="预约请求(Post方法)"></a>预约请求(Post方法)</h3><p>基本思路同注册请求</p><h1 id="效果预览图与项目代码"><a href="#效果预览图与项目代码" class="headerlink" title="效果预览图与项目代码"></a>效果预览图与项目代码</h1><p>注册页面</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nypyjs4j310k0qiwgl.jpg" alt="IMG_7555"></p><p>登录页面</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nzbxgiwj310k0qiwgh.jpg" alt="IMG_7556"></p><p>数据提交页面</p><p><img src="/2020/08/20200827/007S8ZIlly1gi4o34di6rj30xn06574p.jpg" alt="IMG_7554"></p><p>个人信息页面</p><p><img src="/2020/08/20200827/007S8ZIlly1gi4o35739vj30xn06574p.jpg" alt="IMG_7558"></p><p>GitHub地址：<a href="https://github.com/Latsummer/interview-system">https://github.com/Latsummer/interview-system</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h1&gt;&lt;p&gt;通过httplib库函数中的Post和Get方法来处理以下四种请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;注册&lt;/code&gt; ：处理浏览器传来的数据，并调用数据库函数增加列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;登录&lt;/code&gt; ：处理浏览器传来的数据，在数据库中进行查询，登陆成功则生成sessionID用以后续使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据页面&lt;/code&gt;：处理浏览器传来的数据，使用sessionID查询当前登录的用户，在数据库中查询该用户信息并返回&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据提交&lt;/code&gt;：处理浏览器传来的数据，根据头部的sessionID查询登陆用户，切割正文提交的信息，插入数据库&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="小作品" scheme="http://zhaozhuolin.com/categories/%E5%B0%8F%E4%BD%9C%E5%93%81/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="后端" scheme="http://zhaozhuolin.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>简单的Boost文档搜索引擎--基于jieba分词和HTTP协议</title>
    <link href="http://zhaozhuolin.com/2020/08/20200826.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200826.html</id>
    <published>2020-08-26T07:40:00.000Z</published>
    <updated>2023-05-07T11:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更方便的使用Boost库，于是想到实现一个基于Boost离线文档的搜索引擎，对离线的HTML文件进行分析，、并对查询词进行分词（借用第三方库），然后根据相关性（简陋的相关性公式）进行排序，最终将查询结果用JSON的数据格式进行组织打包，最终通过对外的http服务将查询结果返回</p><span id="more"></span><h2 id="成品效果以及GitHub链接"><a href="#成品效果以及GitHub链接" class="headerlink" title="成品效果以及GitHub链接"></a>成品效果以及GitHub链接</h2><blockquote><p>由于不怎么会前端的一些语法，所以页面比较简陋</p></blockquote><p><img src="/2020/08/20200826/007S8ZIlly1gi49kgwwqmj31hc0u01a0.jpg" alt="IMG_7552"></p><p><img src="/2020/08/20200826/007S8ZIlly1gi49kbll6kj30rx06wwg2.jpg" alt="IMG_7553"></p><p>详细代码于 - GitHub链接：<a href="https://github.com/Latsummer/Boost-search-engine">GitHub  Boost-search-engine</a></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>按照处理流程，整个项目的结构可以被分为，预处理模块，索引模块，搜索模块以及服务器模块</p><ol><li>预处理模块：读取原始的HTML文档内容，进行预处理操作：解析一些重要的信息，如文档标题、文档的URL，文档的正文，即去除HTML标签，只保留正文；在预处理完毕之后，将结果整理成一个行文本文件，用以之后的模块使用</li><li>索引模块：将预处理好的行文本文件输入，根据预处理结果，在内存中构造正排索引（文档ID =&gt; 文档正文）和倒排索引（文档正文 =&gt; 文档ID）</li><li>搜索模块：输入查询词，先对查询词进行分词，然后实现触发，将查询结果按照相关性进行排序，依次拼装，按照JSON数据格式进行组织</li><li>服务器模块：加载搜索引擎模块，对外提供HTTP服务</li></ol><p><img src="/2020/08/20200826/007S8ZIlly1gi49l0rlk0j317m0csgnf.jpg" alt="IMG_7551"></p><h1 id="预处理模块"><a href="#预处理模块" class="headerlink" title="预处理模块"></a>预处理模块</h1><p>该模块核心功能为：读取并分析Boost文档的.html文件内容，解析出每个文档的标题，URL，正文，最终把结果输出为一个行文版文件</p><p>首先根据核心功能，定义一个可以表示一个文章的结构体，以及一些全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string g_input_path = <span class="string">&quot;../data/input/&quot;</span>;<span class="comment">//表示从哪个目录中读取boost文档中的html</span></span><br><span class="line">string g_output_path = <span class="string">&quot;../data/tmp/raw_input&quot;</span>;<span class="comment">//表示预处理模块的输出结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  string tittle;<span class="comment">//标题</span></span><br><span class="line">  string url;<span class="comment">//url</span></span><br><span class="line">  string content;<span class="comment">//正文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="枚举路径"><a href="#枚举路径" class="headerlink" title="枚举路径"></a>枚举路径</h2><p>使用Boost中的filesystem的递归文档迭代器来对每一个文件进行枚举，使用一个vector来临时存储，用于之后的解析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnumFile</span><span class="params">(<span class="type">const</span> string&amp; input_path, vector&lt;string&gt;* file_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">filesystem::path <span class="title">root_path</span><span class="params">(input_path)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">exists</span>(root_path) )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;目录不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个迭代器使用循环的时候可以自动完成递归（对文件）</span></span><br><span class="line">  boost::filesystem::recursive_directory_iterator end_iter;</span><br><span class="line">  <span class="keyword">for</span>(boost::filesystem::recursive_directory_iterator <span class="built_in">it</span>(root_path);  it != end_iter; it++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//当前路径对应的如果是目录则跳过</span></span><br><span class="line">    <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">is_regular_file</span>(*it) )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//当前路径对应的文件如果不是html文件，跳过</span></span><br><span class="line">    <span class="keyword">if</span>( it-&gt;<span class="built_in">path</span>().<span class="built_in">extension</span>() != <span class="string">&quot;.html&quot;</span> )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//把得到的路径加入到vector中</span></span><br><span class="line">    file_list-&gt;<span class="built_in">push_back</span>(it-&gt;<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h2><ol><li>遍历上一步vector中存放的文件路径，读取文件内容，将读取内容写入到string类型变量<code>html</code>中</li><li>根据读取到的内容，首先解析出标题，按照html中的标签<code>&lt;title&gt;&lt;/title&gt;</code>，调用string类成员函数<code>substr</code>获取文章标题</li><li>根据读取到的内容，构造对应的URL，由于网络路径和文件路径一致，所以只需要在文件的路径前加上前缀<code>https://www.boost.org/doc/libs/1_53_0/doc/</code>即可</li><li>根绝读取到的内容，解析正文片段，跳过字符<code>&lt;</code>和字符<code>&gt;</code>中的内容，同时将内容中的<code>\n</code>替换为空格（因为最终结果要对应到原始的html文档）</li><li>对于2、3、4步骤，解析出的三个内容使用不可见字符<code>\3</code>分割，然后写入删除文件<code>raw_put</code>中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFile</span><span class="params">(<span class="type">const</span> string&amp; file_path, DocInfo* doc_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//1. 先读取文件内容</span></span><br><span class="line">  string html;</span><br><span class="line">  <span class="type">bool</span> ret = common::Util::<span class="built_in">Read</span>(file_path, &amp;html);</span><br><span class="line">  <span class="keyword">if</span>(!ret)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解析文件失败!&quot;</span> &lt;&lt; file_path &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 根据文件内容解析出标题</span></span><br><span class="line">  ret = <span class="built_in">ParseTitle</span>(html, &amp;doc_info-&gt;tittle);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;标题解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3. 根据文件路径，构造出对应的在线文档</span></span><br><span class="line">  ret = <span class="built_in">ParseUrl</span>(file_path, &amp;doc_info-&gt;url);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;url 解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4. 根据文件内容，去标签，作为doc_info中的content字段内容</span></span><br><span class="line">  ret = <span class="built_in">ParseContent</span>(html, &amp;doc_info-&gt;content);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正文解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h1><p>索引使用了正排索引和倒排索引，其结构体分别如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正排索引：给定doc_id映射到文档内容（DocInfo对象）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;</span><br><span class="line">  string _title;</span><br><span class="line">  string _url;</span><br><span class="line">  string _content;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒排索引：给定词，映射到包含该词语的文档id列表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weight</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;<span class="comment">//该词在哪个文档出现</span></span><br><span class="line">  <span class="type">int</span> _weight;<span class="comment">//对应的权重</span></span><br><span class="line">  string _word;<span class="comment">//什么词</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个类来表示整个索引结构，并提供外部调用的API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Index</span>();</span><br><span class="line">    <span class="comment">//1. 查正排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> DocInfo* <span class="title">GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span>;</span><br><span class="line">    <span class="comment">//2. 查倒排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>;</span><br><span class="line">    <span class="comment">//3. 构建索引</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Build</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">DocInfo* <span class="title">BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span>;</span><br><span class="line">    cppjieba::Jieba jieba;<span class="comment">//jieba分词</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//正排索引，数组下标对应到doc_id</span></span><br><span class="line">    vector&lt;DocInfo&gt; _forward_index;</span><br><span class="line">    <span class="comment">//倒排索引，使用一个hash表来表示映射关系</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;Weight&gt; &gt; _inverted_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建正排索引"><a href="#创建正排索引" class="headerlink" title="创建正排索引"></a>创建正排索引</h2><p>正排索引使用vector来存放，文章的ID就是其所在位置的下标，元素内容就是预处理模块中的输出内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DocInfo* <span class="title">Index::BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vector&lt;string&gt; tokens;</span><br><span class="line">  common::Util::<span class="built_in">Split</span>(line, <span class="string">&quot;\3&quot;</span>, &amp;tokens);</span><br><span class="line">  <span class="keyword">if</span>( tokens.<span class="built_in">size</span>() != <span class="number">3</span> )<span class="comment">//如果没有被切分为3份，说明节分结果有问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//把切分结果填充到DocInfo对象中</span></span><br><span class="line">  DocInfo doc_info;</span><br><span class="line">  doc_info._doc_id = _forward_index.<span class="built_in">size</span>();</span><br><span class="line">  doc_info._title = tokens[<span class="number">0</span>];</span><br><span class="line">  doc_info._url = tokens[<span class="number">1</span>];</span><br><span class="line">  doc_info._content = tokens[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">  _forward_index.<span class="built_in">push_back</span>(<span class="built_in">move</span>(doc_info));<span class="comment">//转化为右值引用，移动语义复制赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index.<span class="built_in">back</span>();<span class="comment">//防止野指针问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建倒排索引"><a href="#创建倒排索引" class="headerlink" title="创建倒排索引"></a>创建倒排索引</h2><p>依次对标题与正文进行分词，建立统计词频的结构体，根据统计结果，填充<code>Weight</code>对象，其中成员<code>_weight</code>(权重)简单的设计了一个公式：权重 == 10 * 标题出现次数 + 正文出现次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//倒排是一个hash表</span></span><br><span class="line">  <span class="comment">//key是词（针对文档分词结果）</span></span><br><span class="line">  <span class="comment">//value是倒排拉链（包含若干个Weight对象）</span></span><br><span class="line">  <span class="comment">//每次遍历到一个文档，分析之后把信息更新到倒排结构中</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Index::BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//0. 创建专门统计词频的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">WordCnt</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> _title_cnt;</span><br><span class="line">      <span class="type">int</span> _content_cnt;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">WordCnt</span>() </span><br><span class="line">          : _title_cnt(<span class="number">0</span>)</span><br><span class="line">          , _content_cnt(<span class="number">0</span>) </span><br><span class="line">      &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    unordered_map&lt;string, WordCnt&gt; word_cnt_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 对标题进行分词</span></span><br><span class="line">    vector&lt;string&gt; title_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.title, &amp;title_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="comment">//次数要考虑大小写问题，大小写应该都算成小写</span></span><br><span class="line">    <span class="keyword">for</span>(string&amp; word : title_token)</span><br><span class="line">    &#123;</span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">      ++word_cnt_map[word]._title_cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对正文分词</span></span><br><span class="line">    vector&lt;string&gt; content_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.content, &amp;content_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (string word : content_token) </span><br><span class="line">    &#123;</span><br><span class="line">       boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">       ++word_cnt_map[word]._content_cnt;                      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 根据统计结果，整个出Weight对象，把结果更新到倒排索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; word_pair : word_cnt_map)</span><br><span class="line">    &#123;</span><br><span class="line">      Weight weight;</span><br><span class="line">      weight._doc_id = doc_info.doc_id;</span><br><span class="line">      weight._weight = <span class="number">10</span> * word_pair.second._title_cnt + word_pair.second._content_cnt;</span><br><span class="line">      weight._word = word_pair.first;</span><br><span class="line"></span><br><span class="line">      vector&lt;Weight&gt;&amp; inverted_list = _inverted_index[word_pair.first];</span><br><span class="line">      inverted_list.<span class="built_in">push_back</span>(<span class="built_in">move</span>(weight));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Index::CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    jieba.<span class="built_in">CutForSearch</span>(input, *output);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，整个索引模块建立完成，内存中即存在了正排索引结构和倒排索引结构，等待搜索模块去调用</p><h2 id="查询正排-倒排索引"><a href="#查询正排-倒排索引" class="headerlink" title="查询正排/倒排索引"></a>查询正排/倒排索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> DocInfo* <span class="title">Index::GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( doc_id &lt; <span class="number">0</span> || doc_id &gt;= _forward_index.<span class="built_in">size</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index[doc_id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">Index::GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = _inverted_index.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span>( it == _inverted_index.<span class="built_in">end</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Searcher</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//搜索过程中依赖索引，需要持有索引指针</span></span><br><span class="line">    Index* index;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Searcher</span>() </span><br><span class="line">        :<span class="built_in">index</span>(<span class="keyword">new</span> <span class="built_in">Index</span>())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* results)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="function">string <span class="title">GenerateDesc</span><span class="params">(<span class="type">const</span> string&amp; content, <span class="type">const</span> string&amp; word)</span></span>;<span class="comment">//生成描述</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>在使用搜索模块时，创建<code>Searcher</code>对象，即<code>new</code>了一个Index对象，接着调用成员函数<code>Init</code>，它会调用Index的成员函数<code>Build</code>，来创建正排索引和倒排索引，在需要查询时，调用成员函数<code>Search</code>，完成查询过程，将结果写入string类对象<code>results</code>中</p><h2 id="搜索函数"><a href="#搜索函数" class="headerlink" title="搜索函数"></a>搜索函数</h2><p>搜索模块先对查询词进行分词，再根据分词结果去调用索引模块的查询正排，倒排成员函数，接着将查询结果按照权重降序排列，最后调用JSONCPP库函数来包装查询结果（同时调用相关函数来生成描述），序列化为字符串输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Searcher::Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//1. [分词] 针对查询结果进行分词</span></span><br><span class="line">    vector&lt;string&gt; tokens;</span><br><span class="line">    index-&gt;<span class="built_in">CutWord</span>(query, &amp;tokens);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. [触发] 根据分词结果，查询倒排，把相关文档都获取到</span></span><br><span class="line">    vector&lt;Weight&gt; all_token_result;</span><br><span class="line">    <span class="keyword">for</span>(string word : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//做索引的时候，已经把其中的词统一转成小写了</span></span><br><span class="line">      <span class="comment">//查询到排的时候，也需要把查询词统一转成小写</span></span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span>* inverted_list = index-&gt;<span class="built_in">GetInvertedList</span>(word);</span><br><span class="line">      <span class="keyword">if</span>( inverted_list == <span class="literal">nullptr</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//说明该词在倒排索引中不存在，如果这个词比较生僻，</span></span><br><span class="line">        <span class="comment">//在所有文档中都没有出现过。此时得到的倒排拉链就是nullptr</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//tokens 包含多个结果，需要把多个结果合并到一起，才能进行统一排序</span></span><br><span class="line">      all_token_result.<span class="built_in">insert</span>(all_token_result.<span class="built_in">end</span>(), </span><br><span class="line">                              inverted_list-&gt;<span class="built_in">begin</span>(), inverted_list-&gt;<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. [排序] 把刚才查到的文档的倒排拉链合并到一起并按照权重进行降序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(all_token_result.<span class="built_in">begin</span>(), all_token_result.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> Weight&amp; w1, <span class="type">const</span> Weight&amp; w2)&#123;</span><br><span class="line">      <span class="comment">//实现降序排序 w1 &gt; w2</span></span><br><span class="line">      <span class="keyword">return</span> w1.weight &gt; w2.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. [包装结果] 把得到的这些倒排拉链中的文档id获取到，然后去查正排，</span></span><br><span class="line">    <span class="comment">//             再把doc_info中的内容构造成最终的预期格式(JSON)</span></span><br><span class="line">    <span class="comment">//使用JSONCPP库来实现</span></span><br><span class="line">    Json::Value results;<span class="comment">//包含若干个结果，每个结果就是一个JSON对象对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; weight : all_token_result)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//根据weight中的结果查询正排序</span></span><br><span class="line">      <span class="type">const</span> DocInfo* doc_info = index-&gt;<span class="built_in">GetDocInfo</span>(weight.doc_id);</span><br><span class="line">      <span class="comment">//把doc_info对象进一步包装成一个JSON对象</span></span><br><span class="line">      Json::Value result;</span><br><span class="line">      result[<span class="string">&quot;title&quot;</span>] = doc_info-&gt;title;</span><br><span class="line">      result[<span class="string">&quot;url&quot;</span>] = doc_info-&gt;url;</span><br><span class="line">      result[<span class="string">&quot;desc&quot;</span>] = <span class="built_in">GenerateDesc</span>(doc_info-&gt;content, weight.word);</span><br><span class="line">      results.<span class="built_in">append</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一步，把得到的results这个JSON对象序列化为字符串，写入output中</span></span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    *output = writer.<span class="built_in">write</span>(results);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，搜索模块就搭建好了，等待最终的服务器模块调用</p><h1 id="服务器模块"><a href="#服务器模块" class="headerlink" title="服务器模块"></a>服务器模块</h1><p>首先初始化Searcher对象，调用<code>Init</code>成员函数初始化索引结构，然后调用Server对象中的Get方法，接收网页端请求，分析参数调用查询函数，然就将结果返回给网页端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> httplib;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建Searcher对象</span></span><br><span class="line">    searcher::Searcher searcher;</span><br><span class="line">    <span class="type">bool</span> ret = searcher.<span class="built_in">Init</span>(<span class="string">&quot;../data/tmp/raw_input&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Searcher初始化失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server;</span><br><span class="line">    server.<span class="built_in">Get</span>(<span class="string">&quot;/searcher&quot;</span>, [&amp;searcher](<span class="type">const</span> Request&amp; req, Response&amp; resp)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!req.<span class="built_in">has_param</span>(<span class="string">&quot;query&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            resp.<span class="built_in">set_content</span>(<span class="string">&quot;请求参数错误&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string query = req.<span class="built_in">get_param_value</span>(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        cout  &lt;&lt; <span class="string">&quot;收到查询词：&quot;</span> &lt;&lt; query &lt;&lt; endl;</span><br><span class="line">        string results;</span><br><span class="line">        searcher.<span class="built_in">Search</span>(query, &amp;results);</span><br><span class="line">        resp.<span class="built_in">set_content</span>(results, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.<span class="built_in">set_base_dir</span>(<span class="string">&quot;./www&quot;</span>);</span><br><span class="line">    server.<span class="built_in">listen</span>(<span class="string">&quot;x.x.x.x&quot;</span>, [port]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个搜索引擎已经搭建完成，只需要运行起来即可</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了更方便的使用Boost库，于是想到实现一个基于Boost离线文档的搜索引擎，对离线的HTML文件进行分析，、并对查询词进行分词（借用第三方库），然后根据相关性（简陋的相关性公式）进行排序，最终将查询结果用JSON的数据格式进行组织打包，最终通过对外的http服务将查询结果返回&lt;/p&gt;</summary>
    
    
    
    <category term="小作品" scheme="http://zhaozhuolin.com/categories/%E5%B0%8F%E4%BD%9C%E5%93%81/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="后端" scheme="http://zhaozhuolin.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>特殊类设计</title>
    <link href="http://zhaozhuolin.com/2020/08/20200820.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200820.html</id>
    <published>2020-08-20T06:14:00.000Z</published>
    <updated>2023-05-07T11:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只能在堆上创建对象的类"><a href="#只能在堆上创建对象的类" class="headerlink" title="只能在堆上创建对象的类"></a>只能在堆上创建对象的类</h1><ol><li>构造函数私有</li><li>提供一个静态的堆上创建对象的方法</li><li>防止拷贝（拷贝构造声明为私有且不实现，或者声明为delete）<span id="more"></span></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> HeapOnly* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapOnly;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HeapOnly</span>()</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp; H) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testHeaponly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HeapOnly* ptr = HeapOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只能在栈上创建对象的类"><a href="#只能在栈上创建对象的类" class="headerlink" title="只能在栈上创建对象的类"></a>只能在栈上创建对象的类</h1><ol><li>构造函数私有</li><li>提供一个静态的栈上创建对象的方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">StackOnly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">StackOnly</span>()&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testStackOnly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackOnly so = StackOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：屏蔽new</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">StackOnly2</span>()</span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对象不能被拷贝的类"><a href="#对象不能被拷贝的类" class="headerlink" title="对象不能被拷贝的类"></a>对象不能被拷贝的类</h1><p>将拷贝构造与赋值运算符声明为delete函数或者声明为私有且不实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyBan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CopyBan</span>() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">CopyBan</span>(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">CopyBan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="不能被继承的类"><a href="#不能被继承的类" class="headerlink" title="不能被继承的类"></a>不能被继承的类</h1><ol><li>父类构造声明为私有</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">NoSon</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>加上final关键字</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span> <span class="keyword">final</span></span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类只能创建一个对象，该模式可以保证该类中只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><ol><li>构造函数私有</li><li>提供一个静态的方法返回单例</li><li>声明一个静态的单例成员</li><li>拷贝构造和赋值声明为delete函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_single;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton _single;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line">Singleton Singleton::_single;</span><br></pre></td></tr></table></figure><p>特点：实现简单，多线程情境下效率高</p><p>缺陷：程序启动比较满，多个单例对象初始化的顺序无法控制</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><ol><li>构造函数私有</li><li>提供一个静态的方法返回单例，第一次调用创建对象，后续调用直接返回</li><li>声明一个静态指针，指针初始化为nullptr</li><li>拷贝构造和赋值声明为delete</li><li>保证线程安全（修改指针），双检查提高效率</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton2* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;<span class="comment">//双检查</span></span><br><span class="line">_mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第一次调用， 创建对象</span></span><br><span class="line">_ptr = <span class="keyword">new</span> Singleton2;</span><br><span class="line">&#125;</span><br><span class="line">_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GC</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">GC</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_ptr)</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton2</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Singleton2</span>(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton2* _ptr;</span><br><span class="line"><span class="type">static</span> mutex _mtx;</span><br><span class="line"><span class="type">static</span> GC _gc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton2* Singleton2::_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton2::_mtx;</span><br><span class="line">Singleton2::GC Singleton2::_gc;</span><br></pre></td></tr></table></figure><p>特点：延迟加载，程序启动快，可以指定多个单例对象的初始化顺序</p><p>缺陷：实现较为复杂</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;只能在堆上创建对象的类&quot;&gt;&lt;a href=&quot;#只能在堆上创建对象的类&quot; class=&quot;headerlink&quot; title=&quot;只能在堆上创建对象的类&quot;&gt;&lt;/a&gt;只能在堆上创建对象的类&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;构造函数私有&lt;/li&gt;
&lt;li&gt;提供一个静态的堆上创建对象的方法&lt;/li&gt;
&lt;li&gt;防止拷贝（拷贝构造声明为私有且不实现，或者声明为delete）&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="-C++ -类与对象" scheme="http://zhaozhuolin.com/tags/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++11中的新特性</title>
    <link href="http://zhaozhuolin.com/2020/07/20200727.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200727.html</id>
    <published>2020-07-27T08:40:15.000Z</published>
    <updated>2023-05-07T11:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><p>C++11：支持内置类型与自定义类型的列表初始化，其中自定义类型不是天然支持列表初始化，需要显示定义参数类型为<code>initiaizer_list</code>的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span> (<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    : _a(a)</span><br><span class="line">    , _b(b)</span><br><span class="line">  &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">  <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> c&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">float</span> d = &#123; <span class="number">1.2</span> &#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m = &#123; &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">A a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="变量类型推导"><a href="#变量类型推导" class="headerlink" title="变量类型推导"></a>变量类型推导</h1><ul><li>auto：编译时根据初始化表达式进行类型推导</li><li>decltype：运行时类型识别，如果有参数列表，推导返回值类型，如果没有参数列表，只有函数名，推导为函数的接口类型</li></ul><h1 id="final与override"><a href="#final与override" class="headerlink" title="final与override"></a>final与override</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span> <span class="comment">//不能被继承</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">override</span> <span class="comment">//强制子类重写父类虚函数</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="默认成员函数控制"><a href="#默认成员函数控制" class="headerlink" title="默认成员函数控制"></a>默认成员函数控制</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a): _a(a) </span><br><span class="line">&#123;&#125; </span><br><span class="line">  <span class="comment">// 显式缺省构造函数，由编译器生成 </span></span><br><span class="line"><span class="built_in">A</span>() = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> C&amp; c) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">//把一个函数声明成已删除函数，不能再被使用</span></span><br><span class="line">  <span class="comment">//拷贝构造声明为delete：放拷贝</span></span><br><span class="line">  </span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a); </span><br><span class="line"> <span class="comment">// 在类中声明，在类外定义时让编译器生成默认赋值运算符重载 </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">int</span> _a; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">A&amp; A::<span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line">A a2; </span><br><span class="line">a2 = a1; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>简单来说，左值：可以出现在<code>=</code>的两边、或者可以取地址的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* p2 = &amp;b;</span><br></pre></td></tr></table></figure><p>右值：只能出现在<code>=</code>的右边，或者不可以取地址（非绝对）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>；</span><br><span class="line"><span class="type">int</span>* p = &amp;<span class="number">10</span>;</span><br><span class="line"><span class="comment">//此处10和20均为右值</span></span><br></pre></td></tr></table></figure><p>C++中的右值：</p><ul><li>纯右值：常量、临时变量。<code>getA(A) = b;    int* p = &amp;(getA());</code></li><li>将亡值：声明周期即将结束的值</li></ul><p>临时变量：函数以值返回的变量，调用类的构造函数创建的变量</p><ul><li>左值引用：引用的实体既可以为左值，也可以为右值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ra = a;</span><br><span class="line"><span class="comment">//ra实体为左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ri = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//ri实体为右值</span></span><br></pre></td></tr></table></figure><ul><li>右值引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; lr = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//实体为常量</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; lr2 = <span class="built_in">getA</span>();</span><br><span class="line"><span class="comment">//实体为临时变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r3 = <span class="built_in">getA</span>();<span class="comment">//左值引用，实体为右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; r4 = a;<span class="comment">//不能使用，右值引用语法不能用来引用左值</span></span><br></pre></td></tr></table></figure><p>小结：</p><p>左值引用，右值引用的语法意义：都是变量的别名</p><p>左值引用：就可以引用左值，也可以引用右值，如果引用右值，需要为const左值引用</p><p>右值引用：引用右值</p><ul><li>移动构造：参数类型为右值引用，提高拷贝的效率<ul><li>相对于拷贝构造，可以实现浅拷贝的情况下，不产生错误</li><li>右值引用指向的实体一般是将亡值，可以直接获取右值引用所指向的实体资源，不需要深拷贝</li></ul></li><li>移动赋值：参数类型为右值引用，也是浅拷贝，原理同上</li><li><code>move</code>：移动语义，将左值变为右值，使用时候需要注意保证属性被修改的左值在之后不会再用到</li></ul><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p><code>[捕捉列表](参数列表)mutable-&gt;返回值类型&#123;函数体&#125;</code></p><ul><li>捕捉列表（capture-list）：在lambda函数的开始位置，编译器根据[]来判断接下来 的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用。 </li><li>参数列表（parameters）：与普通函数的参数列表一致，如果不需要参数传递，则可以连同()一起省略 </li><li>mutable：默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。使用该修饰符时，参数列表不可省略(即使参数为空)。 </li><li>返回值类型（returntype）：用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分 可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导。 </li><li>函数体（statement）：在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量。 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">[] &#123;&#125;;</span><br><span class="line">[a, b]()<span class="keyword">mutable</span> &#123;a = <span class="number">100</span>; b = <span class="number">200</span>; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;a = <span class="number">1</span>; b = <span class="number">2</span>; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="built_in">func</span>(a, b);</span><br></pre></td></tr></table></figure><h2 id="捕捉列表"><a href="#捕捉列表" class="headerlink" title="捕捉列表"></a>捕捉列表</h2><ul><li>[var]：以值传递的方式捕捉变量var</li><li>[=]：表示以值传递的方式捕捉父类作用域的所有变量</li><li>[&amp;]：表示以引用传递的方式捕捉父作用域的所有变量，如果是传引用形式，不需要mutable也可以修改捕捉列表中的变量</li><li>[&amp;var]：以引用传递的方式捕捉变量var</li><li>[this]：以值传递方式捕捉当前的this指针</li><li>捕捉列表可以交叉使用</li><li>父类作用域不一定是直接父类作用域，嵌套的也可以</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//[=]以传值的形式捕捉父类作用域的所有变量</span></span><br><span class="line">[=](<span class="type">int</span> num)<span class="keyword">mutable</span>-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">  <span class="comment">//return a + b + c + num;</span></span><br><span class="line">  <span class="comment">//c还没有被定义，不能捕捉</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun2 = [&amp;](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">fun2</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了a以外其他变量都以值传递捕捉，a以引用传递捕捉</span></span><br><span class="line"><span class="comment">//错误写法[=, a]，都是值传递</span></span><br><span class="line"><span class="keyword">auto</span> fun3 = [=, &amp;a](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun4 = [&amp;, a](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lambda表达式不能相互赋值，但可以拷贝；可以吧lambda表达式赋给一个函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun1 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> fun2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">fun1 = fun2;<span class="comment">//赋值操作，不能执行</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun3</span><span class="params">(fun2)</span></span>;<span class="comment">//拷贝操作</span></span><br><span class="line"><span class="keyword">auto</span> fun4 = fun2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*fptr)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fptr2)</span></span>;</span><br><span class="line"></span><br><span class="line">fptr ptr;</span><br><span class="line"></span><br><span class="line">ptr = fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口不一致</span></span><br><span class="line"><span class="comment">//fptr2 ptr2 = fun1;</span></span><br></pre></td></tr></table></figure><h1 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h1><p>头文件thread</p><div class="table-container"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>thread</td><td>构造一个线程对象，没有关联任何线程函数，即没有启动任何线程</td></tr><tr><td>thread(fun, args1, args2, …)</td><td>构造一个线程对象，并关联线程函数fun，函数参数为args</td></tr><tr><td>get_id()</td><td>获取线程ID</td></tr><tr><td>joinable()</td><td>线程是否还在执行，joinable代表的是一个正在执行中的线程</td></tr><tr><td>join()</td><td>该函数调用后会阻塞线程，当该函数结束后，主线程继续执行</td></tr><tr><td>detach()</td><td>线程分离，把被创建的线程与线程对象分离</td></tr></tbody></table></div><p>RAII：资源获取立即初始化，在构造函数中初始化资源，在析构函数中销毁资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadMange</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ThreadMange</span>(thread&amp; t)</span><br><span class="line">: _thread(t)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ThreadMange</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_thread.<span class="built_in">joinable</span>())</span><br><span class="line">_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">thread&amp; _thread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//thread t1;</span></span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(r1)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(r2, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(r3, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadMange <span class="title">tm1</span><span class="params">(t1)</span></span>;</span><br><span class="line"><span class="function">ThreadMange <span class="title">tm2</span><span class="params">(t2)</span></span>;</span><br><span class="line"><span class="function">ThreadMange <span class="title">tm3</span><span class="params">(t3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*t1.join();</span></span><br><span class="line"><span class="comment">t2.join();</span></span><br><span class="line"><span class="comment">t3.join();*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要类的成员函数做线程函数，需要写完整的作用域，并且需要显示取地址，参数需要加上this所指的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::bfun&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;B::bfun, &amp;b)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数参数类型为引用，在线程中需要修改原是变量，则需要听过ref转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(fun, ref(a))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子性操作库（atomic）"><a href="#原子性操作库（atomic）" class="headerlink" title="原子性操作库（atomic）"></a>原子性操作库（atomic）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">sum2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">sum2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, num)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func, num)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个变量声明为原子类型变量之后，不需要对该变量加互斥锁，线程也能够对该变量互斥访问，可以根据<code>atomic</code>类模版，定义出需要的任意原子类型。</p><p>由于原子类型通常属于资源型数据，故在C++11中，标准库将拷贝构造，移动构造以及运算符重载默认置为<code>delete</code></p><h1 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h1><ol><li>mutex</li></ol><p>try_lock：非阻塞加锁操作，如果其他线程没有释放当前锁，则直接返回加锁失败结果</p><p>lock：阻塞加锁操作，如果其他线程没有释放当前锁，阻塞等待，直到其他线程释放当前锁</p><p>unlock：解锁</p><ol><li>recursive_mutex：递归上锁，允许对互斥量进行多次上锁，但解锁需要调用与上锁相同的递归深度</li><li>timed_mutex</li></ol><ul><li>try_lock_for：接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程 释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返 回 false。 </li><li>try_lock_until() ：接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期 间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得 锁），则返回 false。 </li></ul><ol><li>recursive_timed_mutex</li></ol><h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>lock_guard类模版通过RAII的方式对其管理的互斥量进行了封装，在需要加锁的地方，使用任意一个互斥体实例化一个lock_guard，调用其构造函数即上锁，在出作用域前，lock_guard对象要被销毁，会调用其析构函数而自动解锁，可以有效避免死锁问题。</p><p>缺陷：太过单一，用户无法对该锁进行控制</p><h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>相较于lock_guard有了更多的接口</p><p>上锁/解锁操作：lock、try_lock、try_lock_for、try_lock_until和unlock </p><p>修改操作：移动赋值、交换(swap：与另一个unique_lock对象互换所管理的互斥量所有权)、释放 (release：返回它所管理的互斥量对象的指针，并释放所有权) </p><p>获取属性：owns_lock(返回当前对象是否上了锁)、operator bool()(与owns_lock()的功能相同)、 mutex(返回当前unique_lock所管理的互斥量的指针)。</p><h1 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h1><ol><li><p>原子操作：指令不会被打断，线程安全操作，效率较高</p><p> atomic\<T\>：把T类型数据封装成原子操作</T\></p></li><li><p>加锁：通过多线程之间的加锁阻塞保证线程安全，效率较低，加锁解锁比较耗时（相对于原子操作）</p><p> mutex、recursive_mutex、timed_mutex、recursive_timed_mutex</p><p> lock：阻塞式加锁</p><p> unlock：解锁</p><p> try_lock：非阻塞式加锁</p></li></ol><p>lock_guard、unique_lock：RAII实现，通过对象的生命周期控制锁的生命周期：</p><p>构造函数-&gt;加锁、析构函数-&gt;解锁</p><p>不支持拷贝操作</p><h1 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h1><ul><li>throw：当问题出现时，程序会抛出一个异常，通过throw关键字来完成</li><li>catch：在想要处理问题的地方，通过异常处理程序捕获一场，catch用于捕获异常，可以有多个catch进行捕获</li><li>try：try代码块中的代码表示将被激活特定的异常</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">0</span>;<span class="comment">//抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//try：可能发生异常的代码放在这里</span></span><br><span class="line"><span class="built_in">fun2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">char</span> ch)</span><br><span class="line">&#123;<span class="comment">//捕获对应类型的异常</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch(char)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch(char*)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h2><p><strong>异常的抛出和匹配原则：</strong> </p><ol><li>异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。 </li><li>被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。 </li><li>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁。（这里的处理类似于函数的传值返回） </li><li>catch(…)可以捕获任意类型的异常，但是不知道异常错误是什么。 </li><li>实际中抛出和捕获的匹配原则有个例外，并不是类型完全匹配，可以抛出派生类对象，使用基类捕获。</li></ol><p><strong>在函数调用链中异常栈展开匹配原则：</strong> </p><ol><li>首先检查throw本身是否在try块内部，如果是再查找匹配的catch语句。如果有匹配的，则调到catch的地方进行处理。 </li><li>没有匹配的catch则退出当前函数栈，继续在调用函数的栈中进行查找匹配的catch。 </li><li>如果到达main函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的catch子句的过程称为栈展开。所以实际中一般都会加一个catch(…)捕获任意类型的异常，否则当有异常没捕 获，程序就会直接终止。 </li><li>找到匹配的catch子句并处理以后，会继续沿着catch子句后面继续执行</li></ol><p><strong>异常的重新抛出：</strong>有可能单个的catch不能完全处理异常，在进行一些矫正处理后，希望再交给更外层的调用链函数来处理，catch则可以通过重新抛出异常传递给更上层的函数进行处理</p><p><strong>异常安全：</strong></p><ul><li>构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化</li><li>析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等) </li><li>C++中异常经常会导致资源泄漏的问题，比如在new和delete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，而C++经常使用RAII来解决以上问题。</li></ul><p><strong>异常规范：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>; </span><br><span class="line"><span class="comment">// 这里表示这个函数只会抛出bad_alloc的异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>; </span><br><span class="line"><span class="comment">// 这里表示这个函数不会抛出异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure><h2 id="标准库中的异常体系"><a href="#标准库中的异常体系" class="headerlink" title="标准库中的异常体系"></a>标准库中的异常体系</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    arr.<span class="built_in">at</span>(<span class="number">10</span>) = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未知异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::execptiom</code>是所有标准C++异常的父类，用所有异常的根基类的引用或指针进行捕捉，可以匹配所有继承体系的所有类型，通过根基类虚函数重写，完成多态的逻辑，最终通过多态完成对异常的精准处理</p><h2 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h2><p><strong>优点：</strong></p><ol><li>异常对象定义好了，相比错误码的方式可以清晰准确的展示出错误的各种信息，甚至可以包含堆栈调用的信息，这样可以帮助更好的定位程序的bug。 </li><li>返回错误码的传统方式有个很大的问题是，在函数调用链中，深层的函数返回了错误，需要得层层返回错误，最外层才能拿到错误。</li><li>很多的第三方库都包含异常。</li><li>很多测试框架都使用异常，这样能更好的使用单元测试等进行白盒的测试。 </li><li>部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理。比如T&amp;operator这样的函数，如果pos越界了只能使用异常或者终止程序处理，没办法通过返回值表示错误。 </li></ol><p><strong>缺点：</strong></p><ol><li>异常会导致程序的执行流乱跳，并且非常的混乱，并且是运行时出错抛异常就会乱跳。会导致踪调试时以及分析程序时比较困难。 </li><li>异常会有一些性能的开销。但是在现代硬件速度很快的情况下，这个影响基本忽略不计。 </li><li>C++没有垃圾回收机制，资源需要自己管理，有了异常非常容易导致内存泄漏、死锁等异常安全问题，需要使用RAII来处理资源的管理问题。</li><li>C++标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱。 </li><li>异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func()、throw();的方式规范化。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;列表初始化&quot;&gt;&lt;a href=&quot;#列表初始化&quot; class=&quot;headerlink&quot; title=&quot;列表初始化&quot;&gt;&lt;/a&gt;列表初始化&lt;/h1&gt;&lt;p&gt;C++11：支持内置类型与自定义类型的列表初始化，其中自定义类型不是天然支持列表初始化，需要显示定义参数类型为&lt;code&gt;initiaizer_list&lt;/code&gt;的构造函数&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;A&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : _a(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    , _b(b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; _a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; _b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; arr[] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; c&amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; d = &amp;#123; &lt;span class=&quot;number&quot;&gt;1.2&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; arr1&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; arr2 = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pair&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; p = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; m = &amp;#123; &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A a = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;A &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从无序关联容器到哈希（及无序关联容器的模拟实现）</title>
    <link href="http://zhaozhuolin.com/2020/07/20200719.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200719.html</id>
    <published>2020-07-19T12:11:00.000Z</published>
    <updated>2023-05-07T11:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>基本使用与map相同，迭代器无反向迭代器，无序map，其体现在遍历时无序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testUMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">15</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">um[<span class="number">100</span>] = <span class="number">100</span>;<span class="comment">//插入</span></span><br><span class="line">um[<span class="number">15</span>] = <span class="number">15</span>;<span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line">um.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">2</span>;<span class="comment">//at无法插入，key不存在直接抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历无序</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator uit = um.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (uit != um.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; uit-&gt;first &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; uit-&gt;second &lt;&lt; endl;</span><br><span class="line">uit++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  uit = um.<span class="built_in">find</span>(<span class="number">100</span>);<span class="comment">//find找到返回指定位置迭代器，找不到则返回end迭代器</span></span><br><span class="line">cout &lt;&lt; um.<span class="built_in">count</span>(<span class="number">100</span>) &lt;&lt; endl;<span class="comment">//count返回元素个数，1或0</span></span><br><span class="line">cout &lt;&lt; uit-&gt;first &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; uit-&gt;second &lt;&lt; endl;</span><br><span class="line">uit = um.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; um.<span class="built_in">count</span>(<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (uit == um.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">99</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">48</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">27</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历无序</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::iterator uit = us.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (uit != us.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *uit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">uit++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="和有序容器的区别"><a href="#和有序容器的区别" class="headerlink" title="和有序容器的区别"></a>和有序容器的区别</h2><p>map, set, multi_map, multi_set：迭代器遍历有序，中序遍历；底层实现：红黑树；操作时间复杂度O(log<sub>2</sub>n)</p><p>unordered_map, unordered_set, unordered_multimap, unordered_multiset：</p><p>迭代器遍历无序，底层实现：哈希；操作时间复杂度O(1)</p><p>使用场景：</p><ol><li>对遍历顺序有要求：非unordered系列容器</li><li>对性能要求更高：unordered系列容器</li></ol><h1 id="底层结构：哈希结构"><a href="#底层结构：哈希结构" class="headerlink" title="底层结构：哈希结构"></a>底层结构：哈希结构</h1><p>通过构造一种存储结构，通过某种函数（hashFunc）使元素的存储位置和它的关键码之间能够建立一一映射的关系，那么在查找时就可以很快的找到该元素，一种以空间换时间的结构</p><p>映射关系：哈希函数</p><p>​        哈希：把元素/键值映射到空间的某一个位置</p><p>​        特点：</p><ol><li>映射位置范围小于等于空间范围</li><li>映射位置尽量均匀</li><li>映射关系尽量简单</li></ol><p>常用的哈希函数：</p><ol><li>除留余数法（通用）：元素/键值 % 空间的大小</li><li>直接定址法（只适合范围紧凑的数据，如字符）：线性函数，A * x(元素/键值) + (B)偏置</li></ol><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>不同的数据映射到同一个位置即为哈希冲突</p><p>解决哈希冲突问题：</p><ol><li><p>闭散列（开放定址法）</p><p> 线性探测、二次探测</p></li><li><p>开散列（拉链法，哈希桶）</p></li></ol><p>负载因子：实际存放的元素个数 / 空间大小（一般70%～80%）</p><p><strong>线性探测：</strong></p><ol><li>插入：<ol><li>通过哈希函数计算哈希位置</li><li>如果当前位置为空，则进行插入操作</li><li>如果位置不为空，则从当前位置开始，找到第一个空的位置，再进行插入操作</li></ol></li><li>查找：<ol><li>通过哈希函数计算哈希位置</li><li>查看当前位置的数据是否和查找的数据相同，如果相同，则查找结束</li><li>如果不相同，则从当前位置继续向后查找，直到找到了数据或者走到了空的位置，则查找结束</li></ol></li><li>删除：假删除，通过设置状态数据，来标记数据是否可用<ol><li>进行查找操作</li><li>如果找到需要删除的数据，则对待删除数据所在位置进行删除状态标记</li></ol></li></ol><blockquote><p><strong>二次探测：每次偏移的位置的长度为上一次的平方</strong></p></blockquote><p><strong>开散列：</strong></p><ol><li>增容：<ol><li>遍历旧表中的每一个元素</li><li>计算每一个元素在新表中的位置</li><li>把元素重新挂载到新表中的对应位置</li></ol></li><li>迭代器++：<ol><li>_next非空：更新到_next</li><li>_next为空：</li></ol></li></ol><p><code>HashTable</code>: K, V, KeyOfValue, HashFun</p><ul><li>K：数据键值</li><li>V：键值对应的value， <code>unordered_map</code>—&gt;pair<K, v>、<code>unordered_set</code>—-&gt;K</K,></li><li>KeyOfValue：获取value对应的键值</li><li>HashFun：把键值K转换成整形数据（非整形数类型的转换，非整数—&gt;映射—&gt;整数）</li><li>哈希表迭代器：前置声明，友元类声明</li><li>成员：节点，哈希表指针</li><li>++操作：<ul><li>next是否非空，不为空：更新到next节点；为空：<ul><li>首先通过kov获取对应键值</li><li>通过hashFun计算键值对应的整数值</li><li>通过整数值计算当前节点在哈希表中的位置</li><li>从上一步计算位置的下一个位置开始，寻找第一个非空练表的头节点</li><li>如果没有找到，更新为空指针</li></ul></li></ul></li><li>begin：第一个非空链表的头节点</li><li>end：空节点</li></ul><p>哈希表（开散列）：可以存放任意类型的数据，如果键值类型为非数值类型，可以通过hashFun转换为整数值</p><p>插入、查找、删除：</p><ul><li>首先进行的操作为：通过键值计算位置</li><li>然后进行类似单链表的操作</li></ul><h1 id="unordered-map与unordered-set的模拟实现"><a href="#unordered-map与unordered-set的模拟实现" class="headerlink" title="unordered_map与unordered_set的模拟实现"></a>unordered_map与unordered_set的模拟实现</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>unordered_map和unordered_set的底层均由同一个哈希表实现，本次实现使用开散列哈希桶的结构，其结构大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span></span><br><span class="line">&#123;</span><br><span class="line">V _value;</span><br><span class="line">HashNode&lt;V&gt;* _next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HashNode</span>(<span class="type">const</span> V&amp; val = <span class="built_in">V</span>())</span><br><span class="line">: _value(val)</span><br><span class="line">, _next(<span class="literal">nullptr</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//迭代器声明为友元类，原因是在迭代器类中，需要使用到哈希表来进行迭代器的自加操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">HashIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> HashIterator&lt;K, V, KeyOfValue, HF&gt; iterator;<span class="comment">//迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">CheckCapacity</span>();</span><br><span class="line"></span><br><span class="line">HF hf;</span><br><span class="line">KeyOfValue kov;</span><br><span class="line"><span class="type">size_t</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(value)) % _table.<span class="built_in">size</span>();<span class="comment">//计算当前元素对应的位置</span></span><br><span class="line"></span><br><span class="line">Node* cur = _table[idx];</span><br><span class="line"><span class="keyword">while</span> (cur)<span class="comment">//寻找是否有重复元素，重复则插入失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kov</span>(cur-&gt;_value) == <span class="built_in">kov</span>(value))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(value);<span class="comment">//头插</span></span><br><span class="line">cur-&gt;_next = _table[idx];</span><br><span class="line">_table[idx] = cur;</span><br><span class="line">_size++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span>；</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">size_t getNextSize(size_t n);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_size == _table.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newSize = <span class="built_in">getNextSize</span>(_size);<span class="comment">//获取下一个表的大小值</span></span><br><span class="line">vector&lt;Node*&gt; newTable;</span><br><span class="line">newTable.<span class="built_in">resize</span>(newSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历旧表中的非空单链表</span></span><br><span class="line">KeyOfValue kov;</span><br><span class="line">HF hf;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _table[i];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(cur-&gt;_value)) % newTable.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">cur-&gt;_next = newTable[idx];</span><br><span class="line">newTable[idx] = cur;</span><br><span class="line"></span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">_table[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">_table.<span class="built_in">swap</span>(newTable);<span class="comment">//交换新旧表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node*&gt; _table;</span><br><span class="line"><span class="type">size_t</span> _size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用序列容器vector来存放单链表表头，当遇到哈希冲突时，直接将插入元素头插在对应位置的单链表；其中K、V两个泛型参数在unordered_map中分别为K，<code>pair&lt;K, V&gt;</code>，在unordered_set中为K、K；泛型参数<code>KeyOfValue</code>则为不同的获取Key值的方法，通过仿函数对象来实现具体的方法</p><p>在unordered_map中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在unordered_set中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而泛型参数HF则为哈希函数，一般具有默认类型参数，也可指定，如在本次实现中为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashFunc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashFunc</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = s.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> seed = <span class="number">131</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * seed + (*str++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>哈希表的迭代器不能通过简单的指针来完成，必须对指针进行封装，封装成一个类，并开放begin，end，++等操作的接口，大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> HashIterator&lt;K, V, KeyOfValue, HF&gt; Self;</span><br><span class="line"><span class="keyword">typedef</span> HashTable&lt;K, V, KeyOfValue, HF&gt; HT;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HashIterator</span>(Node* node, HT* ht)</span><br><span class="line">: _node(node)</span><br><span class="line">, _ht(ht)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> _node-&gt;_value;&#125;</span><br><span class="line"></span><br><span class="line">V* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> &amp;_node-&gt;_value;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it)&#123;<span class="keyword">return</span> _node != it._node;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; it)&#123;<span class="keyword">return</span> _node == it._node;&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++()&#123;<span class="built_in">add</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;<span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="built_in">add</span>(); <span class="keyword">return</span> *tmp;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_next)</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KeyOfValue kov;</span><br><span class="line">HF hf;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(_node-&gt;_value)) % _ht-&gt;_table.<span class="built_in">size</span>();<span class="comment">//计算当前传入值对应的位置</span></span><br><span class="line">idx++;</span><br><span class="line"><span class="keyword">if</span> (idx == _ht-&gt;_table.<span class="built_in">size</span>())<span class="comment">//走到哈希表尾</span></span><br><span class="line">&#123;</span><br><span class="line">_node = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* cur = _ht-&gt;_table[idx];</span><br><span class="line"><span class="keyword">for</span> (; idx &lt; _ht-&gt;_table.<span class="built_in">size</span>(); idx++)<span class="comment">//找到下一个非空链表头</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ht-&gt;_table[idx])</span><br><span class="line">&#123;</span><br><span class="line">_node = _ht-&gt;_table[idx];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idx == _ht-&gt;_table.<span class="built_in">size</span>())<span class="comment">//检查是否已经遍历完成</span></span><br><span class="line">_node = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* _node;</span><br><span class="line">HT* _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，unordered_map和unordered_set的实现已经完成了大半，接下来创建这两个类分别对哈希表类进行封装即可</p><h2 id="unordered-set-1"><a href="#unordered-set-1" class="headerlink" title="unordered_set"></a>unordered_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span> = HashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Unordered_Set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> SetKeyOfValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> K&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, K, SetKeyOfValue, HF&gt;::iterator iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">end</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; value)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">insert</span>(value);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">erase</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashNode&lt;K&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">count</span>(key);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HashTable&lt;K, K, SetKeyOfValue, HF&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上，通过调用哈希表的不同接口，来实现unordered_set的各种功能</p><h2 id="unordered-map-1"><a href="#unordered-map-1" class="headerlink" title="unordered_map"></a>unordered_map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">HF</span> = HashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Unordered_Map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> MapKeyOfValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> value.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfValue, HF&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">end</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">insert</span>(value);&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)&#123;</span><br><span class="line">        pair&lt;iterator, <span class="type">bool</span>&gt; ret = _ht.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">erase</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashNode&lt;V&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">count</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfValue, HF&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p><a href="[https://github.com/Latsummer/FinishedProducts/tree/master/unordered_map%E4%B8%8Eset/unordered_map%E4%B8%8Eset](https://github.com/Latsummer/FinishedProducts/tree/master/unordered_map与set/unordered_map与set">unordered_map与unordered_set的模拟实现 - GitHub</a>)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;无序关联容器&quot;&gt;&lt;a href=&quot;#无序关联容器&quot; class=&quot;headerlink&quot; title=&quot;无序关联容器&quot;&gt;&lt;/a&gt;无序关联容器&lt;/h1&gt;&lt;h2 id=&quot;unordered-map&quot;&gt;&lt;a href=&quot;#unordered-map&quot; class=&quot;headerlink&quot; title=&quot;unordered_map&quot;&gt;&lt;/a&gt;unordered_map&lt;/h2&gt;&lt;p&gt;基本使用与map相同，迭代器无反向迭代器，无序map，其体现在遍历时无序&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;unordered_map&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testUMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	unordered_map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; um;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//插入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;at&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//at无法插入，key不存在直接抛异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//遍历无序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	unordered_map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator uit = um.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (uit != um.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		cout &amp;lt;&amp;lt; uit-&amp;gt;first &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;--&amp;gt;&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; uit-&amp;gt;second &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		uit++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  uit = um.&lt;span class=&quot;built_in&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//find找到返回指定位置迭代器，找不到则返回end迭代器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; um.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &amp;lt;&amp;lt; endl;&lt;span class=&quot;comment&quot;&gt;//count返回元素个数，1或0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; uit-&amp;gt;first &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;--&amp;gt;&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; uit-&amp;gt;second &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	uit = um.&lt;span class=&quot;built_in&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; um.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; (uit == um.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;()) &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>map和set的模拟实现</title>
    <link href="http://zhaozhuolin.com/2020/07/20200717.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200717.html</id>
    <published>2020-07-17T14:40:10.000Z</published>
    <updated>2023-05-07T11:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改造红黑树"><a href="#改造红黑树" class="headerlink" title="改造红黑树"></a>改造红黑树</h1><p>关联式容器存储的是K， V键值对，故在改造红黑树时，K为key类型，对于V来说，如果是set，则其为K类型，如果是map则为</p><p><code>pair&lt;K, V&gt;</code>，类型，除此之外，还需要一个仿函数类KeyOfValue来兼容map与set的大小比较，其迭代器也需要封装指针为一个类，迭代器的自加自减相当于红黑树的中序遍历</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> RBTIterator&lt;V&gt; Self;</span><br><span class="line"><span class="built_in">RBTIterator</span>(Node* node);</span><br><span class="line">  </span><br><span class="line">V&amp; <span class="keyword">operator</span>*();</span><br><span class="line"></span><br><span class="line">V* <span class="keyword">operator</span>-&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; it);</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++();</span><br><span class="line"></span><br><span class="line">Self <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">Self <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> RBNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> RBTIterator&lt;V&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RBTree</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> V&amp; val)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">iterator <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">leftMost</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">Node* <span class="title">rightMost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="map和set的实现"><a href="#map和set的实现" class="headerlink" title="map和set的实现"></a>map和set的实现</h1><p>通过封装红黑树类，传入仿函数类和具体类型，修改等操作调用红黑树的接口，遍历操作通过迭代器完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfValue&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt-&gt;<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">insert</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;iterator, <span class="type">bool</span>&gt; ret = _rbt.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">Find</span>(<span class="built_in">pair</span>&lt;K, V&gt;(key, <span class="built_in">V</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfValue&gt;::iterator iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">Find</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">insert</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">RBTree&lt;K, K, SetKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="GitHub链接"><a href="#GitHub链接" class="headerlink" title="GitHub链接"></a>GitHub链接</h1><p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/map%E5%92%8Cset%E5%AE%9E%E7%8E%B0">map和set的实现-GitHub</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;改造红黑树&quot;&gt;&lt;a href=&quot;#改造红黑树&quot; class=&quot;headerlink&quot; title=&quot;改造红黑树&quot;&gt;&lt;/a&gt;改造红黑树&lt;/h1&gt;&lt;p&gt;关联式容器存储的是K， V键值对，故在改造红黑树时，K为key类型，对于V来说，如果是set，则其为K类型，如果是map则为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pair&amp;lt;K, V&amp;gt;&lt;/code&gt;，类型，除此之外，还需要一个仿函数类KeyOfValue来兼容map与set的大小比较，其迭代器也需要封装指针为一个类，迭代器的自加自减相当于红黑树的中序遍历&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从AVL树到红黑树(的插入)</title>
    <link href="http://zhaozhuolin.com/2020/07/20200713.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200713.html</id>
    <published>2020-07-13T10:01:11.000Z</published>
    <updated>2023-05-07T11:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><ul><li>左右子树都是AVL树</li><li>左右子树高度差的绝对值不超过1（-1/0/1）（一般：右子树高度 - 左子树高度）</li><li>如果一棵二叉搜索树树高度平衡的，它就是AVL树。如果它有n个节点，其高度可保持在O(log<sub>2</sub>N)，搜索时间复杂度O(log<sub>2</sub>N)</li></ul><span id="more"></span><h2 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line">T _value;</span><br><span class="line"><span class="type">int</span> _bf;<span class="comment">//平衡因子</span></span><br><span class="line">AVLNode&lt;T&gt;* _left;</span><br><span class="line">AVLNode&lt;T&gt;* _right;</span><br><span class="line">AVLNode&lt;T&gt;* _parent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVLNode</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">: _value(val)</span><br><span class="line">, _bf(<span class="number">0</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><blockquote><p>插入节点后：必须要更新平衡因子</p><p>可能需要更新平衡因子的节点：</p><ol><li>新插入节点中所有足祖先节点</li><li>如果节点的子树高度发生变化，则需要更新</li></ol></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol><li><p>二叉搜索树的插入</p></li><li><p>从新插入的节点对应的父节点位置开始更新平衡因子</p></li><li><p>在第二步的过程中，平衡因子更新之后：</p><ol><li><p>平衡因子：0    —-&gt;     停止更新</p></li><li><p>平衡因子：-1/1    —-&gt;    继续向上更新</p></li><li><p>平衡因子：-2/2    —-&gt;    旋转</p><ol><li><p>单旋：</p><ol><li><p>左单旋：右边的右边高，<code>parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1</code></p><p> 修改链接：parent、subRL、subR</p><p> ​                    parent-&gt;_right : subRL、subR-&gt;left : parent</p><p> 更新平衡因子：parent、subR：0</p></li><li><p>右单旋：左边的左边高，<code>parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1</code></p><p> 修改链接：subL、subLR、parent</p><p> ​                    parent-&gt;left : subLR、subL-&gt;right : parent</p><p> 更新平衡因子：parent、subL：0</p></li></ol></li><li><p>双旋：</p><ol><li><p>左右双旋：左边的右边高，<code>parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1</code></p><p> 修改链接：subL、subLR、parent</p><p> ​        左旋：以subL为轴</p><p> ​        右旋：以parent为轴</p><p> 重新更新平衡因子：</p><p> if(subLR-&gt;bf == -1)</p><p> ​    subL-&gt;bf = 0, parent-&gt;bf = 1;</p><p> else if(subLR-&gt;bf == 1)</p><p> ​    subL-&gt;bf = -1, parent-&gt;bf = 0;</p></li><li><p>右左双旋右边的左边高，<code>parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1</code></p><p> 修改链接：parent、subRL、subR</p><p> ​        右旋：以subR为轴</p><p> ​        左旋：以parent为轴</p><p> ​    重新更新平衡因子：</p><p> ​    if(subRL-&gt;bf == 1)</p><p> ​        parent-&gt;bf = -1, subR-&gt;bf = 0;</p><p> else if(subRL-&gt;bf == -1)</p><p> ​        parent-&gt;bf = 0, subR-&gt;bf = 1;</p></li></ol></li></ol></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">parent = cur;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_value == val) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_value &lt; val) &#123;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_value &lt; val) &#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新 + 调整</span></span><br><span class="line"><span class="keyword">while</span> (parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.更新parent平衡因子</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">parent-&gt;_bf--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_bf++;</span><br><span class="line"><span class="comment">//2.判断是否需要继续更新</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>) &#123;<span class="comment">//被补齐了，parent的父节点左右子树高度未发生变化</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-1</span> || parent-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">cur = parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> || parent-&gt;_bf == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//调整</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//左边的左边高，右旋</span></span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//右边的右边高，左旋</span></span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//右边的左边高，右左双旋</span></span><br><span class="line">          Node* subR = parent-&gt;_right;</span><br><span class="line">          Node* subRl = subR-&gt;_left;</span><br><span class="line">          <span class="type">int</span> bf = subRL-&gt;_bf;</span><br><span class="line">          </span><br><span class="line"><span class="built_in">RotateR</span>(cur);</span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//调整平衡因子</span></span><br><span class="line">          <span class="keyword">if</span>(bf == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//subRL右子树高</span></span><br><span class="line">            subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">            parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(bf == <span class="number">-1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//subRL左子树高</span></span><br><span class="line">            parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">            subR-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//左边的右边高,左右双旋</span></span><br><span class="line"><span class="built_in">RotateL</span>(cur);</span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subR = parent-&gt;_right;</span><br><span class="line">Node* subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line">subR-&gt;_left = parent;</span><br><span class="line">parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subRL)</span><br><span class="line">subRL-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = subR;</span><br><span class="line">subR-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* g = parent-&gt;_parent;</span><br><span class="line">subR-&gt;_parent = g;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;_left == parent)</span><br><span class="line">g-&gt;_left = subR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">g-&gt;_right = subR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent-&gt;_parent = subR;</span><br><span class="line">parent-&gt;_bf = subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subL = parent-&gt;_left;</span><br><span class="line">Node* subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line">subL-&gt;_right = parent;</span><br><span class="line">parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subLR)</span><br><span class="line">subLR-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = subL;</span><br><span class="line">subL-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* g = parent-&gt;_parent;</span><br><span class="line">subL-&gt;_parent = g;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;_left == parent)</span><br><span class="line">g-&gt;_left = subL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">g-&gt;_right = subL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent-&gt;_parent = subL;</span><br><span class="line">parent-&gt;_bf = subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ol><li>每个节点不是红色就是黑色</li><li>根结点是黑色的</li><li>如果一个节点是红色的，则它的两个孩子节点是黑色的</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点</li><li>每个叶子节点都是黑色的（空节点也可）</li></ol><blockquote><p>根是黑色的</p><p>红色不能连续，黑色可以连续</p><p>每条路径上，黑色节点个数相同</p><p>最长路径是最短路径的两倍（最短：全黑；最长：红黑相间）</p></blockquote><p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/RBTree">一个红黑树的简单实现 - GitHub</a></p><h2 id="节点结构-1"><a href="#节点结构-1" class="headerlink" title="节点结构"></a>节点结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">BLACK,</span><br><span class="line">RED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBNode</span></span><br><span class="line">&#123;</span><br><span class="line">pair&lt;K, V&gt; _value;</span><br><span class="line">Color _color;</span><br><span class="line">RBNode&lt;K, V&gt; _parent;</span><br><span class="line">RBNode&lt;K, V&gt; _left;</span><br><span class="line">RBNode&lt;K, V&gt; _right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RBNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; value = <span class="built_in">pair</span>&lt;K, V&gt;())</span><br><span class="line">: _value(value)</span><br><span class="line">, _color(RED)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>不能改变当前结构中的黑色节点的个数，除了祖父节点为根节点的情况</p><ul><li>g：祖父</li><li>p：父亲</li><li>u：叔叔</li><li>cur：插入节点</li></ul><ol><li>搜索树的插入</li><li>判断是否需要调整：红色连续 </li></ol><ul><li>cur在p左边，叔叔存在且为红色，将p、u置为黑色，g为红色</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggnzzrztvuj31bo0toaak.jpg" alt="IMG_7063"></p><ul><li>cur在p左边，叔叔不存在，以g为轴心进行右旋，将g变红，将p变黑</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo07rykj1j31bo0to3z1.jpg" alt="IMG_7064"></p><ul><li>cur在p左边叔叔为黑色，以g为轴心进行右旋，将g变红，将p变黑</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo0c2ek0zj31bo0to0vf.jpg" alt="IMG_7065"></p><ul><li>cur在p右边，先以p为轴心左旋，交换p与cur指针，按照情况三处理</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo0qurg82j31bo0tot9k.jpg" alt="IMG_7066"></p><ul><li><strong>p在g右边，则操作完全相反</strong></li></ul><p>代码如下，其中旋转部分代码与AVL树相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_header-&gt;_parent == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//空树</span></span><br><span class="line">   Node* root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">   root-&gt;_color = BLACK;<span class="comment">//根为黑色</span></span><br><span class="line"></span><br><span class="line">   _header-&gt;_parent = root;</span><br><span class="line">   root-&gt;_parent = _header;</span><br><span class="line"></span><br><span class="line">   _header-&gt;_left = root;</span><br><span class="line">   _header-&gt;_right = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非空树</span></span><br><span class="line">  Node* cur = _header-&gt;_parent;</span><br><span class="line">  Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur)</span><br><span class="line">  &#123;</span><br><span class="line">   parent = cur;</span><br><span class="line">   <span class="keyword">if</span> (cur-&gt;_value.first == val.first)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (cur-&gt;_value.first &lt; val.first)</span><br><span class="line">    cur = cur-&gt;_right;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    cur = cur-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">  <span class="keyword">if</span> (parent-&gt;_value.first &lt; val.first)</span><br><span class="line">   parent-&gt;_right = cur;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   parent-&gt;_left = cur;</span><br><span class="line"></span><br><span class="line">  cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调整:修改颜色，旋转</span></span><br><span class="line">  <span class="keyword">while</span> (cur != _header-&gt;_parent &amp;&amp; cur-&gt;_parent-&gt;_color == RED)</span><br><span class="line">  &#123;</span><br><span class="line">   Node* p = cur-&gt;_parent;</span><br><span class="line">   Node* g = p-&gt;_parent;</span><br><span class="line">   <span class="keyword">if</span> (g-&gt;_left == p)</span><br><span class="line">   &#123;</span><br><span class="line">    Node* u = g-&gt;_right;</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u-&gt;_color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">     u-&gt;_color = p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line"></span><br><span class="line">     cur = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//ub不存在或u存在且为黑色</span></span><br><span class="line">     <span class="keyword">if</span> (cur == p-&gt;_right)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">RotateL</span>(p);</span><br><span class="line">      <span class="built_in">swap</span>(cur, p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//cur在p左边,右旋+修改颜色</span></span><br><span class="line">     <span class="built_in">RotateR</span>(g);</span><br><span class="line">     p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span><span class="comment">//p在g右边</span></span><br><span class="line">   &#123;</span><br><span class="line">    Node* u = g-&gt;_left;</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u-&gt;_color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">     u-&gt;_color = p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line">     cur = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span> (cur == p-&gt;_left)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">RotateR</span>(p);</span><br><span class="line">      <span class="built_in">swap</span>(cur, p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">RotateL</span>(g);</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line">     p-&gt;_color = BLACK;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将根置为黑</span></span><br><span class="line">  _header-&gt;_parent-&gt;_color = BLACK;</span><br><span class="line">  <span class="comment">//更新头的左右指针</span></span><br><span class="line">  _header-&gt;_left = <span class="built_in">leftMost</span>();</span><br><span class="line">  _header-&gt;_right = <span class="built_in">rightMost</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;左右子树都是AVL树&lt;/li&gt;
&lt;li&gt;左右子树高度差的绝对值不超过1（-1/0/1）（一般：右子树高度 - 左子树高度）&lt;/li&gt;
&lt;li&gt;如果一棵二叉搜索树树高度平衡的，它就是AVL树。如果它有n个节点，其高度可保持在O(log&lt;sub&gt;2&lt;/sub&gt;N)，搜索时间复杂度O(log&lt;sub&gt;2&lt;/sub&gt;N)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
