<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小赵的学习笔记</title>
  
  
  <link href="http://zhaozhuolin.com/atom.xml" rel="self"/>
  
  <link href="http://zhaozhuolin.com/"/>
  <updated>2023-05-08T14:01:00.954Z</updated>
  <id>http://zhaozhuolin.com/</id>
  
  <author>
    <name>Morgan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust-变量、函数与控制流</title>
    <link href="http://zhaozhuolin.com/2023/05/20230507.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230507.html</id>
    <published>2023-05-07T11:20:01.000Z</published>
    <updated>2023-05-08T14:01:00.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-hello-world-开始"><a href="#从-hello-world-开始" class="headerlink" title="从 hello world 开始"></a>从 hello world 开始</h1><p>创建一个 <code>main.rs</code> 文件，写入以下内容</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用以下命令进行编译运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><ul><li>也可使用<code>Cargo</code>工具进行构建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo new  <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="comment">#这将会创建如下结构</span></span><br><span class="line"><span class="variable">$&#123;project_name&#125;</span></span><br><span class="line">src/main.rs</span><br><span class="line">Cargo.toml</span><br></pre></td></tr></table></figure><span id="more"></span><p>其中，<code>toml</code>文件内容如下</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;project_name&quot;</span> <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#项目版本</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#Rust版本，当前为2015 2018 2021，默认为2015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> <span class="comment">#依赖的包</span></span><br></pre></td></tr></table></figure><p>在 <code>src/main.rs</code> 中写入内容， 使用<code>cargo build/cargo build --release</code> 进行构建，编译产物将会放在<code>target/debug/$&#123;project_name&#125; or target/release/$&#123;project_name&#125;</code>下，也可使用<code>cargo run</code>直接编译运行，也可使用<code>cargo check</code>来进行编译检查</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>变量与可变性</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">//不可变</span></span><br><span class="line">x = <span class="number">6</span>; <span class="comment">//编译失败</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">6</span>; <span class="comment">//可变</span></span><br><span class="line">y = <span class="number">6</span>; <span class="comment">//正确的，没问题的</span></span><br></pre></td></tr></table></figure><ul><li>常量</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SOME_VALUE: <span class="type">u32</span> = <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>常量使用<code>const</code>关键字进行声明，常量可以在任何作用域中声明，并且声明常量时<strong>必须注明值的类型</strong></p><ul><li>隐藏</li></ul><p>当定义多个同名的变量时，只有之前的变量都会被最后一次定义的变量隐藏，直到最后一次定义的变量作用于结束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码，首先将<code>x</code>绑定到值<code>5</code>上， 接着通过<code>let x = </code>创建了新的变量<code>x</code>，获取初始值并加一，此时<code>x</code>的值变为<code>6</code>，接着在花括号创建的作用于内，<code>x</code>又被隐藏了一次，此时<code>x</code>的值为12，在作用于结束时，隐藏也结束了，<code>x</code>又变回6，因此以上程序输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.31s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure><p>隐藏实际上是创建了一个新的同名变量，可以改变变量值类型，并复用这个名字，而<code>mut</code>关键字无法做到这一点，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二次为数字类型，使用隐藏可以做到这一点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二句则尝试讲一个数字类型赋值给一个字符串类型的变量，此时编译会失败</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每一个值都属于某一个数据类型，这将高速Rust编译器它被指定为何种数据，一遍明确数据处理方式，存在两类数据源类型子集：<em>标量</em>与<em>复合</em></p><p>通常编译器可以自动推导数据类型，不过某些情况下需要显示的指定数据类型，例如数据类型可能有多种情况时，例如将字符串转为数字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number !&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>代表单独一个值，Rust中有四种基本标量类型：整形、浮点型、布尔型以及字符串类型</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>默认类型为<code>i32</code></p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>而对于数字面值，允许使用类型后缀，例如<code>64u8</code>为<code>u8</code>类型的64，也允许使用<code>_</code>下划线作为分隔符，例如<code>1_000</code>等价于<code>1000</code></p><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr><tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr><tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr><tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (单字节字符)(仅限于<code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><blockquote><p>关于整型溢出，Debug模式下构建的二进制，在发生溢出时会panic，Release模式下构建的二进制会进行二进制补码操作，来绕回最小值，如256+1 &#x3D; 0</p><p>对于整型溢出，可采用以下方式显示处理</p><ul><li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li><li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li><li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li><li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li></ul></blockquote><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p><code>f32</code>与<code>f64</code>，分别占32位于64位，默认为<code>f64</code>，浮点型数据都是有符号的</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br></pre></td></tr></table></figure><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>关键字为<code>char</code>，类型大小为4个字节，并代表了一个Unicode标量值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>可将多个值组合成一个类型，存在两种原生的复合类型：元组与数组</p><h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><p>将多个其他类型的值组合仅一个复合类型，元组长度固定，一旦声明，其长度不会变化</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当想从元组中获取单个值时， 可以使用模式匹配来结构元组值，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="comment">//创建了 x, y, z 来将 tup 分成了三个变量，</span></span><br></pre></td></tr></table></figure><p>也可使用<code>.</code>来进行访问，例如<code>tup.0</code>即为第一个值<code>500</code></p><p>不带任何值的元组有个特殊的名称，叫做 <strong>单元</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。<strong>如果表达式不返回任何其他值，则会隐式返回单元值。</strong></p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组中的每个元素类型必须相同，且数组的长度是固定的，数组在栈上分配空间</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">array2</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">//5个i32类型数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = [<span class="number">3</span>; <span class="number">5</span>];<span class="comment">//标识数组中有 5 个 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = array[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;number is &#123;one&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="函数与控制流"><a href="#函数与控制流" class="headerlink" title="函数与控制流"></a>函数与控制流</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用关键字<code>fun</code>声明，函数名与变量名使用Unix风格，小写字母，并使用下换线分割单词</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。</strong></p><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数必须声明参数类型，多个参数使用逗号分割</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><ul><li><strong>语句</strong> 执行一些操作但不返回值的指令，以分号结尾</li><li><strong>表达式</strong> 计算并产生一个值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>; <span class="comment">//语句不会返回任何值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = (<span class="keyword">let</span> <span class="variable">c</span> = <span class="number">2</span>);<span class="comment">//编译会失败 let c = 2 不会返回值</span></span><br></pre></td></tr></table></figure><p>在rust中，函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">1</span>;</span><br><span class="line">    b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时 a = 4</span></span><br></pre></td></tr></table></figure><h3 id="具有返回值的函数"><a href="#具有返回值的函数" class="headerlink" title="具有返回值的函数"></a>具有返回值的函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ret</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">ret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a><code>if</code>表达式</h3><p><strong><code>if</code>表达式使用的值必须为<code>bool</code>类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">5</span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &#123; <span class="comment">//不能这样使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>也可在<code>let</code>中使用，但是需要每个分支都必须是相同的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">flag</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="number">1</span>&#125;; <span class="comment">//可以</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num2</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;one&quot;</span>&#125; <span class="comment">//不行</span></span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h4><p>无条件的循环，可以使用<code>break</code>从循环跳出，同时可以返回一个值，也可以使用<code>continue</code>跳过循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;loopping !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> cnt * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res = 200</span></span><br></pre></td></tr></table></figure><p><code>break</code>和<code>continue</code>仅能控制当前的循环，对于嵌套的循环，可以配合标签一起使用来控制循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">&#x27;loop_start</span>&#x27;: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cnt = &#123;cnt&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;loop_start</span>&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;End cnt = &#123;cnt&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="while条件循环"><a href="#while条件循环" class="headerlink" title="while条件循环"></a><code>while</code>条件循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> num != <span class="number">0</span> &#123;</span><br><span class="line">num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for遍历集合"><a href="#for遍历集合" class="headerlink" title="for遍历集合"></a><code>for</code>遍历集合</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">one</span> <span class="keyword">in</span> a &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;one&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从-hello-world-开始&quot;&gt;&lt;a href=&quot;#从-hello-world-开始&quot; class=&quot;headerlink&quot; title=&quot;从 hello world 开始&quot;&gt;&lt;/a&gt;从 hello world 开始&lt;/h1&gt;&lt;p&gt;创建一个 &lt;code&gt;main.rs&lt;/code&gt; 文件，写入以下内容&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;使用以下命令进行编译运行&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rustc main.rs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello, world!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;也可使用&lt;code&gt;Cargo&lt;/code&gt;工具进行构建&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cargo new  &lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#这将会创建如下结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	src/main.rs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Cargo.toml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CMake语法小结</title>
    <link href="http://zhaozhuolin.com/2023/03/20230318.html"/>
    <id>http://zhaozhuolin.com/2023/03/20230318.html</id>
    <published>2023-03-18T12:55:09.000Z</published>
    <updated>2023-05-07T11:15:56.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h3><p><code>PROJECT(name)</code>指定工程名称， 默认支持所有语言</p><p><code>PROJECT(name CXX)</code>指定工程名称， 支持C++</p><p>会隐式定义两个变量</p><ul><li>${name}_BINARY_DIR</li><li>${name}_SOURCE_DIR</li></ul><p>修改工程名时会将这两个变量修改，可通过预定义两个变量<code>PROJECT_BINARY_DIR</code>以及<code>PROJECT_SOURCE_DIR</code>解决该问题</p><h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h3><p>设定值，<code>SET(SRC_LIST main.cpp a.cpp b.cpp)</code>，即设定了<code>SEC_LIST</code>的值</p><h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h3><p>输出自定义的信息，主要有三种</p><ul><li>SEND_ERROR，产生错误生成过程被跳过</li><li>STAUS，显示普通的消息</li><li>FATAL_ERROR，终止cmake过程</li></ul><span id="more"></span><h3 id="ADD-EXECUTABLE"><a href="#ADD-EXECUTABLE" class="headerlink" title="ADD_EXECUTABLE"></a>ADD_EXECUTABLE</h3><p>生成可执行文件<code>ADD_EXECUTABLE(target src)</code></p><h3 id="ADD-SUBDIRECTORY"><a href="#ADD-SUBDIRECTORY" class="headerlink" title="ADD_SUBDIRECTORY"></a>ADD_SUBDIRECTORY</h3><ul><li>添加存放源文件的子目录，并可指定中间二进制与目标二进制的存放位置</li><li><code>EXECULDE_FORM_ALL</code>可将参数从编译中排除</li><li><code>ADD_SUBDIRECTORY(src bin)</code><ul><li>将src目录加入工程并指定编译输出（包含中间结果）路径为bin目录</li><li>如果不进行 bin 目录指定， 那编译结果（包含中间文件）将会存放在指定的 执行cmake命令目录下的src</li></ul></li></ul><h3 id="关于更改二进制保存路径"><a href="#关于更改二进制保存路径" class="headerlink" title="关于更改二进制保存路径"></a>关于更改二进制保存路径</h3><ul><li><code>SET(EXECUTABLE_OUTPUT_PATH $(PROJECT_BINARY_DIR)/bin)</code></li><li><code>SET(LIBRARY_OUTPUT_PATH $(PROJECT_BINARY_DIR)/lib)</code></li></ul><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol><li>变量使用<code>$&#123;&#125;</code>取值，<strong>但在 IF 语句中直接使用变量名</strong></li><li>指令中的参数需使用<code>()</code>括起来，参数之间使用空格或分号分隔</li><li>指令大小写无关</li><li>如果参数中包含空格，则需要将参数使用双引号包括</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>INSTALL：安装指令，包括二进制，动态库，静态库以及文件，目录，脚本等</p><p>CMAKE_INSTALL_PREFIX：–prefix</p></blockquote><ul><li>安装文件：<code>INSTALL(FILES file1 file2 DESTINATION dst_dir)</code>，将<code>file1</code>以及<code>file2</code>安装到<code>dest_dir</code>中，其中<code>FILES</code>为文件，<code>DESTINATION </code>一般为：<ul><li>绝对路径</li><li>相对路径，即为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;DESTINATION&#125;</code>，<code>CMAKE_INSTALL_PREFIX</code>一般默认为<code>/usr/local/</code>，可使用<code>cmake -DCMAKE_INSTALL_PREFIX=/usr</code>指定该变量的值</li></ul></li><li>安装脚本：<code>INSTALL(PROGRAMS abc.sh bin)</code>，<code>PROGRAMS</code> 为非目标文件的可执行程序安装</li><li>安装目录：<ul><li>直接在需要安装的目录内创建CMakeList.txt，在其内写INSTALL file</li><li><code>INSTALL(DIRECTORY dir/ DESTINATION dst_dir)</code>：若为<code>dir/</code>则表示将<code>dir</code>目录下所有内容安装到<code>dst_dir</code>下，若为<code>dir</code>则表示将<code>dir</code>目录本身安装到<code>dst_dir</code></li></ul></li><li>安装库文件：<code>INSTALL(TARGET bin_name lib_name_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</code>，安装二进制，静态或动态库均需要使用<code>TARGET</code>，<code>ARCHIVE</code>特指静态库，<code>LIBRARY</code>特指动态库，<code>RUNTIME</code>特指可执行的目标二进制</li></ul><h2 id="构建静态库与动态库"><a href="#构建静态库与动态库" class="headerlink" title="构建静态库与动态库"></a>构建静态库与动态库</h2><p><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></p><ul><li>lib_name：库名称</li><li>SHARED：表示生成动态库，STATIC表示生成静态库</li><li>LIB_SRC：源文件</li></ul><blockquote><p>同时构建静态库与动态库的方式：</p><ol><li><p>使用两个名字，例如</p><ul><li><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></li><li><code>ADD_LIBRARY(lib_name_static STATIC $&#123;LIB_SRC&#125;)</code></li></ul></li><li><p>使用<code>SET_TARGET_PROPERTIES</code>，设置输出名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIB_NAME_SRC lib_src.cpp)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name_static STATIC <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">//重命名lib_name_static为lib_name</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">//在构建新的目标时，会尝试清理掉其他使用使用这个名称的库，例如构建lib_name.so时会清除掉lib_name.a</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name SHARED <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="动态库版本号设定"><a href="#动态库版本号设定" class="headerlink" title="动态库版本号设定"></a>动态库版本号设定</h3><p><code>SET_TARGET_PROPERTIES(lib_name PROPERTIES VERSION 1.2 SOVERSION 1)</code>，其中：</p><ul><li>VERSION：动态库版本</li><li>SOVERSION：API版本</li></ul><h2 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h2><p><code>INCLUDE_DIRECTORIES(head_path)</code>，指定头文件路径</p><p><code>LINK_DIRECTORIES(lib_path)</code>，指定库路径</p><p><code>TARGET_LINK_LIBRARIES(bin_name lib_name)</code>，指定二进制<code>lib_name</code>要链接的库文件</p><h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><ul><li><code>CMAKE_INCLUDE_PATH</code>，头文件路径</li><li><code>CMAKE_LIBRARY_PATH</code>，库文件路径</li><li><code>CMAKE_BUILD_TYPE</code>，release or debug等</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h1&gt;&lt;h2 id=&quot;关键字&quot;&gt;&lt;a href=&quot;#关键字&quot; class=&quot;headerlink&quot; title=&quot;关键字&quot;&gt;&lt;/a&gt;关键字&lt;/h2&gt;&lt;h3 id=&quot;PROJECT关键字&quot;&gt;&lt;a href=&quot;#PROJECT关键字&quot; class=&quot;headerlink&quot; title=&quot;PROJECT关键字&quot;&gt;&lt;/a&gt;PROJECT关键字&lt;/h3&gt;&lt;p&gt;&lt;code&gt;PROJECT(name)&lt;/code&gt;指定工程名称， 默认支持所有语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PROJECT(name CXX)&lt;/code&gt;指定工程名称， 支持C++&lt;/p&gt;
&lt;p&gt;会隐式定义两个变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${name}_BINARY_DIR&lt;/li&gt;
&lt;li&gt;${name}_SOURCE_DIR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改工程名时会将这两个变量修改，可通过预定义两个变量&lt;code&gt;PROJECT_BINARY_DIR&lt;/code&gt;以及&lt;code&gt;PROJECT_SOURCE_DIR&lt;/code&gt;解决该问题&lt;/p&gt;
&lt;h3 id=&quot;SET关键字&quot;&gt;&lt;a href=&quot;#SET关键字&quot; class=&quot;headerlink&quot; title=&quot;SET关键字&quot;&gt;&lt;/a&gt;SET关键字&lt;/h3&gt;&lt;p&gt;设定值，&lt;code&gt;SET(SRC_LIST main.cpp a.cpp b.cpp)&lt;/code&gt;，即设定了&lt;code&gt;SEC_LIST&lt;/code&gt;的值&lt;/p&gt;
&lt;h3 id=&quot;MESSAGE关键字&quot;&gt;&lt;a href=&quot;#MESSAGE关键字&quot; class=&quot;headerlink&quot; title=&quot;MESSAGE关键字&quot;&gt;&lt;/a&gt;MESSAGE关键字&lt;/h3&gt;&lt;p&gt;输出自定义的信息，主要有三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SEND_ERROR，产生错误生成过程被跳过&lt;/li&gt;
&lt;li&gt;STAUS，显示普通的消息&lt;/li&gt;
&lt;li&gt;FATAL_ERROR，终止cmake过程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://zhaozhuolin.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="cmake" scheme="http://zhaozhuolin.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://zhaozhuolin.com/2021/03/20210312.html"/>
    <id>http://zhaozhuolin.com/2021/03/20210312.html</id>
    <published>2021-03-12T05:08:09.000Z</published>
    <updated>2023-05-07T11:18:08.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的构成"><a href="#图的构成" class="headerlink" title="图的构成"></a>图的构成</h1><p><strong>顶点集合</strong>+<strong>边的集合</strong>：<code>G = (V, E)</code>，顶点集合<code>V = &#123;x | x属于某个数据对象及&#125;</code>是有穷非空集合</p><ul><li><p><code>E = &#123;(x, y) | x, y属于V&#125;</code>或者<code>E = &#123;&lt;x, y&gt; | x, y属于V &amp;&amp; Path(x, y)&#125;</code>是顶点间关系的有穷集合，也叫边集合</p></li><li><p><code>(x, y)</code>表示x到y的一条双向通道，即<code>(x, y)</code>是无方向的，<code>Path(x, y)</code>表示从x到y的一条单向通路，即<code>Path(x, y)是有方向的</code></p></li></ul><p>顶点和边：图中节点成为顶点，第i个顶点记作vi， 两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中第k条边记作ek，<code>ek = (vi, vj)</code>或<code>ek = &lt;vi, vj&gt;</code></p><ul><li>在有向图中，顶点对<code>&lt;x, y&gt;</code>是有序的，顶点对<code>&lt;x, y&gt;</code>称为顶点x到顶点y的一条边(弧)，<code>&lt;x, y&gt;</code>和<code>&lt;y ,x&gt;</code>是两条不同的边，如G3、G4</li><li>在无向图中，顶点对(x, y)是无序的，顶点对(x,y) 称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，如G1、G2</li><li>注意：<strong>无向边<code>(x, y)</code>等于有向边<code>&lt;x, y&gt;</code>和<code>&lt;y, x&gt;</code></strong></li></ul><span id="more"></span><p><em>可以表示</em>：社交关系</p><ul><li>社交关系中，每个人就是一个顶点，两个人是好友，他们之间就有了边，那么边的权值可以是他们的亲密度</li><li>无向图：QQ、微信类似的社交关系可以被看作是无向图（强社交关系，熟人社交）</li><li>有向图：微博（关注的关系）、抖音 （弱社交关系，陌生人社交、粉丝社交）</li><li>也可以用来表示地图（导航路线选择），网络连接（路由器选择）</li><li>vertex 顶点、edge 边、weight 权值</li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ol><li>完全图（即所有顶点相连接）：在有n个顶点的无向图中，若有<code>n * (n-1)/2</code>条边，即<em>任意两个顶点之间有且仅有一条边</em>，则称此图为<strong>无向完全图</strong>，如G1；在n个顶点的有向图中，若有<code>n * (n-1)</code>条边，即<em>任意两个顶点之间有且仅有方向</em> 相反的边，则称此图为<strong>有向完全图</strong>，如G4。</li><li>邻接顶点：在无向图中G中，若(u, v)是E(G)中的一条边，则称u和v互为邻接顶点，并称边(u,v)依附于顶点u 和v；在有向图G中，若是E(G)中的一条边，则称顶点u邻接到v，顶点v邻接自顶点u，并称边与 顶点u和顶点v相关联。</li><li>顶点的度：<u>顶点v的度是指与它相关联的边的条数</u>，记作<code>deg(v)</code>。在有向图中，顶点的度等于该顶点的入度与 出度之和，其中顶点v的入度是以v为终点的有向边的条数，记作<code>indev(v)</code>;顶点v的出度是以v为起始点的有向 边的条数，记作<code>outdev(v)</code>。因此：<code>dev(v) = indev(v) + outdev(v)</code>。注意：对于无向图，顶点的度等于该顶 点的入度和出度，即<code>dev(v) = indev(v) = outdev(v)</code>。</li><li>路径：在图<code>G = (V， E)</code>中，若从顶点vi出发有一组边使其可到达顶点vj，则称顶点vi到顶点vj的顶点序列为从 顶点vi到顶点vj的路径。</li><li>路径长度：对于不带权的图，一条路径的路径长度是指该路径上的边的条数；对于带权的图，一条路 径的路 径长度是指该路径上各个边权值的总和。</li></ol><p><img src="/2021/03/20210312/008eGmZEly1gpljuxnpgij30k00i1aby.jpg" alt="截屏2021-04-16 14.04.25"></p><ol><li>简单路径与回路：若路径上各顶点v1，v2，v3，…，vm均不重复，则称这样的路径为简单路径。若路 径上 第一个顶点v1和最后一个顶点vm重合，则称这样的路径为回路或环。即路径不重复为简单路径，重复则为回路</li><li>子图：某个图的一个部分（一部分边、一部分顶点等）称为其的子图</li><li>连通图：在<strong>无向图</strong>中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。如果图中任意一 对顶点 都是连通的，则称此图为连通图。（连通图不一定是完全图，但完全图一定是连通图，对连通图来说，仅需有路径即可，而完全图则要求两顶点邻接）</li><li>强连通图：在<strong>有向图</strong>中，若在每一对顶点vi和vj之间都存在一条从vi到vj的路径，也存在一条从vj到 vi的路 径，则称此图是强连通图</li><li>生成树（用最少的边把图连通）：一个连通图的最小连通子图称作该图的生成树。有n个顶点的连通图的生成树有n个顶点和n - 1条边。</li></ol><ul><li>图和树的区别：<ul><li>树可以认为是特殊的图，图不一定是树</li><li>联通图，且不带环（没有回路），就可以认为是树</li></ul></li></ul><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>保存节点以及边的关系</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>因为节点与节点之间的关系就是连通与否，即为0或者1，因此邻接矩阵(二维数组)即是：先用一个数组将顶点保存，然后采用矩阵来表示节点与节点之间的关系。</p><p><img src="/2021/03/20210312/008eGmZEly1gplp3axgjsj306n06wjrm.jpg" alt="截屏2021-04-16 17.05.50"></p><p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下<br>$$<br>edge &#x3D; \left[ \begin{matrix}  &amp; A &amp; B &amp; C &amp; D \ A &amp; 0 &amp; 1 &amp; 0 &amp; 1 \ B &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ C &amp; 0 &amp; 1 &amp; 0 &amp; 1 \ D &amp; 1 &amp; 0 &amp; 1 &amp; 0 \end{matrix} \right]<br>$$<br><img src="/2021/03/20210312/008eGmZEly1gpltlbqflfj305i098jrl.jpg" alt="截屏2021-04-16 19.41.36"></p><p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下<br>$$<br>edge &#x3D; \left[ \begin{matrix}  &amp; A &amp; B &amp; C  \ A &amp; 0 &amp; 1 &amp; 0 \ B &amp; 1 &amp; 0 &amp; 1 \ C &amp; 0 &amp; 0 &amp; 0\end{matrix} \right]<br>$$</p><ul><li>无向图的邻接矩阵是对称的，第i行(列)元素之和，就是顶点i的度。有向图的邻接矩阵则不一定是对称 的，第i行(列)元素之后就是顶点i 的出(入)度</li><li>如果边带有权值，并且两个节点之间是连通的，上图中的边的关系就用权值代替，如果两个顶点不通， 则使用无穷大代替</li><li>用邻接矩阵存储图的有点是能够快速知道两个顶点是否连通，缺陷是如果顶点比较多，边比较少时，矩 阵中存储了大量的0成为系数矩阵，比较浪费空间，并且要求两个节点之间的路径不是很好求。</li></ul><p><img src="/2021/03/20210312/008eGmZEly1gpluoyfacuj30m409f406.jpg" alt="截屏2021-04-16 20.18.53"></p><h3 id="邻接矩阵代码实现"><a href="#邻接矩阵代码实现" class="headerlink" title="邻接矩阵代码实现"></a>邻接矩阵代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vertex 顶点</span></span><br><span class="line"><span class="comment">//edge 边</span></span><br><span class="line"><span class="comment">//weight 权值</span></span><br><span class="line"><span class="comment">//matrix矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> matrix</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        &#123;</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _matrex.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                _matrex[i].<span class="built_in">resize</span>(n, <span class="built_in">W</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;非法顶点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            _matrex[srcIndex][dstIndex] = w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">                _matrex[dstIndex][srcIndex] = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;vector&lt;W&gt; &gt; _matrex;     <span class="comment">//表示邻接矩阵的边</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>使用数组表示顶点的集合，使用链表表示边的关系。</p><ul><li>图为无向图的邻接表存储</li></ul><p><img src="/2021/03/20210312/008eGmZEly1gpn1zc5fnyj30ir08adgk.jpg" alt="截屏2021-04-17 21.17.19"></p><ul><li>注意：无向图中同一条边在邻接表中出现了两次。如果想知道顶点vi的度，只需要知道顶点vi边链表集合中结点的数目即可</li><li>有向图则添加一个边的集合或者反向添加一次</li></ul><h2 id="邻接表的代码实现"><a href="#邻接表的代码实现" class="headerlink" title="邻接表的代码实现"></a>邻接表的代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> table</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> _srcIndex;</span><br><span class="line">        <span class="type">int</span> _dstIndex;</span><br><span class="line">        <span class="type">const</span> W&amp; _w;</span><br><span class="line"></span><br><span class="line">        EdgeNode&lt;W&gt;* _next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        &#123;</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _linkTable.<span class="built_in">resize</span>(n, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;非法顶点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">            node-&gt;_srcIndex = srcIndex;</span><br><span class="line">            node-&gt;_dstIndex = dstIndex;</span><br><span class="line">            node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//挂起头</span></span><br><span class="line">            node-&gt;_next = _linkTable[srcIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">            _linkTable[srcIndex] = node;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">                node-&gt;_srcIndex = dstIndex;</span><br><span class="line">                node-&gt;_dstIndex = srcIndex;</span><br><span class="line">                node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//挂起头</span></span><br><span class="line">                node-&gt;_next = _linkTable[dstIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">                _linkTable[dstIndex] = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;EdgeNode&lt;W&gt;*&gt; _linkTable;<span class="comment">//邻接表</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历 一次。”遍历”即对结点进行某种操作的意思</p><h2 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h2><p>对邻接矩阵，深度优先可是使用递归的方式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _DFS(<span class="type">int</span> srcIndex, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; _vertexs[srcIndex] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; srcIndex &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;<span class="comment">//输出当前节点</span></span><br><span class="line">  visited[srcIndex] = <span class="literal">true</span>;<span class="comment">//标记当前节点已访问</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;<span class="comment">//访问当前节点的相邻顶点</span></span><br><span class="line">    <span class="keyword">if</span>(_matrex[srcIndex][i] != <span class="built_in">W</span>() &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">      _DFS(i, visited);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">  _DFS(srcIndex, visited);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h2><p>对邻接矩阵，广度优先可以使用队列实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line"></span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(srcIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; _vertexs[front] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; front &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    <span class="comment">//好友入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(visited[i] == <span class="literal">false</span> &amp;&amp; _matrex[front][i] != <span class="built_in">W</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>连通图中的每一棵生成树，都是原图的一个极大无环子图，即：从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成一条回路。 </p><p>若连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边。因此构造最小生成树的准则有三条：</p><ol><li>只能使用图中的边来构造最小生成树 </li><li>只能使用恰好n-1条边来连接图中的n个顶点</li><li>选用的n-1条边不能构成回路</li></ol><p>构造最小生成树的方法：<strong>Kruskal算法</strong>和<strong>Prim算法</strong>。</p><ul><li>这两个算法都采用了<strong>逐步求解的贪心策略</strong>。 贪心算法：是指在问题求解时，总是做出当前看起来最好的选择。也就是说贪心算法做出的不是整体最优的选择，而是某种意义上的局部最优解。贪心算法不是对所有的问题都能得到整体最优解。</li></ul><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><ol><li><p>任给一个有n个顶点的连通网络<code>N=&#123;V,E&#125;</code></p></li><li><p>首先构造一个由这n个顶点组成、不含任何边的图<code>G=&#123;V,NULL&#125;</code>，其中每个顶点自成一个连通分量</p></li><li><p>接着不断从E中取出权值最小的一条边(若有多条任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。</p></li><li><p>如此重复，直到所有顶点在同一个连通分量上为止。</p></li></ol><ul><li>核心：每次迭代时，选出一条具有最小权值，且两端点不在同一连通分量上的边，加入生成树。</li></ul><blockquote><p>如何判断选出一条边以后跟已有的边是否构成回路：并查集</p><p>如果选的边在一个集合中，就不能再使用，不在一个集合才能添加</p></blockquote><h2 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a>Prime算法</h2><p>仍是贪心算法，但它先选出最小的一条边，接着并非从全局中找到最小的边，而是以最小的边为基础，选已有的边的邻接顶点链接出的边中最小的，避开了选出环路的情况</p><h1 id="单元最短路径"><a href="#单元最短路径" class="headerlink" title="单元最短路径"></a>单元最短路径</h1><p>从在带权图的某一顶点出发，找出一条通往另一顶点的最短路径，最短也就是沿路径各边的权值总和达到最小。</p><blockquote><p>Dijkstra算法和Floyd算法</p></blockquote><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>求一个点和图中的其他所有点之间的最路径</p><p><img src="/2021/03/20210312/008i3skNly1gptzx4hmntj30au0a0mxt.jpg" alt="截屏2021-04-23 21.25.02"></p><p><img src="/2021/03/20210312/008i3skNly1gpu0bcc8v9j30kv089wgk.jpg" alt="截屏2021-04-23 21.38.39"></p><table><thead><tr><th>路径</th><th>路径长度</th></tr></thead><tbody><tr><td>0，1</td><td>无穷大</td></tr><tr><td>0，2</td><td>50</td></tr><tr><td>0，3</td><td>10</td></tr><tr><td>0，4</td><td>50</td></tr></tbody></table><p>依次遍历所有的边，找出更短路径，找到则更新</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;图的构成&quot;&gt;&lt;a href=&quot;#图的构成&quot; class=&quot;headerlink&quot; title=&quot;图的构成&quot;&gt;&lt;/a&gt;图的构成&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;顶点集合&lt;/strong&gt;+&lt;strong&gt;边的集合&lt;/strong&gt;：&lt;code&gt;G = (V, E)&lt;/code&gt;，顶点集合&lt;code&gt;V = &amp;#123;x | x属于某个数据对象及&amp;#125;&lt;/code&gt;是有穷非空集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;E = &amp;#123;(x, y) | x, y属于V&amp;#125;&lt;/code&gt;或者&lt;code&gt;E = &amp;#123;&amp;lt;x, y&amp;gt; | x, y属于V &amp;amp;&amp;amp; Path(x, y)&amp;#125;&lt;/code&gt;是顶点间关系的有穷集合，也叫边集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(x, y)&lt;/code&gt;表示x到y的一条双向通道，即&lt;code&gt;(x, y)&lt;/code&gt;是无方向的，&lt;code&gt;Path(x, y)&lt;/code&gt;表示从x到y的一条单向通路，即&lt;code&gt;Path(x, y)是有方向的&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顶点和边：图中节点成为顶点，第i个顶点记作vi， 两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中第k条边记作ek，&lt;code&gt;ek = (vi, vj)&lt;/code&gt;或&lt;code&gt;ek = &amp;lt;vi, vj&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在有向图中，顶点对&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;是有序的，顶点对&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;称为顶点x到顶点y的一条边(弧)，&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;y ,x&amp;gt;&lt;/code&gt;是两条不同的边，如G3、G4&lt;/li&gt;
&lt;li&gt;在无向图中，顶点对(x, y)是无序的，顶点对(x,y) 称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，如G1、G2&lt;/li&gt;
&lt;li&gt;注意：&lt;strong&gt;无向边&lt;code&gt;(x, y)&lt;/code&gt;等于有向边&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;y, x&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="图" scheme="http://zhaozhuolin.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>在线的面试预约系统</title>
    <link href="http://zhaozhuolin.com/2020/08/20200827.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200827.html</id>
    <published>2020-08-26T16:05:00.000Z</published>
    <updated>2023-05-07T11:18:08.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>通过httplib库函数中的Post和Get方法来处理以下四种请求</p><ul><li><code>注册</code> ：处理浏览器传来的数据，并调用数据库函数增加列</li><li><code>登录</code> ：处理浏览器传来的数据，在数据库中进行查询，登陆成功则生成sessionID用以后续使用</li><li><code>数据页面</code>：处理浏览器传来的数据，使用sessionID查询当前登录的用户，在数据库中查询该用户信息并返回</li><li><code>数据提交</code>：处理浏览器传来的数据，根据头部的sessionID查询登陆用户，切割正文提交的信息，插入数据库</li></ul><span id="more"></span><p><img src="/2020/08/20200827/007S8ZIlly1gi4nyalqwpj31f40nijuu.jpg" alt="IMG_7559"></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><h3 id="http服务"><a href="#http服务" class="headerlink" title="http服务"></a>http服务</h3><p>创建了一个类来完成整个项目的运行，这个类用于保存登录数据库的参数、所有登录用户的sessionid、启动http服务，其结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AisSvr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AisSvr</span>()</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">OnInit</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span><span class="comment">//启动http服务</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">GetSessionId</span><span class="params">(httplib::Request res, string* session_id)</span></span>;<span class="comment">//获取当前用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span></span>;<span class="comment">//打开配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string _svr_ip;<span class="comment">//服务端监听的IP地址</span></span><br><span class="line">  <span class="type">uint16_t</span> _svr_port;<span class="comment">//服务端监听的端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据库类成员</span></span><br><span class="line">  DataBaseSvr* _db;</span><br><span class="line">  string _db_ip;</span><br><span class="line">  string _db_user;</span><br><span class="line">  string _db_passwd;</span><br><span class="line">  string _db_name;</span><br><span class="line">  <span class="type">uint16_t</span> _db_port;</span><br><span class="line"></span><br><span class="line">  AllSessionInfo* _all_session;<span class="comment">//所有登录用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  httplib::Server _http_svr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>对于数据库的操作，同样创建了一个类来完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataBaseSvr</span><span class="comment">//数据库类</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DataBaseSvr</span>(string&amp; host, string&amp; user, string&amp; passwd, string&amp; db, <span class="type">uint16_t</span> port)</span><br><span class="line">    &#123;</span><br><span class="line">      _host = host;</span><br><span class="line">      _user = user;</span><br><span class="line">      _passwd = passwd;</span><br><span class="line">      _db = db;</span><br><span class="line">      _port = port;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">mysql_init</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DataBaseSvr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">mysql_close</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QuerySql</span><span class="params">(<span class="type">const</span> string&amp; sql)</span></span>;<span class="comment">//操作数据库接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Connect2MySQL</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="type">bool</span> <span class="title">QueryUserExist</span><span class="params">(Json::Value&amp; request_json, Json::Value* result)</span></span>;<span class="comment">//数据库查询</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QueryOneStuInfo</span><span class="params">(string user_id, Json::Value* result)</span></span>;<span class="comment">//查询用户信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//MySQL就是客户端的操作句柄</span></span><br><span class="line">    MYSQL _mysql;</span><br><span class="line">    string _host;</span><br><span class="line">    string _user;</span><br><span class="line">    string _passwd;</span><br><span class="line">    string _db;</span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sessionid管理"><a href="#sessionid管理" class="headerlink" title="sessionid管理"></a>sessionid管理</h3><p>创建了一个类专门计算MD5值，用另一个类进行封装，同时管理一批sessionid</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Session</span>(Json::Value&amp; user_info)</span><br><span class="line">    &#123;</span><br><span class="line">      _origin_str.<span class="built_in">clear</span>();</span><br><span class="line">      _user_info = user_info;</span><br><span class="line"></span><br><span class="line">      _origin_str += <span class="built_in">to_string</span>(_user_info[<span class="string">&quot;stu_id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_interview_time&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SumMd5</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">string&amp; <span class="title">GetSessionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">SumMd5</span>();</span><br><span class="line">      <span class="keyword">return</span> _session_id;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//private:因为不想再写个接口获取sessionid所以直接将成员变量设为public（懒惰！）</span></span><br><span class="line">    string _session_id;<span class="comment">//保存session_id</span></span><br><span class="line">    string _origin_str;<span class="comment">//原始的串，用来生成session_id</span></span><br><span class="line">    Json::Value _user_info;<span class="comment">//原始串内容：stu_id, stu_name, stu_interview_time</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllSessionInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  ~<span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  <span class="comment">//Set Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">SetSessionValue</span><span class="params">(string&amp; session_id, Session&amp; session_info)</span></span>;</span><br><span class="line">  <span class="comment">//Get Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetSessionValue</span><span class="params">(string&amp; session_id, Session* session_info)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//key：sessionid，value：session</span></span><br><span class="line">  unordered_map&lt;string, Session&gt; _session_map;</span><br><span class="line">  <span class="type">pthread_mutex_t</span> _map_lock;<span class="comment">//所有操作均需要互斥完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>该模块主要完成对浏览器响应正文的数据进行分割和解析，输出日志信息，较为简单</p><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><h3 id="响应登录请求-Post方法"><a href="#响应登录请求-Post方法" class="headerlink" title="响应登录请求(Post方法)"></a>响应登录请求(Post方法)</h3><ol><li>解析提交的内容</li><li>先根据邮箱作为查询条件，如果邮箱不存在，则登陆失败，如果邮箱存在，则校验密码</li><li>上一步校验失败，向浏览器返回false，校验成功则进行下一步</li><li>根据登录用户信息，生成sessionid，用以表示当前用户</li><li>跳转到个人信息页面</li></ol><h3 id="个人信息也页面-Get方法"><a href="#个人信息也页面-Get方法" class="headerlink" title="个人信息也页面(Get方法)"></a>个人信息也页面(Get方法)</h3><ol><li>根据请求头部的sessionid信息，从管理sessionid的类中获取当前登录用户信息</li><li>查询数据库，获取用户信息</li><li>组织应答</li></ol><h3 id="注册请求-Post方法"><a href="#注册请求-Post方法" class="headerlink" title="注册请求(Post方法)"></a>注册请求(Post方法)</h3><ol><li>解析请求正文</li><li>将解析出的用户信息插入注册信息表(此处需要开启数据库事务，加入注册信息插入失败，则回滚)</li><li>组织应答</li></ol><h3 id="预约请求-Post方法"><a href="#预约请求-Post方法" class="headerlink" title="预约请求(Post方法)"></a>预约请求(Post方法)</h3><p>基本思路同注册请求</p><h1 id="效果预览图与项目代码"><a href="#效果预览图与项目代码" class="headerlink" title="效果预览图与项目代码"></a>效果预览图与项目代码</h1><p>注册页面</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nypyjs4j310k0qiwgl.jpg" alt="IMG_7555"></p><p>登录页面</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nzbxgiwj310k0qiwgh.jpg" alt="IMG_7556"></p><p>数据提交页面</p><p><img src="/2020/08/20200827/007S8ZIlly1gi4o34di6rj30xn06574p.jpg" alt="IMG_7554"></p><p>个人信息页面</p><p><img src="/2020/08/20200827/007S8ZIlly1gi4o35739vj30xn06574p.jpg" alt="IMG_7558"></p><p>GitHub地址：<a href="https://github.com/Latsummer/interview-system">https://github.com/Latsummer/interview-system</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h1&gt;&lt;p&gt;通过httplib库函数中的Post和Get方法来处理以下四种请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;注册&lt;/code&gt; ：处理浏览器传来的数据，并调用数据库函数增加列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;登录&lt;/code&gt; ：处理浏览器传来的数据，在数据库中进行查询，登陆成功则生成sessionID用以后续使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据页面&lt;/code&gt;：处理浏览器传来的数据，使用sessionID查询当前登录的用户，在数据库中查询该用户信息并返回&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据提交&lt;/code&gt;：处理浏览器传来的数据，根据头部的sessionID查询登陆用户，切割正文提交的信息，插入数据库&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="小作品" scheme="http://zhaozhuolin.com/categories/%E5%B0%8F%E4%BD%9C%E5%93%81/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="后端" scheme="http://zhaozhuolin.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>简单的Boost文档搜索引擎--基于jieba分词和HTTP协议</title>
    <link href="http://zhaozhuolin.com/2020/08/20200826.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200826.html</id>
    <published>2020-08-26T07:40:00.000Z</published>
    <updated>2023-05-07T11:15:56.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更方便的使用Boost库，于是想到实现一个基于Boost离线文档的搜索引擎，对离线的HTML文件进行分析，、并对查询词进行分词（借用第三方库），然后根据相关性（简陋的相关性公式）进行排序，最终将查询结果用JSON的数据格式进行组织打包，最终通过对外的http服务将查询结果返回</p><span id="more"></span><h2 id="成品效果以及GitHub链接"><a href="#成品效果以及GitHub链接" class="headerlink" title="成品效果以及GitHub链接"></a>成品效果以及GitHub链接</h2><blockquote><p>由于不怎么会前端的一些语法，所以页面比较简陋</p></blockquote><p><img src="/2020/08/20200826/007S8ZIlly1gi49kgwwqmj31hc0u01a0.jpg" alt="IMG_7552"></p><p><img src="/2020/08/20200826/007S8ZIlly1gi49kbll6kj30rx06wwg2.jpg" alt="IMG_7553"></p><p>详细代码于 - GitHub链接：<a href="https://github.com/Latsummer/Boost-search-engine">GitHub  Boost-search-engine</a></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>按照处理流程，整个项目的结构可以被分为，预处理模块，索引模块，搜索模块以及服务器模块</p><ol><li>预处理模块：读取原始的HTML文档内容，进行预处理操作：解析一些重要的信息，如文档标题、文档的URL，文档的正文，即去除HTML标签，只保留正文；在预处理完毕之后，将结果整理成一个行文本文件，用以之后的模块使用</li><li>索引模块：将预处理好的行文本文件输入，根据预处理结果，在内存中构造正排索引（文档ID &#x3D;&gt; 文档正文）和倒排索引（文档正文 &#x3D;&gt; 文档ID）</li><li>搜索模块：输入查询词，先对查询词进行分词，然后实现触发，将查询结果按照相关性进行排序，依次拼装，按照JSON数据格式进行组织</li><li>服务器模块：加载搜索引擎模块，对外提供HTTP服务</li></ol><p><img src="/2020/08/20200826/007S8ZIlly1gi49l0rlk0j317m0csgnf.jpg" alt="IMG_7551"></p><h1 id="预处理模块"><a href="#预处理模块" class="headerlink" title="预处理模块"></a>预处理模块</h1><p>该模块核心功能为：读取并分析Boost文档的.html文件内容，解析出每个文档的标题，URL，正文，最终把结果输出为一个行文版文件</p><p>首先根据核心功能，定义一个可以表示一个文章的结构体，以及一些全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string g_input_path = <span class="string">&quot;../data/input/&quot;</span>;<span class="comment">//表示从哪个目录中读取boost文档中的html</span></span><br><span class="line">string g_output_path = <span class="string">&quot;../data/tmp/raw_input&quot;</span>;<span class="comment">//表示预处理模块的输出结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  string tittle;<span class="comment">//标题</span></span><br><span class="line">  string url;<span class="comment">//url</span></span><br><span class="line">  string content;<span class="comment">//正文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="枚举路径"><a href="#枚举路径" class="headerlink" title="枚举路径"></a>枚举路径</h2><p>使用Boost中的filesystem的递归文档迭代器来对每一个文件进行枚举，使用一个vector来临时存储，用于之后的解析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnumFile</span><span class="params">(<span class="type">const</span> string&amp; input_path, vector&lt;string&gt;* file_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">filesystem::path <span class="title">root_path</span><span class="params">(input_path)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">exists</span>(root_path) )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;目录不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个迭代器使用循环的时候可以自动完成递归（对文件）</span></span><br><span class="line">  boost::filesystem::recursive_directory_iterator end_iter;</span><br><span class="line">  <span class="keyword">for</span>(boost::filesystem::recursive_directory_iterator <span class="built_in">it</span>(root_path);  it != end_iter; it++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//当前路径对应的如果是目录则跳过</span></span><br><span class="line">    <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">is_regular_file</span>(*it) )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//当前路径对应的文件如果不是html文件，跳过</span></span><br><span class="line">    <span class="keyword">if</span>( it-&gt;<span class="built_in">path</span>().<span class="built_in">extension</span>() != <span class="string">&quot;.html&quot;</span> )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//把得到的路径加入到vector中</span></span><br><span class="line">    file_list-&gt;<span class="built_in">push_back</span>(it-&gt;<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h2><ol><li>遍历上一步vector中存放的文件路径，读取文件内容，将读取内容写入到string类型变量<code>html</code>中</li><li>根据读取到的内容，首先解析出标题，按照html中的标签<code>&lt;title&gt;&lt;/title&gt;</code>，调用string类成员函数<code>substr</code>获取文章标题</li><li>根据读取到的内容，构造对应的URL，由于网络路径和文件路径一致，所以只需要在文件的路径前加上前缀<code>https://www.boost.org/doc/libs/1_53_0/doc/</code>即可</li><li>根绝读取到的内容，解析正文片段，跳过字符<code>&lt;</code>和字符<code>&gt;</code>中的内容，同时将内容中的<code>\n</code>替换为空格（因为最终结果要对应到原始的html文档）</li><li>对于2、3、4步骤，解析出的三个内容使用不可见字符<code>\3</code>分割，然后写入删除文件<code>raw_put</code>中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFile</span><span class="params">(<span class="type">const</span> string&amp; file_path, DocInfo* doc_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//1. 先读取文件内容</span></span><br><span class="line">  string html;</span><br><span class="line">  <span class="type">bool</span> ret = common::Util::<span class="built_in">Read</span>(file_path, &amp;html);</span><br><span class="line">  <span class="keyword">if</span>(!ret)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解析文件失败!&quot;</span> &lt;&lt; file_path &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 根据文件内容解析出标题</span></span><br><span class="line">  ret = <span class="built_in">ParseTitle</span>(html, &amp;doc_info-&gt;tittle);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;标题解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3. 根据文件路径，构造出对应的在线文档</span></span><br><span class="line">  ret = <span class="built_in">ParseUrl</span>(file_path, &amp;doc_info-&gt;url);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;url 解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4. 根据文件内容，去标签，作为doc_info中的content字段内容</span></span><br><span class="line">  ret = <span class="built_in">ParseContent</span>(html, &amp;doc_info-&gt;content);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正文解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h1><p>索引使用了正排索引和倒排索引，其结构体分别如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正排索引：给定doc_id映射到文档内容（DocInfo对象）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;</span><br><span class="line">  string _title;</span><br><span class="line">  string _url;</span><br><span class="line">  string _content;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒排索引：给定词，映射到包含该词语的文档id列表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weight</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;<span class="comment">//该词在哪个文档出现</span></span><br><span class="line">  <span class="type">int</span> _weight;<span class="comment">//对应的权重</span></span><br><span class="line">  string _word;<span class="comment">//什么词</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个类来表示整个索引结构，并提供外部调用的API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Index</span>();</span><br><span class="line">    <span class="comment">//1. 查正排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> DocInfo* <span class="title">GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span>;</span><br><span class="line">    <span class="comment">//2. 查倒排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>;</span><br><span class="line">    <span class="comment">//3. 构建索引</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Build</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">DocInfo* <span class="title">BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span>;</span><br><span class="line">    cppjieba::Jieba jieba;<span class="comment">//jieba分词</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//正排索引，数组下标对应到doc_id</span></span><br><span class="line">    vector&lt;DocInfo&gt; _forward_index;</span><br><span class="line">    <span class="comment">//倒排索引，使用一个hash表来表示映射关系</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;Weight&gt; &gt; _inverted_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建正排索引"><a href="#创建正排索引" class="headerlink" title="创建正排索引"></a>创建正排索引</h2><p>正排索引使用vector来存放，文章的ID就是其所在位置的下标，元素内容就是预处理模块中的输出内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DocInfo* <span class="title">Index::BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vector&lt;string&gt; tokens;</span><br><span class="line">  common::Util::<span class="built_in">Split</span>(line, <span class="string">&quot;\3&quot;</span>, &amp;tokens);</span><br><span class="line">  <span class="keyword">if</span>( tokens.<span class="built_in">size</span>() != <span class="number">3</span> )<span class="comment">//如果没有被切分为3份，说明节分结果有问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//把切分结果填充到DocInfo对象中</span></span><br><span class="line">  DocInfo doc_info;</span><br><span class="line">  doc_info._doc_id = _forward_index.<span class="built_in">size</span>();</span><br><span class="line">  doc_info._title = tokens[<span class="number">0</span>];</span><br><span class="line">  doc_info._url = tokens[<span class="number">1</span>];</span><br><span class="line">  doc_info._content = tokens[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">  _forward_index.<span class="built_in">push_back</span>(<span class="built_in">move</span>(doc_info));<span class="comment">//转化为右值引用，移动语义复制赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index.<span class="built_in">back</span>();<span class="comment">//防止野指针问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建倒排索引"><a href="#创建倒排索引" class="headerlink" title="创建倒排索引"></a>创建倒排索引</h2><p>依次对标题与正文进行分词，建立统计词频的结构体，根据统计结果，填充<code>Weight</code>对象，其中成员<code>_weight</code>(权重)简单的设计了一个公式：权重 &#x3D;&#x3D; 10 * 标题出现次数 + 正文出现次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//倒排是一个hash表</span></span><br><span class="line">  <span class="comment">//key是词（针对文档分词结果）</span></span><br><span class="line">  <span class="comment">//value是倒排拉链（包含若干个Weight对象）</span></span><br><span class="line">  <span class="comment">//每次遍历到一个文档，分析之后把信息更新到倒排结构中</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Index::BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//0. 创建专门统计词频的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">WordCnt</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> _title_cnt;</span><br><span class="line">      <span class="type">int</span> _content_cnt;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">WordCnt</span>() </span><br><span class="line">          : _title_cnt(<span class="number">0</span>)</span><br><span class="line">          , _content_cnt(<span class="number">0</span>) </span><br><span class="line">      &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    unordered_map&lt;string, WordCnt&gt; word_cnt_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 对标题进行分词</span></span><br><span class="line">    vector&lt;string&gt; title_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.title, &amp;title_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="comment">//次数要考虑大小写问题，大小写应该都算成小写</span></span><br><span class="line">    <span class="keyword">for</span>(string&amp; word : title_token)</span><br><span class="line">    &#123;</span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">      ++word_cnt_map[word]._title_cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对正文分词</span></span><br><span class="line">    vector&lt;string&gt; content_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.content, &amp;content_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (string word : content_token) </span><br><span class="line">    &#123;</span><br><span class="line">       boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">       ++word_cnt_map[word]._content_cnt;                      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 根据统计结果，整个出Weight对象，把结果更新到倒排索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; word_pair : word_cnt_map)</span><br><span class="line">    &#123;</span><br><span class="line">      Weight weight;</span><br><span class="line">      weight._doc_id = doc_info.doc_id;</span><br><span class="line">      weight._weight = <span class="number">10</span> * word_pair.second._title_cnt + word_pair.second._content_cnt;</span><br><span class="line">      weight._word = word_pair.first;</span><br><span class="line"></span><br><span class="line">      vector&lt;Weight&gt;&amp; inverted_list = _inverted_index[word_pair.first];</span><br><span class="line">      inverted_list.<span class="built_in">push_back</span>(<span class="built_in">move</span>(weight));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Index::CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    jieba.<span class="built_in">CutForSearch</span>(input, *output);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，整个索引模块建立完成，内存中即存在了正排索引结构和倒排索引结构，等待搜索模块去调用</p><h2 id="查询正排-x2F-倒排索引"><a href="#查询正排-x2F-倒排索引" class="headerlink" title="查询正排&#x2F;倒排索引"></a>查询正排&#x2F;倒排索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> DocInfo* <span class="title">Index::GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( doc_id &lt; <span class="number">0</span> || doc_id &gt;= _forward_index.<span class="built_in">size</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index[doc_id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">Index::GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = _inverted_index.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span>( it == _inverted_index.<span class="built_in">end</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Searcher</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//搜索过程中依赖索引，需要持有索引指针</span></span><br><span class="line">    Index* index;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Searcher</span>() </span><br><span class="line">        :<span class="built_in">index</span>(<span class="keyword">new</span> <span class="built_in">Index</span>())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* results)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="function">string <span class="title">GenerateDesc</span><span class="params">(<span class="type">const</span> string&amp; content, <span class="type">const</span> string&amp; word)</span></span>;<span class="comment">//生成描述</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>在使用搜索模块时，创建<code>Searcher</code>对象，即<code>new</code>了一个Index对象，接着调用成员函数<code>Init</code>，它会调用Index的成员函数<code>Build</code>，来创建正排索引和倒排索引，在需要查询时，调用成员函数<code>Search</code>，完成查询过程，将结果写入string类对象<code>results</code>中</p><h2 id="搜索函数"><a href="#搜索函数" class="headerlink" title="搜索函数"></a>搜索函数</h2><p>搜索模块先对查询词进行分词，再根据分词结果去调用索引模块的查询正排，倒排成员函数，接着将查询结果按照权重降序排列，最后调用JSONCPP库函数来包装查询结果（同时调用相关函数来生成描述），序列化为字符串输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Searcher::Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//1. [分词] 针对查询结果进行分词</span></span><br><span class="line">    vector&lt;string&gt; tokens;</span><br><span class="line">    index-&gt;<span class="built_in">CutWord</span>(query, &amp;tokens);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. [触发] 根据分词结果，查询倒排，把相关文档都获取到</span></span><br><span class="line">    vector&lt;Weight&gt; all_token_result;</span><br><span class="line">    <span class="keyword">for</span>(string word : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//做索引的时候，已经把其中的词统一转成小写了</span></span><br><span class="line">      <span class="comment">//查询到排的时候，也需要把查询词统一转成小写</span></span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span>* inverted_list = index-&gt;<span class="built_in">GetInvertedList</span>(word);</span><br><span class="line">      <span class="keyword">if</span>( inverted_list == <span class="literal">nullptr</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//说明该词在倒排索引中不存在，如果这个词比较生僻，</span></span><br><span class="line">        <span class="comment">//在所有文档中都没有出现过。此时得到的倒排拉链就是nullptr</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//tokens 包含多个结果，需要把多个结果合并到一起，才能进行统一排序</span></span><br><span class="line">      all_token_result.<span class="built_in">insert</span>(all_token_result.<span class="built_in">end</span>(), </span><br><span class="line">                              inverted_list-&gt;<span class="built_in">begin</span>(), inverted_list-&gt;<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. [排序] 把刚才查到的文档的倒排拉链合并到一起并按照权重进行降序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(all_token_result.<span class="built_in">begin</span>(), all_token_result.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> Weight&amp; w1, <span class="type">const</span> Weight&amp; w2)&#123;</span><br><span class="line">      <span class="comment">//实现降序排序 w1 &gt; w2</span></span><br><span class="line">      <span class="keyword">return</span> w1.weight &gt; w2.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. [包装结果] 把得到的这些倒排拉链中的文档id获取到，然后去查正排，</span></span><br><span class="line">    <span class="comment">//             再把doc_info中的内容构造成最终的预期格式(JSON)</span></span><br><span class="line">    <span class="comment">//使用JSONCPP库来实现</span></span><br><span class="line">    Json::Value results;<span class="comment">//包含若干个结果，每个结果就是一个JSON对象对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; weight : all_token_result)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//根据weight中的结果查询正排序</span></span><br><span class="line">      <span class="type">const</span> DocInfo* doc_info = index-&gt;<span class="built_in">GetDocInfo</span>(weight.doc_id);</span><br><span class="line">      <span class="comment">//把doc_info对象进一步包装成一个JSON对象</span></span><br><span class="line">      Json::Value result;</span><br><span class="line">      result[<span class="string">&quot;title&quot;</span>] = doc_info-&gt;title;</span><br><span class="line">      result[<span class="string">&quot;url&quot;</span>] = doc_info-&gt;url;</span><br><span class="line">      result[<span class="string">&quot;desc&quot;</span>] = <span class="built_in">GenerateDesc</span>(doc_info-&gt;content, weight.word);</span><br><span class="line">      results.<span class="built_in">append</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一步，把得到的results这个JSON对象序列化为字符串，写入output中</span></span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    *output = writer.<span class="built_in">write</span>(results);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，搜索模块就搭建好了，等待最终的服务器模块调用</p><h1 id="服务器模块"><a href="#服务器模块" class="headerlink" title="服务器模块"></a>服务器模块</h1><p>首先初始化Searcher对象，调用<code>Init</code>成员函数初始化索引结构，然后调用Server对象中的Get方法，接收网页端请求，分析参数调用查询函数，然就将结果返回给网页端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> httplib;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建Searcher对象</span></span><br><span class="line">    searcher::Searcher searcher;</span><br><span class="line">    <span class="type">bool</span> ret = searcher.<span class="built_in">Init</span>(<span class="string">&quot;../data/tmp/raw_input&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Searcher初始化失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server;</span><br><span class="line">    server.<span class="built_in">Get</span>(<span class="string">&quot;/searcher&quot;</span>, [&amp;searcher](<span class="type">const</span> Request&amp; req, Response&amp; resp)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!req.<span class="built_in">has_param</span>(<span class="string">&quot;query&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            resp.<span class="built_in">set_content</span>(<span class="string">&quot;请求参数错误&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string query = req.<span class="built_in">get_param_value</span>(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        cout  &lt;&lt; <span class="string">&quot;收到查询词：&quot;</span> &lt;&lt; query &lt;&lt; endl;</span><br><span class="line">        string results;</span><br><span class="line">        searcher.<span class="built_in">Search</span>(query, &amp;results);</span><br><span class="line">        resp.<span class="built_in">set_content</span>(results, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.<span class="built_in">set_base_dir</span>(<span class="string">&quot;./www&quot;</span>);</span><br><span class="line">    server.<span class="built_in">listen</span>(<span class="string">&quot;x.x.x.x&quot;</span>, [port]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个搜索引擎已经搭建完成，只需要运行起来即可</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了更方便的使用Boost库，于是想到实现一个基于Boost离线文档的搜索引擎，对离线的HTML文件进行分析，、并对查询词进行分词（借用第三方库），然后根据相关性（简陋的相关性公式）进行排序，最终将查询结果用JSON的数据格式进行组织打包，最终通过对外的http服务将查询结果返回&lt;/p&gt;</summary>
    
    
    
    <category term="小作品" scheme="http://zhaozhuolin.com/categories/%E5%B0%8F%E4%BD%9C%E5%93%81/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="后端" scheme="http://zhaozhuolin.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>特殊类设计</title>
    <link href="http://zhaozhuolin.com/2020/08/20200820.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200820.html</id>
    <published>2020-08-20T06:14:00.000Z</published>
    <updated>2023-05-07T11:18:08.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只能在堆上创建对象的类"><a href="#只能在堆上创建对象的类" class="headerlink" title="只能在堆上创建对象的类"></a>只能在堆上创建对象的类</h1><ol><li>构造函数私有</li><li>提供一个静态的堆上创建对象的方法</li><li>防止拷贝（拷贝构造声明为私有且不实现，或者声明为delete）<span id="more"></span></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> HeapOnly* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapOnly;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HeapOnly</span>()</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp; H) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testHeaponly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HeapOnly* ptr = HeapOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只能在栈上创建对象的类"><a href="#只能在栈上创建对象的类" class="headerlink" title="只能在栈上创建对象的类"></a>只能在栈上创建对象的类</h1><ol><li>构造函数私有</li><li>提供一个静态的栈上创建对象的方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">StackOnly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">StackOnly</span>()&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testStackOnly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackOnly so = StackOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：屏蔽new</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">StackOnly2</span>()</span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对象不能被拷贝的类"><a href="#对象不能被拷贝的类" class="headerlink" title="对象不能被拷贝的类"></a>对象不能被拷贝的类</h1><p>将拷贝构造与赋值运算符声明为delete函数或者声明为私有且不实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyBan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CopyBan</span>() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">CopyBan</span>(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">CopyBan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="不能被继承的类"><a href="#不能被继承的类" class="headerlink" title="不能被继承的类"></a>不能被继承的类</h1><ol><li>父类构造声明为私有</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">NoSon</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>加上final关键字</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span> <span class="keyword">final</span></span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类只能创建一个对象，该模式可以保证该类中只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><ol><li>构造函数私有</li><li>提供一个静态的方法返回单例</li><li>声明一个静态的单例成员</li><li>拷贝构造和赋值声明为delete函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_single;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton _single;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line">Singleton Singleton::_single;</span><br></pre></td></tr></table></figure><p>特点：实现简单，多线程情境下效率高</p><p>缺陷：程序启动比较满，多个单例对象初始化的顺序无法控制</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><ol><li>构造函数私有</li><li>提供一个静态的方法返回单例，第一次调用创建对象，后续调用直接返回</li><li>声明一个静态指针，指针初始化为nullptr</li><li>拷贝构造和赋值声明为delete</li><li>保证线程安全（修改指针），双检查提高效率</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton2* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;<span class="comment">//双检查</span></span><br><span class="line">_mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第一次调用， 创建对象</span></span><br><span class="line">_ptr = <span class="keyword">new</span> Singleton2;</span><br><span class="line">&#125;</span><br><span class="line">_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GC</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">GC</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_ptr)</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton2</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Singleton2</span>(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton2* _ptr;</span><br><span class="line"><span class="type">static</span> mutex _mtx;</span><br><span class="line"><span class="type">static</span> GC _gc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton2* Singleton2::_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton2::_mtx;</span><br><span class="line">Singleton2::GC Singleton2::_gc;</span><br></pre></td></tr></table></figure><p>特点：延迟加载，程序启动快，可以指定多个单例对象的初始化顺序</p><p>缺陷：实现较为复杂</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;只能在堆上创建对象的类&quot;&gt;&lt;a href=&quot;#只能在堆上创建对象的类&quot; class=&quot;headerlink&quot; title=&quot;只能在堆上创建对象的类&quot;&gt;&lt;/a&gt;只能在堆上创建对象的类&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;构造函数私有&lt;/li&gt;
&lt;li&gt;提供一个静态的堆上创建对象的方法&lt;/li&gt;
&lt;li&gt;防止拷贝（拷贝构造声明为私有且不实现，或者声明为delete）&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="-C++ -类与对象" scheme="http://zhaozhuolin.com/tags/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++11中的新特性</title>
    <link href="http://zhaozhuolin.com/2020/07/20200727.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200727.html</id>
    <published>2020-07-27T08:40:15.000Z</published>
    <updated>2023-05-07T11:18:08.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><p>C++11：支持内置类型与自定义类型的列表初始化，其中自定义类型不是天然支持列表初始化，需要显示定义参数类型为<code>initiaizer_list</code>的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span> (<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    : _a(a)</span><br><span class="line">    , _b(b)</span><br><span class="line">  &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">  <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> c&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">float</span> d = &#123; <span class="number">1.2</span> &#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m = &#123; &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">A a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="变量类型推导"><a href="#变量类型推导" class="headerlink" title="变量类型推导"></a>变量类型推导</h1><ul><li>auto：编译时根据初始化表达式进行类型推导</li><li>decltype：运行时类型识别，如果有参数列表，推导返回值类型，如果没有参数列表，只有函数名，推导为函数的接口类型</li></ul><h1 id="final与override"><a href="#final与override" class="headerlink" title="final与override"></a>final与override</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span> <span class="comment">//不能被继承</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">override</span> <span class="comment">//强制子类重写父类虚函数</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="默认成员函数控制"><a href="#默认成员函数控制" class="headerlink" title="默认成员函数控制"></a>默认成员函数控制</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a): _a(a) </span><br><span class="line">&#123;&#125; </span><br><span class="line">  <span class="comment">// 显式缺省构造函数，由编译器生成 </span></span><br><span class="line"><span class="built_in">A</span>() = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> C&amp; c) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">//把一个函数声明成已删除函数，不能再被使用</span></span><br><span class="line">  <span class="comment">//拷贝构造声明为delete：放拷贝</span></span><br><span class="line">  </span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a); </span><br><span class="line"> <span class="comment">// 在类中声明，在类外定义时让编译器生成默认赋值运算符重载 </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">int</span> _a; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">A&amp; A::<span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line">A a2; </span><br><span class="line">a2 = a1; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>简单来说，左值：可以出现在<code>=</code>的两边、或者可以取地址的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* p2 = &amp;b;</span><br></pre></td></tr></table></figure><p>右值：只能出现在<code>=</code>的右边，或者不可以取地址（非绝对）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>；</span><br><span class="line"><span class="type">int</span>* p = &amp;<span class="number">10</span>;</span><br><span class="line"><span class="comment">//此处10和20均为右值</span></span><br></pre></td></tr></table></figure><p>C++中的右值：</p><ul><li>纯右值：常量、临时变量。<code>getA(A) = b;int* p = &amp;(getA());</code></li><li>将亡值：声明周期即将结束的值</li></ul><p>临时变量：函数以值返回的变量，调用类的构造函数创建的变量</p><ul><li>左值引用：引用的实体既可以为左值，也可以为右值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ra = a;</span><br><span class="line"><span class="comment">//ra实体为左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ri = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//ri实体为右值</span></span><br></pre></td></tr></table></figure><ul><li>右值引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; lr = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//实体为常量</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; lr2 = <span class="built_in">getA</span>();</span><br><span class="line"><span class="comment">//实体为临时变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r3 = <span class="built_in">getA</span>();<span class="comment">//左值引用，实体为右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; r4 = a;<span class="comment">//不能使用，右值引用语法不能用来引用左值</span></span><br></pre></td></tr></table></figure><p>小结：</p><p>左值引用，右值引用的语法意义：都是变量的别名</p><p>左值引用：就可以引用左值，也可以引用右值，如果引用右值，需要为const左值引用</p><p>右值引用：引用右值</p><ul><li>移动构造：参数类型为右值引用，提高拷贝的效率<ul><li>相对于拷贝构造，可以实现浅拷贝的情况下，不产生错误</li><li>右值引用指向的实体一般是将亡值，可以直接获取右值引用所指向的实体资源，不需要深拷贝</li></ul></li><li>移动赋值：参数类型为右值引用，也是浅拷贝，原理同上</li><li><code>move</code>：移动语义，将左值变为右值，使用时候需要注意保证属性被修改的左值在之后不会再用到</li></ul><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p><code>[捕捉列表](参数列表)mutable-&gt;返回值类型&#123;函数体&#125;</code></p><ul><li>捕捉列表（capture-list）：在lambda函数的开始位置，编译器根据[]来判断接下来 的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用。 </li><li>参数列表（parameters）：与普通函数的参数列表一致，如果不需要参数传递，则可以连同()一起省略 </li><li>mutable：默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。使用该修饰符时，参数列表不可省略(即使参数为空)。 </li><li>返回值类型（returntype）：用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分 可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导。 </li><li>函数体（statement）：在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">[] &#123;&#125;;</span><br><span class="line">[a, b]()<span class="keyword">mutable</span> &#123;a = <span class="number">100</span>; b = <span class="number">200</span>; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;a = <span class="number">1</span>; b = <span class="number">2</span>; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="built_in">func</span>(a, b);</span><br></pre></td></tr></table></figure><h2 id="捕捉列表"><a href="#捕捉列表" class="headerlink" title="捕捉列表"></a>捕捉列表</h2><ul><li>[var]：以值传递的方式捕捉变量var</li><li>[&#x3D;]：表示以值传递的方式捕捉父类作用域的所有变量</li><li>[&amp;]：表示以引用传递的方式捕捉父作用域的所有变量，如果是传引用形式，不需要mutable也可以修改捕捉列表中的变量</li><li>[&amp;var]：以引用传递的方式捕捉变量var</li><li>[this]：以值传递方式捕捉当前的this指针</li><li>捕捉列表可以交叉使用</li><li>父类作用域不一定是直接父类作用域，嵌套的也可以</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//[=]以传值的形式捕捉父类作用域的所有变量</span></span><br><span class="line">[=](<span class="type">int</span> num)<span class="keyword">mutable</span>-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">  <span class="comment">//return a + b + c + num;</span></span><br><span class="line">  <span class="comment">//c还没有被定义，不能捕捉</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun2 = [&amp;](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">fun2</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了a以外其他变量都以值传递捕捉，a以引用传递捕捉</span></span><br><span class="line"><span class="comment">//错误写法[=, a]，都是值传递</span></span><br><span class="line"><span class="keyword">auto</span> fun3 = [=, &amp;a](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun4 = [&amp;, a](<span class="type">int</span> num)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lambda表达式不能相互赋值，但可以拷贝；可以吧lambda表达式赋给一个函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun1 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> fun2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span>&#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">fun1 = fun2;<span class="comment">//赋值操作，不能执行</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun3</span><span class="params">(fun2)</span></span>;<span class="comment">//拷贝操作</span></span><br><span class="line"><span class="keyword">auto</span> fun4 = fun2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*fptr)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fptr2)</span></span>;</span><br><span class="line"></span><br><span class="line">fptr ptr;</span><br><span class="line"></span><br><span class="line">ptr = fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口不一致</span></span><br><span class="line"><span class="comment">//fptr2 ptr2 = fun1;</span></span><br></pre></td></tr></table></figure><h1 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h1><p>头文件thread</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>thread</td><td>构造一个线程对象，没有关联任何线程函数，即没有启动任何线程</td></tr><tr><td>thread(fun, args1, args2, …)</td><td>构造一个线程对象，并关联线程函数fun，函数参数为args</td></tr><tr><td>get_id()</td><td>获取线程ID</td></tr><tr><td>joinable()</td><td>线程是否还在执行，joinable代表的是一个正在执行中的线程</td></tr><tr><td>join()</td><td>该函数调用后会阻塞线程，当该函数结束后，主线程继续执行</td></tr><tr><td>detach()</td><td>线程分离，把被创建的线程与线程对象分离</td></tr></tbody></table><p>RAII：资源获取立即初始化，在构造函数中初始化资源，在析构函数中销毁资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadMange</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ThreadMange</span>(thread&amp; t)</span><br><span class="line">: _thread(t)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ThreadMange</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_thread.<span class="built_in">joinable</span>())</span><br><span class="line">_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">thread&amp; _thread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//thread t1;</span></span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(r1)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(r2, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(r3, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadMange <span class="title">tm1</span><span class="params">(t1)</span></span>;</span><br><span class="line"><span class="function">ThreadMange <span class="title">tm2</span><span class="params">(t2)</span></span>;</span><br><span class="line"><span class="function">ThreadMange <span class="title">tm3</span><span class="params">(t3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*t1.join();</span></span><br><span class="line"><span class="comment">t2.join();</span></span><br><span class="line"><span class="comment">t3.join();*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要类的成员函数做线程函数，需要写完整的作用域，并且需要显示取地址，参数需要加上this所指的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::bfun&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;B::bfun, &amp;b)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数参数类型为引用，在线程中需要修改原是变量，则需要听过ref转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(fun, ref(a))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子性操作库（atomic）"><a href="#原子性操作库（atomic）" class="headerlink" title="原子性操作库（atomic）"></a>原子性操作库（atomic）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="function">atomic&lt;<span class="type">int</span>&gt; <span class="title">sum2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">sum2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, num)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func, num)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个变量声明为原子类型变量之后，不需要对该变量加互斥锁，线程也能够对该变量互斥访问，可以根据<code>atomic</code>类模版，定义出需要的任意原子类型。</p><p>由于原子类型通常属于资源型数据，故在C++11中，标准库将拷贝构造，移动构造以及运算符重载默认置为<code>delete</code></p><h1 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h1><ol><li>mutex</li></ol><p>try_lock：非阻塞加锁操作，如果其他线程没有释放当前锁，则直接返回加锁失败结果</p><p>lock：阻塞加锁操作，如果其他线程没有释放当前锁，阻塞等待，直到其他线程释放当前锁</p><p>unlock：解锁</p><ol start="2"><li>recursive_mutex：递归上锁，允许对互斥量进行多次上锁，但解锁需要调用与上锁相同的递归深度</li><li>timed_mutex</li></ol><ul><li>try_lock_for：接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程 释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返 回 false。 </li><li>try_lock_until() ：接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期 间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得 锁），则返回 false。</li></ul><ol start="4"><li>recursive_timed_mutex</li></ol><h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>lock_guard类模版通过RAII的方式对其管理的互斥量进行了封装，在需要加锁的地方，使用任意一个互斥体实例化一个lock_guard，调用其构造函数即上锁，在出作用域前，lock_guard对象要被销毁，会调用其析构函数而自动解锁，可以有效避免死锁问题。</p><p>缺陷：太过单一，用户无法对该锁进行控制</p><h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>相较于lock_guard有了更多的接口</p><p>上锁&#x2F;解锁操作：lock、try_lock、try_lock_for、try_lock_until和unlock </p><p>修改操作：移动赋值、交换(swap：与另一个unique_lock对象互换所管理的互斥量所有权)、释放 (release：返回它所管理的互斥量对象的指针，并释放所有权) </p><p>获取属性：owns_lock(返回当前对象是否上了锁)、operator bool()(与owns_lock()的功能相同)、 mutex(返回当前unique_lock所管理的互斥量的指针)。</p><h1 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h1><ol><li><p>原子操作：指令不会被打断，线程安全操作，效率较高</p><p> atomic&lt;T&gt;：把T类型数据封装成原子操作</p></li><li><p>加锁：通过多线程之间的加锁阻塞保证线程安全，效率较低，加锁解锁比较耗时（相对于原子操作）</p><p> mutex、recursive_mutex、timed_mutex、recursive_timed_mutex</p><p> lock：阻塞式加锁</p><p> unlock：解锁</p><p> try_lock：非阻塞式加锁</p></li></ol><p>lock_guard、unique_lock：RAII实现，通过对象的生命周期控制锁的生命周期：</p><p>构造函数-&gt;加锁、析构函数-&gt;解锁</p><p>不支持拷贝操作</p><h1 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h1><ul><li>throw：当问题出现时，程序会抛出一个异常，通过throw关键字来完成</li><li>catch：在想要处理问题的地方，通过异常处理程序捕获一场，catch用于捕获异常，可以有多个catch进行捕获</li><li>try：try代码块中的代码表示将被激活特定的异常</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">0</span>;<span class="comment">//抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//try：可能发生异常的代码放在这里</span></span><br><span class="line"><span class="built_in">fun2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">char</span> ch)</span><br><span class="line">&#123;<span class="comment">//捕获对应类型的异常</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch(char)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch(char*)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h2><p><strong>异常的抛出和匹配原则：</strong> </p><ol><li>异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。 </li><li>被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。 </li><li>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁。（这里的处理类似于函数的传值返回） </li><li>catch(…)可以捕获任意类型的异常，但是不知道异常错误是什么。 </li><li>实际中抛出和捕获的匹配原则有个例外，并不是类型完全匹配，可以抛出派生类对象，使用基类捕获。</li></ol><p><strong>在函数调用链中异常栈展开匹配原则：</strong> </p><ol><li>首先检查throw本身是否在try块内部，如果是再查找匹配的catch语句。如果有匹配的，则调到catch的地方进行处理。 </li><li>没有匹配的catch则退出当前函数栈，继续在调用函数的栈中进行查找匹配的catch。 </li><li>如果到达main函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的catch子句的过程称为栈展开。所以实际中一般都会加一个catch(…)捕获任意类型的异常，否则当有异常没捕 获，程序就会直接终止。 </li><li>找到匹配的catch子句并处理以后，会继续沿着catch子句后面继续执行</li></ol><p><strong>异常的重新抛出：</strong>有可能单个的catch不能完全处理异常，在进行一些矫正处理后，希望再交给更外层的调用链函数来处理，catch则可以通过重新抛出异常传递给更上层的函数进行处理</p><p><strong>异常安全：</strong></p><ul><li>构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化</li><li>析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等) </li><li>C++中异常经常会导致资源泄漏的问题，比如在new和delete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，而C++经常使用RAII来解决以上问题。</li></ul><p><strong>异常规范：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>; </span><br><span class="line"><span class="comment">// 这里表示这个函数只会抛出bad_alloc的异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>; </span><br><span class="line"><span class="comment">// 这里表示这个函数不会抛出异常 </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure><h2 id="标准库中的异常体系"><a href="#标准库中的异常体系" class="headerlink" title="标准库中的异常体系"></a>标准库中的异常体系</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    arr.<span class="built_in">at</span>(<span class="number">10</span>) = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未知异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::execptiom</code>是所有标准C++异常的父类，用所有异常的根基类的引用或指针进行捕捉，可以匹配所有继承体系的所有类型，通过根基类虚函数重写，完成多态的逻辑，最终通过多态完成对异常的精准处理</p><h2 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h2><p><strong>优点：</strong></p><ol><li>异常对象定义好了，相比错误码的方式可以清晰准确的展示出错误的各种信息，甚至可以包含堆栈调用的信息，这样可以帮助更好的定位程序的bug。 </li><li>返回错误码的传统方式有个很大的问题是，在函数调用链中，深层的函数返回了错误，需要得层层返回错误，最外层才能拿到错误。</li><li>很多的第三方库都包含异常。</li><li>很多测试框架都使用异常，这样能更好的使用单元测试等进行白盒的测试。 </li><li>部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理。比如T&amp;operator这样的函数，如果pos越界了只能使用异常或者终止程序处理，没办法通过返回值表示错误。</li></ol><p><strong>缺点：</strong></p><ol><li>异常会导致程序的执行流乱跳，并且非常的混乱，并且是运行时出错抛异常就会乱跳。会导致踪调试时以及分析程序时比较困难。 </li><li>异常会有一些性能的开销。但是在现代硬件速度很快的情况下，这个影响基本忽略不计。 </li><li>C++没有垃圾回收机制，资源需要自己管理，有了异常非常容易导致内存泄漏、死锁等异常安全问题，需要使用RAII来处理资源的管理问题。</li><li>C++标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱。 </li><li>异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func()、throw();的方式规范化。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;列表初始化&quot;&gt;&lt;a href=&quot;#列表初始化&quot; class=&quot;headerlink&quot; title=&quot;列表初始化&quot;&gt;&lt;/a&gt;列表初始化&lt;/h1&gt;&lt;p&gt;C++11：支持内置类型与自定义类型的列表初始化，其中自定义类型不是天然支持列表初始化，需要显示定义参数类型为&lt;code&gt;initiaizer_list&lt;/code&gt;的构造函数&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;A&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : _a(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    , _b(b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; _a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; _b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; arr[] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; c&amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; d = &amp;#123; &lt;span class=&quot;number&quot;&gt;1.2&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; arr1&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; arr2 = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pair&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; p = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; m = &amp;#123; &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A a = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;A &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从无序关联容器到哈希（及无序关联容器的模拟实现）</title>
    <link href="http://zhaozhuolin.com/2020/07/20200719.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200719.html</id>
    <published>2020-07-19T12:11:00.000Z</published>
    <updated>2023-05-07T11:18:08.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>基本使用与map相同，迭代器无反向迭代器，无序map，其体现在遍历时无序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testUMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">15</span>, <span class="number">1</span>));</span><br><span class="line">um.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">um[<span class="number">100</span>] = <span class="number">100</span>;<span class="comment">//插入</span></span><br><span class="line">um[<span class="number">15</span>] = <span class="number">15</span>;<span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line">um.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">2</span>;<span class="comment">//at无法插入，key不存在直接抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历无序</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator uit = um.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (uit != um.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; uit-&gt;first &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; uit-&gt;second &lt;&lt; endl;</span><br><span class="line">uit++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  uit = um.<span class="built_in">find</span>(<span class="number">100</span>);<span class="comment">//find找到返回指定位置迭代器，找不到则返回end迭代器</span></span><br><span class="line">cout &lt;&lt; um.<span class="built_in">count</span>(<span class="number">100</span>) &lt;&lt; endl;<span class="comment">//count返回元素个数，1或0</span></span><br><span class="line">cout &lt;&lt; uit-&gt;first &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; uit-&gt;second &lt;&lt; endl;</span><br><span class="line">uit = um.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; um.<span class="built_in">count</span>(<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (uit == um.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">99</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">48</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">27</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历无序</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::iterator uit = us.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (uit != us.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *uit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">uit++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="和有序容器的区别"><a href="#和有序容器的区别" class="headerlink" title="和有序容器的区别"></a>和有序容器的区别</h2><p>map, set, multi_map, multi_set：迭代器遍历有序，中序遍历；底层实现：红黑树；操作时间复杂度O(log<sub>2</sub>n)</p><p>unordered_map, unordered_set, unordered_multimap, unordered_multiset：</p><p>迭代器遍历无序，底层实现：哈希；操作时间复杂度O(1)</p><p>使用场景：</p><ol><li>对遍历顺序有要求：非unordered系列容器</li><li>对性能要求更高：unordered系列容器</li></ol><h1 id="底层结构：哈希结构"><a href="#底层结构：哈希结构" class="headerlink" title="底层结构：哈希结构"></a>底层结构：哈希结构</h1><p>通过构造一种存储结构，通过某种函数（hashFunc）使元素的存储位置和它的关键码之间能够建立一一映射的关系，那么在查找时就可以很快的找到该元素，一种以空间换时间的结构</p><p>映射关系：哈希函数</p><p>​哈希：把元素&#x2F;键值映射到空间的某一个位置</p><p>​特点：</p><ol><li>映射位置范围小于等于空间范围</li><li>映射位置尽量均匀</li><li>映射关系尽量简单</li></ol><p>常用的哈希函数：</p><ol><li>除留余数法（通用）：元素&#x2F;键值 % 空间的大小</li><li>直接定址法（只适合范围紧凑的数据，如字符）：线性函数，A * x(元素&#x2F;键值) + (B)偏置</li></ol><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>不同的数据映射到同一个位置即为哈希冲突</p><p>解决哈希冲突问题：</p><ol><li><p>闭散列（开放定址法）</p><p> 线性探测、二次探测</p></li><li><p>开散列（拉链法，哈希桶）</p></li></ol><p>负载因子：实际存放的元素个数 &#x2F; 空间大小（一般70%～80%）</p><p><strong>线性探测：</strong></p><ol><li>插入：<ol><li>通过哈希函数计算哈希位置</li><li>如果当前位置为空，则进行插入操作</li><li>如果位置不为空，则从当前位置开始，找到第一个空的位置，再进行插入操作</li></ol></li><li>查找：<ol><li>通过哈希函数计算哈希位置</li><li>查看当前位置的数据是否和查找的数据相同，如果相同，则查找结束</li><li>如果不相同，则从当前位置继续向后查找，直到找到了数据或者走到了空的位置，则查找结束</li></ol></li><li>删除：假删除，通过设置状态数据，来标记数据是否可用<ol><li>进行查找操作</li><li>如果找到需要删除的数据，则对待删除数据所在位置进行删除状态标记</li></ol></li></ol><blockquote><p><strong>二次探测：每次偏移的位置的长度为上一次的平方</strong></p></blockquote><p><strong>开散列：</strong></p><ol><li>增容：<ol><li>遍历旧表中的每一个元素</li><li>计算每一个元素在新表中的位置</li><li>把元素重新挂载到新表中的对应位置</li></ol></li><li>迭代器++：<ol><li>_next非空：更新到_next</li><li>_next为空：</li></ol></li></ol><p><code>HashTable</code>: K, V, KeyOfValue, HashFun</p><ul><li>K：数据键值</li><li>V：键值对应的value， <code>unordered_map</code>–&gt;pair&lt;K, V&gt;、<code>unordered_set</code>—&gt;K</li><li>KeyOfValue：获取value对应的键值</li><li>HashFun：把键值K转换成整形数据（非整形数类型的转换，非整数–&gt;映射–&gt;整数）</li><li>哈希表迭代器：前置声明，友元类声明</li><li>成员：节点，哈希表指针</li><li>++操作：<ul><li>next是否非空，不为空：更新到next节点；为空：<ul><li>首先通过kov获取对应键值</li><li>通过hashFun计算键值对应的整数值</li><li>通过整数值计算当前节点在哈希表中的位置</li><li>从上一步计算位置的下一个位置开始，寻找第一个非空练表的头节点</li><li>如果没有找到，更新为空指针</li></ul></li></ul></li><li>begin：第一个非空链表的头节点</li><li>end：空节点</li></ul><p>哈希表（开散列）：可以存放任意类型的数据，如果键值类型为非数值类型，可以通过hashFun转换为整数值</p><p>插入、查找、删除：</p><ul><li>首先进行的操作为：通过键值计算位置</li><li>然后进行类似单链表的操作</li></ul><h1 id="unordered-map与unordered-set的模拟实现"><a href="#unordered-map与unordered-set的模拟实现" class="headerlink" title="unordered_map与unordered_set的模拟实现"></a>unordered_map与unordered_set的模拟实现</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>unordered_map和unordered_set的底层均由同一个哈希表实现，本次实现使用开散列哈希桶的结构，其结构大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span></span><br><span class="line">&#123;</span><br><span class="line">V _value;</span><br><span class="line">HashNode&lt;V&gt;* _next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HashNode</span>(<span class="type">const</span> V&amp; val = <span class="built_in">V</span>())</span><br><span class="line">: _value(val)</span><br><span class="line">, _next(<span class="literal">nullptr</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//迭代器声明为友元类，原因是在迭代器类中，需要使用到哈希表来进行迭代器的自加操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">HashIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> HashIterator&lt;K, V, KeyOfValue, HF&gt; iterator;<span class="comment">//迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">CheckCapacity</span>();</span><br><span class="line"></span><br><span class="line">HF hf;</span><br><span class="line">KeyOfValue kov;</span><br><span class="line"><span class="type">size_t</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(value)) % _table.<span class="built_in">size</span>();<span class="comment">//计算当前元素对应的位置</span></span><br><span class="line"></span><br><span class="line">Node* cur = _table[idx];</span><br><span class="line"><span class="keyword">while</span> (cur)<span class="comment">//寻找是否有重复元素，重复则插入失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kov</span>(cur-&gt;_value) == <span class="built_in">kov</span>(value))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(value);<span class="comment">//头插</span></span><br><span class="line">cur-&gt;_next = _table[idx];</span><br><span class="line">_table[idx] = cur;</span><br><span class="line">_size++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span>；</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">size_t getNextSize(size_t n);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_size == _table.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newSize = <span class="built_in">getNextSize</span>(_size);<span class="comment">//获取下一个表的大小值</span></span><br><span class="line">vector&lt;Node*&gt; newTable;</span><br><span class="line">newTable.<span class="built_in">resize</span>(newSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历旧表中的非空单链表</span></span><br><span class="line">KeyOfValue kov;</span><br><span class="line">HF hf;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _table[i];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(cur-&gt;_value)) % newTable.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">cur-&gt;_next = newTable[idx];</span><br><span class="line">newTable[idx] = cur;</span><br><span class="line"></span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">_table[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">_table.<span class="built_in">swap</span>(newTable);<span class="comment">//交换新旧表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node*&gt; _table;</span><br><span class="line"><span class="type">size_t</span> _size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用序列容器vector来存放单链表表头，当遇到哈希冲突时，直接将插入元素头插在对应位置的单链表；其中K、V两个泛型参数在unordered_map中分别为K，<code>pair&lt;K, V&gt;</code>，在unordered_set中为K、K；泛型参数<code>KeyOfValue</code>则为不同的获取Key值的方法，通过仿函数对象来实现具体的方法</p><p>在unordered_map中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在unordered_set中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而泛型参数HF则为哈希函数，一般具有默认类型参数，也可指定，如在本次实现中为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashFunc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashFunc</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = s.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> seed = <span class="number">131</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * seed + (*str++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>哈希表的迭代器不能通过简单的指针来完成，必须对指针进行封装，封装成一个类，并开放begin，end，++等操作的接口，大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">HF</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> HashIterator&lt;K, V, KeyOfValue, HF&gt; Self;</span><br><span class="line"><span class="keyword">typedef</span> HashTable&lt;K, V, KeyOfValue, HF&gt; HT;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HashIterator</span>(Node* node, HT* ht)</span><br><span class="line">: _node(node)</span><br><span class="line">, _ht(ht)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> _node-&gt;_value;&#125;</span><br><span class="line"></span><br><span class="line">V* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> &amp;_node-&gt;_value;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it)&#123;<span class="keyword">return</span> _node != it._node;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; it)&#123;<span class="keyword">return</span> _node == it._node;&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++()&#123;<span class="built_in">add</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;<span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="built_in">add</span>(); <span class="keyword">return</span> *tmp;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_next)</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KeyOfValue kov;</span><br><span class="line">HF hf;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> idx = <span class="built_in">hf</span>(<span class="built_in">kov</span>(_node-&gt;_value)) % _ht-&gt;_table.<span class="built_in">size</span>();<span class="comment">//计算当前传入值对应的位置</span></span><br><span class="line">idx++;</span><br><span class="line"><span class="keyword">if</span> (idx == _ht-&gt;_table.<span class="built_in">size</span>())<span class="comment">//走到哈希表尾</span></span><br><span class="line">&#123;</span><br><span class="line">_node = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* cur = _ht-&gt;_table[idx];</span><br><span class="line"><span class="keyword">for</span> (; idx &lt; _ht-&gt;_table.<span class="built_in">size</span>(); idx++)<span class="comment">//找到下一个非空链表头</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ht-&gt;_table[idx])</span><br><span class="line">&#123;</span><br><span class="line">_node = _ht-&gt;_table[idx];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idx == _ht-&gt;_table.<span class="built_in">size</span>())<span class="comment">//检查是否已经遍历完成</span></span><br><span class="line">_node = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* _node;</span><br><span class="line">HT* _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，unordered_map和unordered_set的实现已经完成了大半，接下来创建这两个类分别对哈希表类进行封装即可</p><h2 id="unordered-set-1"><a href="#unordered-set-1" class="headerlink" title="unordered_set"></a>unordered_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span> = HashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Unordered_Set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> SetKeyOfValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> K&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, K, SetKeyOfValue, HF&gt;::iterator iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">end</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; value)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">insert</span>(value);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">erase</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashNode&lt;K&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">count</span>(key);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HashTable&lt;K, K, SetKeyOfValue, HF&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上，通过调用哈希表的不同接口，来实现unordered_set的各种功能</p><h2 id="unordered-map-1"><a href="#unordered-map-1" class="headerlink" title="unordered_map"></a>unordered_map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">HF</span> = HashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Unordered_Map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> MapKeyOfValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> K&amp; <span class="built_in">operator</span>()(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> value.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfValue, HF&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">end</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">insert</span>(value);&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)&#123;</span><br><span class="line">        pair&lt;iterator, <span class="type">bool</span>&gt; ret = _ht.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">erase</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashNode&lt;V&gt;* <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>&#123;<span class="keyword">return</span> _ht.<span class="built_in">count</span>(key);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfValue, HF&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p><a href="%5Bhttps://github.com/Latsummer/FinishedProducts/tree/master/unordered_map%E4%B8%8Eset/unordered_map%E4%B8%8Eset%5D(https://github.com/Latsummer/FinishedProducts/tree/master/unordered_map%E4%B8%8Eset/unordered_map%E4%B8%8Eset)">unordered_map与unordered_set的模拟实现 - GitHub</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;无序关联容器&quot;&gt;&lt;a href=&quot;#无序关联容器&quot; class=&quot;headerlink&quot; title=&quot;无序关联容器&quot;&gt;&lt;/a&gt;无序关联容器&lt;/h1&gt;&lt;h2 id=&quot;unordered-map&quot;&gt;&lt;a href=&quot;#unordered-map&quot; class=&quot;headerlink&quot; title=&quot;unordered_map&quot;&gt;&lt;/a&gt;unordered_map&lt;/h2&gt;&lt;p&gt;基本使用与map相同，迭代器无反向迭代器，无序map，其体现在遍历时无序&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;unordered_map&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testUMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	unordered_map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; um;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;make_pair&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//插入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	um.&lt;span class=&quot;built_in&quot;&gt;at&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//at无法插入，key不存在直接抛异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//遍历无序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	unordered_map&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator uit = um.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (uit != um.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		cout &amp;lt;&amp;lt; uit-&amp;gt;first &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;--&amp;gt;&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; uit-&amp;gt;second &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		uit++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  uit = um.&lt;span class=&quot;built_in&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//find找到返回指定位置迭代器，找不到则返回end迭代器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; um.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &amp;lt;&amp;lt; endl;&lt;span class=&quot;comment&quot;&gt;//count返回元素个数，1或0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; uit-&amp;gt;first &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;--&amp;gt;&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; uit-&amp;gt;second &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	uit = um.&lt;span class=&quot;built_in&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; um.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; (uit == um.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;()) &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>map和set的模拟实现</title>
    <link href="http://zhaozhuolin.com/2020/07/20200717.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200717.html</id>
    <published>2020-07-17T14:40:10.000Z</published>
    <updated>2023-05-07T11:18:08.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改造红黑树"><a href="#改造红黑树" class="headerlink" title="改造红黑树"></a>改造红黑树</h1><p>关联式容器存储的是K， V键值对，故在改造红黑树时，K为key类型，对于V来说，如果是set，则其为K类型，如果是map则为</p><p><code>pair&lt;K, V&gt;</code>，类型，除此之外，还需要一个仿函数类KeyOfValue来兼容map与set的大小比较，其迭代器也需要封装指针为一个类，迭代器的自加自减相当于红黑树的中序遍历</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> RBTIterator&lt;V&gt; Self;</span><br><span class="line"><span class="built_in">RBTIterator</span>(Node* node);</span><br><span class="line">  </span><br><span class="line">V&amp; <span class="keyword">operator</span>*();</span><br><span class="line"></span><br><span class="line">V* <span class="keyword">operator</span>-&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; it);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; it);</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++();</span><br><span class="line"></span><br><span class="line">Self <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">Self <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> RBNode&lt;V&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> RBTIterator&lt;V&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RBTree</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> V&amp; val)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">iterator <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">leftMost</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">Node* <span class="title">rightMost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="map和set的实现"><a href="#map和set的实现" class="headerlink" title="map和set的实现"></a>map和set的实现</h1><p>通过封装红黑树类，传入仿函数类和具体类型，修改等操作调用红黑树的接口，遍历操作通过迭代器完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfValue&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt-&gt;<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">insert</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;iterator, <span class="type">bool</span>&gt; ret = _rbt.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">Find</span>(<span class="built_in">pair</span>&lt;K, V&gt;(key, <span class="built_in">V</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfValue&gt;::iterator iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">Find</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _rbt.<span class="built_in">insert</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">RBTree&lt;K, K, SetKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="GitHub链接"><a href="#GitHub链接" class="headerlink" title="GitHub链接"></a>GitHub链接</h1><p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/map%E5%92%8Cset%E5%AE%9E%E7%8E%B0">map和set的实现-GitHub</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;改造红黑树&quot;&gt;&lt;a href=&quot;#改造红黑树&quot; class=&quot;headerlink&quot; title=&quot;改造红黑树&quot;&gt;&lt;/a&gt;改造红黑树&lt;/h1&gt;&lt;p&gt;关联式容器存储的是K， V键值对，故在改造红黑树时，K为key类型，对于V来说，如果是set，则其为K类型，如果是map则为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pair&amp;lt;K, V&amp;gt;&lt;/code&gt;，类型，除此之外，还需要一个仿函数类KeyOfValue来兼容map与set的大小比较，其迭代器也需要封装指针为一个类，迭代器的自加自减相当于红黑树的中序遍历&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从AVL树到红黑树(的插入)</title>
    <link href="http://zhaozhuolin.com/2020/07/20200713.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200713.html</id>
    <published>2020-07-13T10:01:11.000Z</published>
    <updated>2023-05-07T11:26:04.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><ul><li>左右子树都是AVL树</li><li>左右子树高度差的绝对值不超过1（-1&#x2F;0&#x2F;1）（一般：右子树高度 - 左子树高度）</li><li>如果一棵二叉搜索树树高度平衡的，它就是AVL树。如果它有n个节点，其高度可保持在O(log<sub>2</sub>N)，搜索时间复杂度O(log<sub>2</sub>N)</li></ul><span id="more"></span><h2 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line">T _value;</span><br><span class="line"><span class="type">int</span> _bf;<span class="comment">//平衡因子</span></span><br><span class="line">AVLNode&lt;T&gt;* _left;</span><br><span class="line">AVLNode&lt;T&gt;* _right;</span><br><span class="line">AVLNode&lt;T&gt;* _parent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVLNode</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">: _value(val)</span><br><span class="line">, _bf(<span class="number">0</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><blockquote><p>插入节点后：必须要更新平衡因子</p><p>可能需要更新平衡因子的节点：</p><ol><li>新插入节点中所有足祖先节点</li><li>如果节点的子树高度发生变化，则需要更新</li></ol></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol><li><p>二叉搜索树的插入</p></li><li><p>从新插入的节点对应的父节点位置开始更新平衡因子</p></li><li><p>在第二步的过程中，平衡因子更新之后：</p><ol><li><p>平衡因子：0—&gt; 停止更新</p></li><li><p>平衡因子：-1&#x2F;1    —&gt;    继续向上更新</p></li><li><p>平衡因子：-2&#x2F;2    —&gt;    旋转</p><ol><li><p>单旋：</p><ol><li><p>左单旋：右边的右边高，<code>parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1</code></p><p> 修改链接：parent、subRL、subR</p><p> ​parent-&gt;_right : subRL、subR-&gt;left : parent</p><p> 更新平衡因子：parent、subR：0</p></li><li><p>右单旋：左边的左边高，<code>parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1</code></p><p> 修改链接：subL、subLR、parent</p><p> ​parent-&gt;left : subLR、subL-&gt;right : parent</p><p> 更新平衡因子：parent、subL：0</p></li></ol></li><li><p>双旋：</p><ol><li><p>左右双旋：左边的右边高，<code>parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1</code></p><p> 修改链接：subL、subLR、parent</p><p> ​左旋：以subL为轴</p><p> ​右旋：以parent为轴</p><p> 重新更新平衡因子：</p><p> if(subLR-&gt;bf &#x3D;&#x3D; -1)</p><p> ​subL-&gt;bf &#x3D; 0, parent-&gt;bf &#x3D; 1;</p><p> else if(subLR-&gt;bf &#x3D;&#x3D; 1)</p><p> ​subL-&gt;bf &#x3D; -1, parent-&gt;bf &#x3D; 0;</p></li><li><p>右左双旋右边的左边高，<code>parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1</code></p><p> 修改链接：parent、subRL、subR</p><p> ​右旋：以subR为轴</p><p> ​左旋：以parent为轴</p><p> ​重新更新平衡因子：</p><p> ​if(subRL-&gt;bf &#x3D;&#x3D; 1)</p><p> ​parent-&gt;bf &#x3D; -1, subR-&gt;bf &#x3D; 0;</p><p> else if(subRL-&gt;bf &#x3D;&#x3D; -1)</p><p> ​parent-&gt;bf &#x3D; 0, subR-&gt;bf &#x3D; 1;</p></li></ol></li></ol></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">parent = cur;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_value == val) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_value &lt; val) &#123;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_value &lt; val) &#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新 + 调整</span></span><br><span class="line"><span class="keyword">while</span> (parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.更新parent平衡因子</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">parent-&gt;_bf--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_bf++;</span><br><span class="line"><span class="comment">//2.判断是否需要继续更新</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>) &#123;<span class="comment">//被补齐了，parent的父节点左右子树高度未发生变化</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-1</span> || parent-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">cur = parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> || parent-&gt;_bf == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//调整</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//左边的左边高，右旋</span></span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//右边的右边高，左旋</span></span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//右边的左边高，右左双旋</span></span><br><span class="line">          Node* subR = parent-&gt;_right;</span><br><span class="line">          Node* subRl = subR-&gt;_left;</span><br><span class="line">          <span class="type">int</span> bf = subRL-&gt;_bf;</span><br><span class="line">          </span><br><span class="line"><span class="built_in">RotateR</span>(cur);</span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//调整平衡因子</span></span><br><span class="line">          <span class="keyword">if</span>(bf == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//subRL右子树高</span></span><br><span class="line">            subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">            parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(bf == <span class="number">-1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//subRL左子树高</span></span><br><span class="line">            parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">            subR-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//左边的右边高,左右双旋</span></span><br><span class="line"><span class="built_in">RotateL</span>(cur);</span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subR = parent-&gt;_right;</span><br><span class="line">Node* subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line">subR-&gt;_left = parent;</span><br><span class="line">parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subRL)</span><br><span class="line">subRL-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = subR;</span><br><span class="line">subR-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* g = parent-&gt;_parent;</span><br><span class="line">subR-&gt;_parent = g;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;_left == parent)</span><br><span class="line">g-&gt;_left = subR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">g-&gt;_right = subR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent-&gt;_parent = subR;</span><br><span class="line">parent-&gt;_bf = subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* subL = parent-&gt;_left;</span><br><span class="line">Node* subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line">subL-&gt;_right = parent;</span><br><span class="line">parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subLR)</span><br><span class="line">subLR-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = subL;</span><br><span class="line">subL-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* g = parent-&gt;_parent;</span><br><span class="line">subL-&gt;_parent = g;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;_left == parent)</span><br><span class="line">g-&gt;_left = subL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">g-&gt;_right = subL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent-&gt;_parent = subL;</span><br><span class="line">parent-&gt;_bf = subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ol><li>每个节点不是红色就是黑色</li><li>根结点是黑色的</li><li>如果一个节点是红色的，则它的两个孩子节点是黑色的</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点</li><li>每个叶子节点都是黑色的（空节点也可）</li></ol><blockquote><p>根是黑色的</p><p>红色不能连续，黑色可以连续</p><p>每条路径上，黑色节点个数相同</p><p>最长路径是最短路径的两倍（最短：全黑；最长：红黑相间）</p></blockquote><p><a href="https://github.com/Latsummer/FinishedProducts/tree/master/RBTree">一个红黑树的简单实现 - GitHub</a></p><h2 id="节点结构-1"><a href="#节点结构-1" class="headerlink" title="节点结构"></a>节点结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">BLACK,</span><br><span class="line">RED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBNode</span></span><br><span class="line">&#123;</span><br><span class="line">pair&lt;K, V&gt; _value;</span><br><span class="line">Color _color;</span><br><span class="line">RBNode&lt;K, V&gt; _parent;</span><br><span class="line">RBNode&lt;K, V&gt; _left;</span><br><span class="line">RBNode&lt;K, V&gt; _right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RBNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; value = <span class="built_in">pair</span>&lt;K, V&gt;())</span><br><span class="line">: _value(value)</span><br><span class="line">, _color(RED)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>不能改变当前结构中的黑色节点的个数，除了祖父节点为根节点的情况</p><ul><li>g：祖父</li><li>p：父亲</li><li>u：叔叔</li><li>cur：插入节点</li></ul><ol><li>搜索树的插入</li><li>判断是否需要调整：红色连续</li></ol><ul><li>cur在p左边，叔叔存在且为红色，将p、u置为黑色，g为红色</li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggnzzrztvuj31bo0toaak.jpg" alt="IMG_7063"><ul><li>cur在p左边，叔叔不存在，以g为轴心进行右旋，将g变红，将p变黑</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo07rykj1j31bo0to3z1.jpg" alt="IMG_7064"></p><ul><li>cur在p左边叔叔为黑色，以g为轴心进行右旋，将g变红，将p变黑</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo0c2ek0zj31bo0to0vf.jpg" alt="IMG_7065"></p><ul><li>cur在p右边，先以p为轴心左旋，交换p与cur指针，按照情况三处理</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggo0qurg82j31bo0tot9k.jpg" alt="IMG_7066"></p><ul><li><strong>p在g右边，则操作完全相反</strong></li></ul><p>代码如下，其中旋转部分代码与AVL树相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_header-&gt;_parent == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//空树</span></span><br><span class="line">   Node* root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">   root-&gt;_color = BLACK;<span class="comment">//根为黑色</span></span><br><span class="line"></span><br><span class="line">   _header-&gt;_parent = root;</span><br><span class="line">   root-&gt;_parent = _header;</span><br><span class="line"></span><br><span class="line">   _header-&gt;_left = root;</span><br><span class="line">   _header-&gt;_right = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非空树</span></span><br><span class="line">  Node* cur = _header-&gt;_parent;</span><br><span class="line">  Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur)</span><br><span class="line">  &#123;</span><br><span class="line">   parent = cur;</span><br><span class="line">   <span class="keyword">if</span> (cur-&gt;_value.first == val.first)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (cur-&gt;_value.first &lt; val.first)</span><br><span class="line">    cur = cur-&gt;_right;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    cur = cur-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">  <span class="keyword">if</span> (parent-&gt;_value.first &lt; val.first)</span><br><span class="line">   parent-&gt;_right = cur;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   parent-&gt;_left = cur;</span><br><span class="line"></span><br><span class="line">  cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调整:修改颜色，旋转</span></span><br><span class="line">  <span class="keyword">while</span> (cur != _header-&gt;_parent &amp;&amp; cur-&gt;_parent-&gt;_color == RED)</span><br><span class="line">  &#123;</span><br><span class="line">   Node* p = cur-&gt;_parent;</span><br><span class="line">   Node* g = p-&gt;_parent;</span><br><span class="line">   <span class="keyword">if</span> (g-&gt;_left == p)</span><br><span class="line">   &#123;</span><br><span class="line">    Node* u = g-&gt;_right;</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u-&gt;_color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">     u-&gt;_color = p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line"></span><br><span class="line">     cur = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//ub不存在或u存在且为黑色</span></span><br><span class="line">     <span class="keyword">if</span> (cur == p-&gt;_right)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">RotateL</span>(p);</span><br><span class="line">      <span class="built_in">swap</span>(cur, p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//cur在p左边,右旋+修改颜色</span></span><br><span class="line">     <span class="built_in">RotateR</span>(g);</span><br><span class="line">     p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span><span class="comment">//p在g右边</span></span><br><span class="line">   &#123;</span><br><span class="line">    Node* u = g-&gt;_left;</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u-&gt;_color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">     u-&gt;_color = p-&gt;_color = BLACK;</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line">     cur = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span> (cur == p-&gt;_left)</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">RotateR</span>(p);</span><br><span class="line">      <span class="built_in">swap</span>(cur, p);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">RotateL</span>(g);</span><br><span class="line">     g-&gt;_color = RED;</span><br><span class="line">     p-&gt;_color = BLACK;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将根置为黑</span></span><br><span class="line">  _header-&gt;_parent-&gt;_color = BLACK;</span><br><span class="line">  <span class="comment">//更新头的左右指针</span></span><br><span class="line">  _header-&gt;_left = <span class="built_in">leftMost</span>();</span><br><span class="line">  _header-&gt;_right = <span class="built_in">rightMost</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;左右子树都是AVL树&lt;/li&gt;
&lt;li&gt;左右子树高度差的绝对值不超过1（-1&amp;#x2F;0&amp;#x2F;1）（一般：右子树高度 - 左子树高度）&lt;/li&gt;
&lt;li&gt;如果一棵二叉搜索树树高度平衡的，它就是AVL树。如果它有n个节点，其高度可保持在O(log&lt;sub&gt;2&lt;/sub&gt;N)，搜索时间复杂度O(log&lt;sub&gt;2&lt;/sub&gt;N)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>set与map的基本使用及特性</title>
    <link href="http://zhaozhuolin.com/2020/07/20200712.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200712.html</id>
    <published>2020-07-12T09:08:00.000Z</published>
    <updated>2023-05-07T11:18:08.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><ol><li>实现—&gt;目前使用搜索树实现（红黑树）</li><li>底层是一个存放KV结构的搜索树，但是此处K、V相同</li><li>set中只需要存放value</li><li>set中不能存放重复的元素</li><li>set中的元素不能修改，不支持修改的操作</li><li><strong>set默认比较是小于</strong>，可以通过修改仿函数，修改比较逻辑</li><li>迭代器遍历有序：底层顺序是二叉搜索树的中序遍历</li><li>迭代器只能读取内容，不能修改内容</li><li>插入：如果用迭代器指定插入位置，最终实际的插入位置可能不是指定的位置，此处的位置只是一个建议，新的元素的插入位置必须符合搜索树的性质</li><li>删除会导致当前删除位置的迭代器失效，但是不影响其他位置的迭代器</li><li>find：找到返回元素的迭代器，未找到返回end迭代器</li><li>count：获取指定元素在set中的个数，根据性质4，只用两个值，1或0</li></ol><span id="more"></span><h2 id="基本使用与遍历"><a href="#基本使用与遍历" class="headerlink" title="基本使用与遍历"></a>基本使用与遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span> &#125;;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">copy</span><span class="params">(s2)</span></span>;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = s2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != s2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  it++;</span><br><span class="line">&#125;<span class="comment">//2,3,8,10,11</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::const_iterator cit = s2.<span class="built_in">cbegin</span>();</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::reverse_iterator rit = s2.<span class="built_in">rbegin</span>();<span class="comment">//11， 10， 8， 3， 2</span></span><br></pre></td></tr></table></figure><p>set元素不能被修改</p><p>遍历有序：搜索树的中序遍历</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span> &#125;;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,8,10,11</span></span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,6,8,10,11</span></span><br><span class="line">s2.<span class="built_in">insert</span>(s2.<span class="built_in">begin</span>(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">//itreator只是一个建议，新插入的元素不一定是指定位置，最终插入位置需要遵循搜索树的性质</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,6,8,10,11,15</span></span><br><span class="line"><span class="type">int</span> arr2[] = &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">0</span> &#125;;</span><br><span class="line">s2.<span class="built_in">insert</span>(arr2, arr2 + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//0,2,3,6,7,8,9,10,11,15,20</span></span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//set不会插入重复元素</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//0,2,3,6,7,8,9,10,11,15,20</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除时候传入的位置必须有效</span></span><br><span class="line">s2.<span class="built_in">erase</span>(<span class="number">10</span>);<span class="comment">//删除10</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//0,2,3,6,7,8,9,11,15,20</span></span><br><span class="line">s2.<span class="built_in">erase</span>(s2.<span class="built_in">begin</span>());<span class="comment">//删除最左节点</span></span><br><span class="line"><span class="built_in">PrntSet</span>(s2);<span class="comment">//2,3,6,7,8,9,10,11,15,20</span></span><br><span class="line"><span class="comment">//s2.erase(s2.end());//end指向最后一个元素的下一个位置，此时运行会报错</span></span><br><span class="line"><span class="comment">//PrntSet(s2);</span></span><br><span class="line">s2.<span class="built_in">erase</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">PrntSet</span>(s2);</span><br></pre></td></tr></table></figure><p>删除操作会导致当前位置的迭代器失效，不影响其他位置</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">10</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span> &#125;;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = s2.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (it != s2.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NONE&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it2 = s2.<span class="built_in">find</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (it2 != s2.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NONE&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//count返回：元素个数，存在返回1，否则0</span></span><br><span class="line">cout &lt;&lt; s2.<span class="built_in">count</span>(<span class="number">11</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2.<span class="built_in">count</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ol><li>实现：通过二叉搜索树实现（红黑树）</li><li>底层结构为存放kv键值对的搜索树，k和v不一定相同</li><li>map存放kv键值对，即pair数据</li><li>key不能重复，value可以重复</li><li>key不允许修改，value可以修改</li><li><strong>map默认比较是小于</strong>，按照key进行比较，可以通过修改仿函数，修改比较逻辑</li><li>迭代器遍历顺序：底层顺序是二叉搜索树的中序遍历，但是按照key的中序遍历进行</li><li>迭代器可以修改value，不能修改key</li><li>插入：如果用迭代器指定插入位置，最终实际的插入位置可能不是指定的位置，此处的位置只是一个建议，新的元素的插入位置必须符合搜索树的性质</li><li>删除会导致当前删除位置的迭代器失效，但是不影响其他位置的迭代器</li><li>find：找到返回元素的迭代器，未找到返回end迭代器，&#x3D;&#x3D;按照key查找&#x3D;&#x3D;</li><li>count：获取指定元素在set中的个数，根据性质4，只用两个值，1或0， &#x3D;&#x3D;按照key查找&#x3D;&#x3D;</li><li>operator[ ]：可读可写可插入</li><li>at：如果key不存在，抛异常</li></ol><h2 id="基本使用以及遍历"><a href="#基本使用以及遍历" class="headerlink" title="基本使用以及遍历"></a>基本使用以及遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; m;<span class="comment">//key：字符串，value：数值</span></span><br><span class="line">  vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">((string)<span class="string">&quot;abc&quot;</span> + (<span class="type">char</span>)(i + <span class="string">&#x27;0&#x27;</span>), <span class="number">5</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(p);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;((string)<span class="string">&quot;zzl&quot;</span>+ (<span class="type">char</span>)(i + <span class="string">&#x27;0&#x27;</span>), <span class="number">14</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>((string)<span class="string">&quot;xyz&quot;</span>+ (<span class="type">char</span>)(i + <span class="string">&#x27;0&#x27;</span>), <span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">  <span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">copy</span><span class="params">(m2)</span></span>;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; m2.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//30</span></span><br><span class="line">  </span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt;::iterator it = m2.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span>(it != m2.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    it++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt;::iterator it = m2.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">while</span>(it != m2.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    it-&gt;second = <span class="number">100</span>;<span class="comment">//map的非const迭代器支持修改value，但不支持修改key</span></span><br><span class="line">    it++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mm;</span><br><span class="line">  cout &lt;&lt; mm.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">//key不存在，抛异常</span></span><br><span class="line">  cout &lt;&lt; mm[<span class="number">2</span>] &lt;&lt; endl;<span class="comment">//key不存在，插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map中key不能重复，但是value可以</li><li>迭代器解引用类型：pair</li><li>迭代器遍历顺序：key的递增顺序</li><li>非const迭代器支持value修改，不支持key修改</li><li>at：key不存在，抛异常</li><li>operator[]：key不存在，插入</li></ul><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">pair&lt;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ret = m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">3</span>));<span class="comment">//插入成功</span></span><br><span class="line">cout &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;<span class="comment">//3---&gt;3</span></span><br><span class="line">cout &lt;&lt; ret.second &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">ret = m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">10</span>));<span class="comment">//key重复，插入失败</span></span><br><span class="line">cout &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;<span class="comment">//3---&gt;3</span></span><br><span class="line">cout &lt;&lt; ret.second &lt;&lt; endl;<span class="comment">//0</span></span><br></pre></td></tr></table></figure><p><code>pair&lt;iterator, bool&gt;</code>iterator</p><ul><li>map中kv键值对 对应的迭代器，bool：插入是否成功</li></ul><p>插入成功：iterator表示新插入的kv键值对的迭代器</p><p>插入失败：iterator表示已经存在的某个kv键值对的迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="type">int</span>, <span class="type">int</span>) m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1---&gt;1</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span>;<span class="comment">//2---&gt;2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//3---&gt;3</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">4</span>;<span class="comment">//4---&gt;4</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><code>value&amp; operator[](key)</code></p><p><code>(*((this-&gt;insert(make_pair(k, mapped_type())).first)).second</code></p><ol><li>创建一个kv键值对：key value 默认值</li><li>执行插入操作，插入第一步创建的kv键值对</li><li>获取插入接口返回值的第一个迭代器成员<ol><li><code>prir&lt;iterator,bool&gt;.first</code> —&gt; iterator —&gt; 指向map中的一个键值对</li><li>插入成功：返回新的kv键值对的迭代器</li><li>插入失败：返回已经存在的键值key的kv键值对的迭代器</li></ol></li><li>解引用第三步拿到的迭代器</li><li>获取迭代器指向的kv键值对的value</li></ol><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="type">int</span>, <span class="type">int</span>) m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1---&gt;1</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span>;<span class="comment">//2---&gt;2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//3---&gt;3</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">4</span>;<span class="comment">//4---&gt;4</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">m.<span class="built_in">erase</span>(it);</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<span class="comment">//删除会导致指向当前位置的迭代器失效</span></span><br></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="type">int</span>, <span class="type">int</span>) m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1---&gt;1</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span>;<span class="comment">//2---&gt;2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//3---&gt;3</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">4</span>;<span class="comment">//4---&gt;4</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line">it = m.<span class="built_in">find</span>(<span class="number">3</span>);<span class="comment">//按照key查找，存在返回指向目标的迭代器，否则返回end迭代器</span></span><br><span class="line">it = m.<span class="built_in">find</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">//按照key值查找，存在返回1，否则返回0</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">count</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h1 id="multiset和multimap"><a href="#multiset和multimap" class="headerlink" title="multiset和multimap"></a>multiset和multimap</h1><p>与set及map最大的区别是其元素可以重复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">-1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">18</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : s)</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//multimap不提供[]操作符重载，at函数</span></span><br><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : m)</span><br><span class="line">cout &lt;&lt; e.first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; e.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pair&lt;multimap&lt;int, int&gt;::iterator, multimap&lt;int, int&gt;::iterator&gt; p = m.equal_range(1);</span></span><br><span class="line"><span class="keyword">auto</span> p = m.<span class="built_in">equal_range</span>(<span class="number">1</span>);</span><br><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = p.first;</span><br><span class="line"><span class="keyword">while</span> (it != p.second)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;set&quot;&gt;&lt;a href=&quot;#set&quot; class=&quot;headerlink&quot; title=&quot;set&quot;&gt;&lt;/a&gt;set&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;实现—&amp;gt;目前使用搜索树实现（红黑树）&lt;/li&gt;
&lt;li&gt;底层是一个存放KV结构的搜索树，但是此处K、V相同&lt;/li&gt;
&lt;li&gt;set中只需要存放value&lt;/li&gt;
&lt;li&gt;set中不能存放重复的元素&lt;/li&gt;
&lt;li&gt;set中的元素不能修改，不支持修改的操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set默认比较是小于&lt;/strong&gt;，可以通过修改仿函数，修改比较逻辑&lt;/li&gt;
&lt;li&gt;迭代器遍历有序：底层顺序是二叉搜索树的中序遍历&lt;/li&gt;
&lt;li&gt;迭代器只能读取内容，不能修改内容&lt;/li&gt;
&lt;li&gt;插入：如果用迭代器指定插入位置，最终实际的插入位置可能不是指定的位置，此处的位置只是一个建议，新的元素的插入位置必须符合搜索树的性质&lt;/li&gt;
&lt;li&gt;删除会导致当前删除位置的迭代器失效，但是不影响其他位置的迭代器&lt;/li&gt;
&lt;li&gt;find：找到返回元素的迭代器，未找到返回end迭代器&lt;/li&gt;
&lt;li&gt;count：获取指定元素在set中的个数，根据性质4，只用两个值，1或0&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>位图、布隆过滤器与大数据处理</title>
    <link href="http://zhaozhuolin.com/2020/07/20200710.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200710.html</id>
    <published>2020-07-10T01:39:01.000Z</published>
    <updated>2023-05-07T11:18:08.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>每一个比特位来表示当前比特位对应的数据是否存在，存在为1，不存在为0</p><p>整数数组：</p><ol><li>整数位置：n&#x2F;32</li><li>整数位置中具体的bit位置：n%32</li></ol><ul><li>右移相当于除，右移n位 &#x3D;&#x3D; 数字➗2^n^</li></ul><p>位图实现：哈希表</p><ol><li>实现：整数数组</li><li>数据单元是bit位</li><li>节省空间，一个字节可以存放8个整数的二值信息（存在与否），不存放数据本身</li><li>操作效率高，通过哈希映射获取位置，通过位运算执行操作， 时间效率O(1)</li><li>位置映射：<ol><li>获取整数位置，n &#x2F; 32</li><li>获取整数的比特位：n % 32</li></ol></li><li>位图需要的空间大小和数据的范围有关，和数据本身大小没有关系</li><li>适合的场景：数据不重复，信息简单</li></ol><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BitMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BitMap</span>(<span class="type">size_t</span> range)</span><br><span class="line">&#123;</span><br><span class="line">_bit.<span class="built_in">resize</span>(range / <span class="number">32</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询: Test</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//整数位置</span></span><br><span class="line"><span class="type">int</span> idx = n &gt;&gt; <span class="number">5</span>;<span class="comment">//等价于n/32</span></span><br><span class="line"><span class="type">int</span> bitIdx = n % <span class="number">32</span>;</span><br><span class="line"><span class="comment">//获取对应二进制值</span></span><br><span class="line"><span class="keyword">if</span> ((_bit[idx] &gt;&gt; bitIdx) &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储: Set</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> idx = n / <span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> bitIdx = n % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">_bit[idx] |= (<span class="number">1</span> &lt;&lt; bitIdx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除: Reset</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> idx = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> bitIdx = n % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">_bit[idx] &amp;= ~(<span class="number">1</span> &lt;&lt; bitIdx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; _bit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>多个位置映射来记录数据是否存在，不能直接支持删除操作，可以通过将每个比特为扩展为一个整形，作为数据的计数器，添加元素加一，删除减一，但会多占用几倍的存储空间，并且其仍不能保证某个数据一定存在，同时该方式存在计数回绕</p><p>m：布隆过滤器的长度，n：插入元素个数，p：误报率<br>$$<br>m&#x3D;-\frac {nlnp}{(ln2)^2}<br>$$<br>k：哈希函数个数<br>$$<br>k&#x3D;\frac mnln 2<br>$$<br>缺陷：</p><ol><li>有误判率，即存在假阳性，即不能准确判断元素是否在集合中(补救方法：再建立一个白</li></ol><p>名单，存储可能会误判的数据)</p><ol start="2"><li>不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素</li><li>如果采用计数方式删除，可能会存在计数回绕问题</li></ol><p>优点:</p><ol><li>增加和查询元素的时间复杂度为O(K)，k为哈希函数个数，一般比较小，与数据量大小无关</li><li>哈希函数相互之间没有关系，方便硬件并行运算</li><li>不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>能够承受一定范围内的误判，占用空间小</li><li>数据量大的时候，布隆过滤器可以表示全集</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">strToint1</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">strToint2</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">strToint3</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HF1</span>, <span class="keyword">class</span> <span class="title class_">HF2</span>, <span class="keyword">class</span> <span class="title class_">HF3</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//bit位数量 = hash函数个数 * 数据量 / ln2</span></span><br><span class="line"><span class="built_in">BloomFilter</span>(<span class="type">size_t</span> num)</span><br><span class="line">: _bit(<span class="number">5</span> * num)</span><br><span class="line">, _bitCount(<span class="number">5</span> * num)</span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HF1 hf1;</span><br><span class="line">HF2 hf2;</span><br><span class="line">HF3 hf3;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> hashCode1 = <span class="built_in">hf1</span>(value);</span><br><span class="line"><span class="type">size_t</span> hashCode2 = <span class="built_in">hf2</span>(value);</span><br><span class="line"><span class="type">size_t</span> hashCode3 = <span class="built_in">hf3</span>(value);</span><br><span class="line"></span><br><span class="line">_bit.<span class="built_in">Set</span>(hashCode1 % _bitCount);</span><br><span class="line">_bit.<span class="built_in">Set</span>(hashCode2 % _bitCount);</span><br><span class="line">_bit.<span class="built_in">Set</span>(hashCode3 % _bitCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HF1 hf1;</span><br><span class="line"><span class="type">size_t</span> hashCode1 = <span class="built_in">hf1</span>(value);</span><br><span class="line"><span class="keyword">if</span> (!_bit.<span class="built_in">Test</span>(hashCode1 % _bitCount))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">HF2 hf2;</span><br><span class="line"><span class="type">size_t</span> hashCode2 = <span class="built_in">hf2</span>(value);</span><br><span class="line"><span class="keyword">if</span> (!_bit.<span class="built_in">Test</span>(hashCode2 % _bitCount))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">HF3 hf3;</span><br><span class="line"><span class="type">size_t</span> hashCode3 = <span class="built_in">hf3</span>(value);</span><br><span class="line"><span class="keyword">if</span> (!_bit.<span class="built_in">Test</span>(hashCode3 % _bitCount))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitMap _bit;</span><br><span class="line"><span class="type">size_t</span> _bitCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对于大数据的处理"><a href="#对于大数据的处理" class="headerlink" title="对于大数据的处理"></a>对于大数据的处理</h1><p>常规的思路对于海量的数据来说，要么过于耗费时间，要么空间占用过高，而哈希思想可以在大数据中发挥很好的作用。</p><ul><li>比如：给定100亿个整数，想要找到其中只出现一次的整数</li></ul><p>此时即可以应用位图来操作，使用两个比特为来表示一个数据：</p><p>00：数据不存在；</p><p>01：出现过一次；</p><p>10：出现过多次；</p><p>将数据映射到位图中，如果对应位置的比特位为00，则将其改为01；如果对应位置为01，则将其改写为10，如果对应位置为10，则不做操作。</p><p>全部映射完成后，每两个比特位进行统计，找到对应比特位为01的那个数据即可</p><blockquote><p>假如要找到出现次数不超过两次的数据，则只需扩充10：出现过两次；11：出现过多次，映射完成之后统计10与01所对应的数据即可</p></blockquote><ul><li>有两个分别有100亿个整数的文件，设法找到两个文件的交集</li></ul><p>同样应用位图来处理，分别使用两个位图，将两个文件映射到其中去，然后两个位图进行按位与，统计结果中位图为1的比特位即为两个文件的交集</p><ul><li>给一个超过100G大小的log file, log中存着IP地址, 设计算法找到出现次数最多的IP地址？ 与上题条件相同，如何找到top K的IP？</li></ul><ol><li>哈希切割，将文件拆分成多个文件</li><li>将IP地址转化成整数，并模文件份数，将对应的IP放在对应的文件中</li><li>采用unordered_map统计每个文件中IP的出现次数，找到最多即可</li><li>topK问题则是在哈希切割之后，采用小堆，其节点为&lt;IP，次数&gt;键值对，同时需要一个仿函数类来实现大于比较，先用K个元素建堆，之后遍历所有元素，如果次数小于堆顶元素，不做任何操作，如果大于堆顶元素，删除堆顶元素并插入该元素，遍历完之后，堆内的元素即为topK</li></ol><p>综上所述，位图、布隆过滤器对于大数据的处理是极为合适的，只需要找到对应的处理办法，它（哈希）可以以比传统方法更高效的完成需求</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;位图&quot;&gt;&lt;a href=&quot;#位图&quot; class=&quot;headerlink&quot; title=&quot;位图&quot;&gt;&lt;/a&gt;位图&lt;/h1&gt;&lt;p&gt;每一个比特位来表示当前比特位对应的数据是否存在，存在为1，不存在为0&lt;/p&gt;
&lt;p&gt;整数数组：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整数位置：n&amp;#x2F;32&lt;/li&gt;
&lt;li&gt;整数位置中具体的bit位置：n%32&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;右移相当于除，右移n位 &amp;#x3D;&amp;#x3D; 数字➗2^n^&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;位图实现：哈希表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现：整数数组&lt;/li&gt;
&lt;li&gt;数据单元是bit位&lt;/li&gt;
&lt;li&gt;节省空间，一个字节可以存放8个整数的二值信息（存在与否），不存放数据本身&lt;/li&gt;
&lt;li&gt;操作效率高，通过哈希映射获取位置，通过位运算执行操作， 时间效率O(1)&lt;/li&gt;
&lt;li&gt;位置映射：&lt;ol&gt;
&lt;li&gt;获取整数位置，n &amp;#x2F; 32&lt;/li&gt;
&lt;li&gt;获取整数的比特位：n % 32&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;位图需要的空间大小和数据的范围有关，和数据本身大小没有关系&lt;/li&gt;
&lt;li&gt;适合的场景：数据不重复，信息简单&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的简单实现</title>
    <link href="http://zhaozhuolin.com/2020/07/20200704.html"/>
    <id>http://zhaozhuolin.com/2020/07/20200704.html</id>
    <published>2020-07-04T10:37:00.000Z</published>
    <updated>2023-05-07T11:18:08.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><ul><li>若左子树非空，则左子树上所有节点的值都小于根节点的值</li><li>若右子树非空，则右子树上所有节点的值都小根节点的值</li><li>左右子树也是二叉搜索树</li></ul><blockquote><p>上述条件反之亦可</p></blockquote><span id="more"></span><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>接近二分查找，最大查找次数为树的高度，平均查找次数Log<sub>2</sub> N</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line">  T _val;</span><br><span class="line">  BSTNode&lt;T&gt;* _left;</span><br><span class="line">  BSTNode&lt;T&gt;* _right;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">BSTNode</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">    :_val(val)</span><br><span class="line">    , _left(<span class="literal">nullptr</span>)</span><br><span class="line">    , _right(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> BSTNode&lt;T&gt; Node;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(cur-&gt;_val == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur;        </span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &lt; val)&#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &gt; val)&#123;</span><br><span class="line">        cur = cur-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>如果树中已存在需要插入的数据，则不重复插入</p><p>插入位置为：叶子，子树不完全的非叶子结点，即度为0或者1的节点位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    _root = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* cur = _root;</span><br><span class="line">  Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur)</span><br><span class="line">  &#123;</span><br><span class="line">    parent = ur;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_val == val)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &lt; val)</span><br><span class="line">      cur = cur-&gt;_right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cur = cur-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">  <span class="keyword">if</span>(parent-&gt;_val &lt; val)</span><br><span class="line">    parent-&gt;_right = Node;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    parent-&gt;_left = cur;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>有以下四种情况</p><pre><code>a. 要删除的结点无孩子结点b. 要删除的结点只有左孩子结点c. 要删除的结点只有右孩子结点d. 要删除的结点有左、右孩子结点</code></pre><ul><li><p>左子树：左子树的最右节点是所有左子树中最大的节点</p></li><li><p>右子树：右子树的最左节点是所有右子树中最小的节点</p></li></ul><p>删除度为2的节点：</p><ol><li>找到此节点中，左子树的最右节点或者右子树的最左节点</li><li>要删除的节点val替换为最左节点或者最右节点</li><li>真正要删除的是最左或者最右节点</li><li>此时问题转换为删除度为0或者度为1的节点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  Node* cur = _root;</span><br><span class="line">  Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur-&gt;_val == val) &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_val &lt; val)&#123;</span><br><span class="line">  parent = cur;</span><br><span class="line">  cur = cur-&gt;_right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  parent = cur;</span><br><span class="line">  cur = cur-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否找到需要删除的节点</span></span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//删除操作</span></span><br><span class="line">  <span class="comment">//1. 叶子</span></span><br><span class="line">  <span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == _root)</span><br><span class="line">  &#123;</span><br><span class="line">  _root = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">parent-&gt;_left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent-&gt;_right = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.左孩子为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == _root)</span><br><span class="line">  _root = cur-&gt;_right;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">  parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.右孩子为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == _root)</span><br><span class="line">  _root = cur-&gt;_left;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">  parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.左右孩子都存在</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//a.照最左或最右节点</span></span><br><span class="line">  <span class="comment">//找右子树的最左节点</span></span><br><span class="line">  Node* leftMostChild = cur-&gt;_right;</span><br><span class="line">  Node* parent = cur;</span><br><span class="line">  <span class="keyword">while</span> (leftMostChild-&gt;_left)</span><br><span class="line">  &#123;</span><br><span class="line">  parent = leftMostChild;</span><br><span class="line">  leftMostChild = leftMostChild-&gt;_left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//b.值替换</span></span><br><span class="line">  cur-&gt;_val = leftMostChild-&gt;_val;</span><br><span class="line">  <span class="comment">//c.删除最左或最右节点</span></span><br><span class="line">  <span class="keyword">if</span> (parent-&gt;_left == leftMostChild)</span><br><span class="line">  parent-&gt;_left = leftMostChild-&gt;_right;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  parent-&gt;_right = leftMostChild-&gt;_right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> leftMostChild;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;若左子树非空，则左子树上所有节点的值都小于根节点的值&lt;/li&gt;
&lt;li&gt;若右子树非空，则右子树上所有节点的值都小根节点的值&lt;/li&gt;
&lt;li&gt;左右子树也是二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;上述条件反之亦可&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++多态的基本原理及使用</title>
    <link href="http://zhaozhuolin.com/2020/06/20200628.html"/>
    <id>http://zhaozhuolin.com/2020/06/20200628.html</id>
    <published>2020-06-28T09:33:20.000Z</published>
    <updated>2023-05-07T11:18:08.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态的概念、定义以及实现"><a href="#多态的概念、定义以及实现" class="headerlink" title="多态的概念、定义以及实现"></a>多态的概念、定义以及实现</h1><p>多种形态，当不同的对象去执行同一种行为时，产生的不同表现形态</p><p><strong>构成条件：</strong>在不同的继承关系的类对象，去调用同一函数，产生了不同的行为</p><ol><li>继承关系</li><li>必须通过基类的指针或者引用调用的虚函数，一般都是用父类指针&#x2F;引用指向父类以及子类实体，即都为切片行为</li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</li></ol><span id="more"></span><blockquote><p>必须同时满足以上条件，缺一不可</p></blockquote><p><strong>虚函数的重写：</strong>重写函数逻辑</p><p>构成虚函数重写条件：子类含有和父类接口完全相同的函数（返回值，函数名，参数完全相同），例外：协变，析构函数重写，如果不满足所有条件，但是函数名相同，则构成函数隐藏</p><blockquote><p>协变：返回值类型可以不同，但是返回值类型必须是父子关系</p></blockquote><p>注意：如果父类函数加了<code>virtual</code>声明，则子类接口完全一致的函数即使不加<code>virtual</code>也具有虚函数的属性，但是反过来不成立，建议一般对于所有的虚函数都加上<code>virtual</code></p><blockquote><p>非多态：看类型</p><p>多态：看实际指向的实体</p></blockquote><p><strong>析构函数重写：</strong></p><ol><li><p>只要父类的析构函数是虚函数，则子类的析构函数和父类的析构函数构成重写</p><p> 原因：编译器对继承关系下的所有类的析构函数的名字做了统一处理，保证了继承关系下所有的析构函数同名，一般把析构函数的名称统一处理成<code>destructor</code></p></li></ol><p><code>final</code>和<code>override</code>关键字：</p><ol><li><code>final</code>：修饰虚函数，表示该虚函数不能再被继承，其定义的函数不能被重写，体现实现继承</li><li><code>override</code>：检查派生类虚函数是否重写了某个虚函数，如果没有重写则编译报错，强制子类重写父类的某一个虚函数</li></ol><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类：包含纯函数的类，抽象类不能实例化对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//纯虚函数：没有函数体的虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//无法执行以下代码</span></span><br><span class="line">  <span class="comment">//A a;</span></span><br><span class="line">  <span class="comment">//a.fun();</span></span><br><span class="line">  </span><br><span class="line">  B b;</span><br><span class="line">  A* pb = &amp;b;</span><br><span class="line">  b.<span class="built_in">fun</span>();</span><br><span class="line">  pb-&gt;<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类存在意义，实现多态，其体现出接口继承</p><h1 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h1><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//包含隐藏成员变量，虚函数表指针</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure><p><strong>包含虚函数的类：</strong>类中包含一个隐含的成员变量，即虚表指针</p><p><strong>虚表指针：</strong>指向虚表的首地址，类型为二级指针，函数指针的指针</p><p><strong>虚表：</strong>存放虚函数指针的数组，类型为指针数组</p><ol><li>只存放虚函数的指针</li><li>普通函数不会存入虚表</li><li>如果子类重写了父类的虚函数，则子类虚表中对应位置使用子类虚函数指针覆盖</li><li>如果子类没有重写父类的任何虚函数，则子类完全继承父类虚表，不做任何修改</li><li>虚函数指针在虚表中的存放顺序和其声明&#x2F;定义的顺序一致</li><li>子类新定义的虚函数，其虚函数指针按照声明&#x2F;定义的顺序依次加入虚表的末尾</li><li>虚表一般以<code>nullptr</code>结束</li></ol><blockquote><p>只要类中包含虚函数，就会有虚表指针和虚表</p></blockquote><ul><li>虚表指针存在对象当中</li><li>虚表存放在代码段</li><li>虚函数存放在代码段</li></ul><p><strong>多态：看实际指向的实体</strong></p><p>多态原理：如果访问的为虚函数，则通过指针&#x2F;引用找到实际指向的实体，获取实体中的虚表指针，通过虚表指针访问虚表，在虚表中找到需要执行的虚函数指针，通过虚函数指针执行具体函数行为</p><h2 id="继承下的虚表"><a href="#继承下的虚表" class="headerlink" title="继承下的虚表"></a>继承下的虚表</h2><p><strong>单继承虚表</strong>：</p><ol><li>子类继承父类虚表</li><li>用重写的虚函数指针覆盖子类对应的虚函数指针</li><li>子类新定义的虚函数，其指针按照声明&#x2F;定义顺序存入虚表的末尾</li></ol><p><strong>多继承虚表：</strong></p><ol><li>虚表个数：等同于直接父类的个数</li><li>子类继承父类所有的虚表</li><li>用重写的虚函数指针覆盖对应父类的虚函数指针</li><li>子类新定义的虚函数，其函数指针按照声明&#x2F;定义的顺序存入第一个直接父类虚表的末尾</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;多态的概念、定义以及实现&quot;&gt;&lt;a href=&quot;#多态的概念、定义以及实现&quot; class=&quot;headerlink&quot; title=&quot;多态的概念、定义以及实现&quot;&gt;&lt;/a&gt;多态的概念、定义以及实现&lt;/h1&gt;&lt;p&gt;多种形态，当不同的对象去执行同一种行为时，产生的不同表现形态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构成条件：&lt;/strong&gt;在不同的继承关系的类对象，去调用同一函数，产生了不同的行为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承关系&lt;/li&gt;
&lt;li&gt;必须通过基类的指针或者引用调用的虚函数，一般都是用父类指针&amp;#x2F;引用指向父类以及子类实体，即都为切片行为&lt;/li&gt;
&lt;li&gt;被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="类与对象" scheme="http://zhaozhuolin.com/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++中的继承</title>
    <link href="http://zhaozhuolin.com/2020/06/20200626.html"/>
    <id>http://zhaozhuolin.com/2020/06/20200626.html</id>
    <published>2020-06-26T07:50:27.000Z</published>
    <updated>2023-05-07T11:18:08.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h1><p>类级别的代码复用</p><ol><li>继承方式：public、protected、private</li><li>protectde访问权限&#x2F;private访问权限：<ul><li>protected —&gt; 在当前类和子类中可见，在其他地方不可见</li><li>private —&gt; 在当前类中可见，在其他地方不可见</li></ul></li><li>父类成员在子类中的访问权限：min { 成员在父类中的原始访问权限，继承方式 }</li><li>一般都是public继承，protected&#x2F;private继承很少使用&#x2F;几乎不用</li><li>默认继承方式：<ul><li>class定义的类默认继承方式是private</li><li>struct定义的类默认继承方式public</li></ul></li></ol><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>/<span class="keyword">struct</span> 类名 : 需要继承的类</span><br><span class="line">  子类/派生类  父类/基类</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nema:&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//类外不可见，内部和子类可见</span></span><br><span class="line">  string _name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">int</span> _age = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> _num = <span class="number">2020</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子类继承方式为protected&#x2F;private，从父类继承下来的所用成员的最低访问权限为protected&#x2F;private，所以在子类外不可见</p><table><thead><tr><th>类成员&#x2F;继承方式</th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td>基类的public成员</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的protected成员</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的private成员</td><td>派生类不可见</td><td>在派生类不可见</td><td>派生类不可见</td></tr></tbody></table><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>子类对象，指针，引用可以直接赋值给父类对象，指针，引用，<strong>此处不是隐式类型转换</strong></p><p>父类对象不能赋值给子类对象</p><p>父类指针、引用不能直接赋值给子类指针、引用。可以通过强制类型转换进行赋值，但是强制转换类型不安全，可能会导致越界，一般不使用强制类型转换，而是动态类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">Student st;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line">p = st;</span><br><span class="line">Person&amp; rs = st;</span><br><span class="line">Person* ptrrs = &amp;st;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不可行</span></span><br><span class="line">st = p;</span><br><span class="line">Student&amp; rp = p;</span><br><span class="line">Student* ptrp = &amp;p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不安全，可能会访问越界</span></span><br><span class="line">Student&amp; rp = (Student&amp;)p;</span><br><span class="line">Student* ptrp = (Student*)&amp;p;</span><br></pre></td></tr></table></figure><blockquote><p> 子类对应类型赋值给父类对应类型 —&gt; 切片：<strong>安全</strong>，不是隐式类型转换</p></blockquote><blockquote><p> 父类（指针&#x2F;引用）赋值给子类（指针&#x2F;引用） —&gt; 强制类型转换：<strong>不安全</strong>，存在访问越界的风险</p></blockquote><h1 id="同名隐藏"><a href="#同名隐藏" class="headerlink" title="同名隐藏"></a>同名隐藏</h1><p>父类和子类中有同名的成员，子类只能直接看到自己的成员，如果需要访问父类同名的成员，需要加父类作用域，不同的作用域下，含有同名成员，当前作用域下的成员就会隐藏其他作用域下的成员，<em>不是继承体系独有的</em>。</p><ul><li>成员变量隐藏：成员变量的名称相同</li><li>函数隐藏：函数名字相同，就会构成函数隐藏，与参数无关 —&gt; 这种情况是发生在父类和子类汇总，不在同一个作用域；函数重载：在同一个作用域，函数名相同，参数不同</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> _num)</span></span></span><br><span class="line"><span class="function">  </span>&#123; _num = _num; &#125;<span class="comment">//就近原则，此时为局部域，局部变量</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> _num = <span class="number">2020</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student st;</span><br><span class="line">cout &lt;&lt; st._num &lt;&lt; endl;</span><br><span class="line">st.<span class="built_in">setNum</span>(<span class="number">1999</span>);</span><br><span class="line">cout &lt;&lt; st._num &lt;&lt; endl;<span class="comment">//2020</span></span><br></pre></td></tr></table></figure><blockquote><p>同名隐藏：父类中的同名成员被子类中的同名成员隐藏</p></blockquote><p>父类、子类的作用域都是独立的，不同的作用域中可以有同名的成员，只要函数名相同，就会构成同名隐藏，不是函数重载</p><h1 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h1><blockquote><p> 编译器自动生成的默认构造自动调用父类的默认构造</p><p>显示定义的构造函数也自动调用父类的默认构造，在初始化列表中调用父类构造</p><p>父类成员必须要由父类的构造函数完成初始化</p></blockquote><p><strong>子类构造函数：</strong></p><ol><li>一定会调用父类的构造函数<ol><li>如果不显示调用，自动调用父类的默认构造</li><li>如果显示调用，则调用显示指定的父类构造</li></ol></li><li>继承自父类的成员变量，一定要通过父类的构造函数完成初始化，在子类的初始化列表中只能显示的初始化子类新增的成员变量</li><li>初始化顺序：一定是首先初始化父类成员，再去初始化子类成员</li><li>创建子类对象时，首先调用子类的构造函数，在子类构造函数的初始化列表中调用父类的构造函数，先执行父类的构造逻辑，然后再执行子类本身的构造逻辑</li></ol><blockquote><p>编译器自动生成的拷贝构造自动调用父类的拷贝构造</p><p>显示定义的拷贝构造，自动调用父类的默认构造，不是父类的拷贝构造</p><p>调用父类拷贝构造会有有切片操作</p></blockquote><p><strong>子类的拷贝构造：</strong></p><ol><li>默认行为（没有显示定义子类的拷贝构造）：父类的拷贝构造</li><li>显示定义子类拷贝构造默认行为（没有显示调用父类的拷贝构造）：父类的默认构造</li><li>在子类的拷贝构造中可以指定调用哪一个父类的构造函数，不一定是拷贝构造</li></ol><blockquote><p>编译器自动生成的赋值运算符重载函数自动调用父类的赋值运算符重载函数</p><p>子类赋值运算符和父类赋值运算符构成同名隐藏</p></blockquote><p><strong>子类的赋值运算符：</strong></p><ol><li>默认行为：调用父类的赋值运算符</li><li>显示定义：和父类的赋值运算符构成同名隐藏，如果需要调用父类的赋值运算符，需要指定父类的作用域</li><li>建议调用父类的赋值运算符：达到代码复用的目的</li></ol><blockquote><p>父类析构不需要显示调用，可能会导致资源二次释放的问题</p></blockquote><p><strong>子类析构函数：</strong></p><ol><li>编译器自动生成的析构函数自动调用父类的析构函数</li><li>显示定义的子类析构函数也会自动调用父类的析构函数</li><li>无论子类析构是否显示调用父类析构，编译器都会自动调用一次父类析构</li><li>子类析构和父类析构底层函数名相同，构成函数隐藏</li></ol><h1 id="继承与友元、静态成员"><a href="#继承与友元、静态成员" class="headerlink" title="继承与友元、静态成员"></a>继承与友元、静态成员</h1><p>友元关系不能继承，基类的友元不能访问子类的私有和保护成员</p><p>基类定义了static静态成员，则继承体系中只有一个这样的成员，无论派生出多少个子类，都只有一个static成员实例</p><h1 id="复杂继承"><a href="#复杂继承" class="headerlink" title="复杂继承"></a>复杂继承</h1><p><strong>单继承：</strong>一个子类只有一个直接父类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>多继承：</strong>一个子类有两个或以上直接父类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>菱形继承：</strong>多继承的一种特殊情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>菱形继承存在数据冗余和二义性的问题</p></blockquote><h2 id="菱形虚拟继承"><a href="#菱形虚拟继承" class="headerlink" title="菱形虚拟继承"></a>菱形虚拟继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>通过虚基表指针和虚基表，虚基表存放公共部分的偏移量，虚基表指针指向虚基表</p><p>虚基表</p><ol><li>相对于当前位置的偏移量</li><li>相对于公共部分偏移量</li></ol><p>菱形虚拟继承可以解决数据冗余和二义性</p><ol><li>通过虚基表指针和虚基表实现</li><li>如果需要访问公共成员：首先通过虚基表指针找到虚基表，读取偏移量，当前位置偏移指定的偏移量，找到公共部分成员，<strong>切片操作的过程</strong></li><li>通过指针大小，换取重复成员的大小</li><li>时间换空间的语法</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;继承概念&quot;&gt;&lt;a href=&quot;#继承概念&quot; class=&quot;headerlink&quot; title=&quot;继承概念&quot;&gt;&lt;/a&gt;继承概念&lt;/h1&gt;&lt;p&gt;类级别的代码复用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承方式：public、protected、private&lt;/li&gt;
&lt;li&gt;protectde访问权限&amp;#x2F;private访问权限：&lt;ul&gt;
&lt;li&gt;protected —&amp;gt; 在当前类和子类中可见，在其他地方不可见&lt;/li&gt;
&lt;li&gt;private —&amp;gt; 在当前类中可见，在其他地方不可见&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;父类成员在子类中的访问权限：min { 成员在父类中的原始访问权限，继承方式 }&lt;/li&gt;
&lt;li&gt;一般都是public继承，protected&amp;#x2F;private继承很少使用&amp;#x2F;几乎不用&lt;/li&gt;
&lt;li&gt;默认继承方式：&lt;ul&gt;
&lt;li&gt;class定义的类默认继承方式是private&lt;/li&gt;
&lt;li&gt;struct定义的类默认继承方式public&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="-类与对象 -C++" scheme="http://zhaozhuolin.com/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-C/"/>
    
  </entry>
  
</feed>
