<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小赵的学习笔记</title>
  
  
  <link href="http://zhaozhuolin.com/atom.xml" rel="self"/>
  
  <link href="http://zhaozhuolin.com/"/>
  <updated>2025-05-08T12:52:01.558Z</updated>
  <id>http://zhaozhuolin.com/</id>
  
  <author>
    <name>Latsummer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Benthos 框架下的限速器降级方案探索</title>
    <link href="http://zhaozhuolin.com/2025/05/20250508.html"/>
    <id>http://zhaozhuolin.com/2025/05/20250508.html</id>
    <published>2025-05-08T11:20:00.000Z</published>
    <updated>2025-05-08T12:52:01.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Benthos-框架下的限速器降级方案探索"><a href="#Benthos-框架下的限速器降级方案探索" class="headerlink" title="Benthos 框架下的限速器降级方案探索"></a>Benthos 框架下的限速器降级方案探索</h1><h2 id="rate-limit限速器"><a href="#rate-limit限速器" class="headerlink" title="rate_limit限速器"></a><code>rate_limit</code>限速器</h2><p>用于限制Benthos中并行组件(或跨实例)之间的共享资源使用, 一般使用<code>resources</code>配置, 如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rate_limit_resources:</span>  <span class="comment"># 固有字段, 表示限速器的资源</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">my_limite</span> <span class="comment"># 限速器资源标签</span></span><br><span class="line">    <span class="attr">local:</span> <span class="comment"># 本地限速器, 只能在单个实例内部生效</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">500</span>  <span class="comment"># 表示每秒500次处理</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure><p>一些内部组件支持直接在配置中带上<code>rate_limit</code>配置, 例如<code>http_client</code>, 其原理是在组件内部通过<code>*service.Resources</code>的<code>AccessRateLimit</code>方法直接获取对应资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">http_client:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">TODO</span></span><br><span class="line">    <span class="attr">verb:</span> <span class="string">GET</span></span><br><span class="line">    <span class="attr">rate_limit:</span> <span class="string">my_limite</span></span><br></pre></td></tr></table></figure><p>通过这种方式使用速率限制，可以保证输入仅以每秒 500 个请求的速率轮询 HTTP 源, 其内部实现大致如下</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">    service.RegisterBatchInput(<span class="string">"http_client"</span>, httpClientInputSpec(), newHttpClient)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpClientInputSpec</span><span class="params">()</span></span> *service.ConfigSpec {</span><br><span class="line">    <span class="comment">// 给出一个接受 rate_limit 配置的字段</span></span><br><span class="line">    <span class="keyword">return</span> service.NewConfigSpec().service.NewStringField(<span class="string">"rate_limit"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHtpClient</span><span class="params">(conf *service.ParsedConfig, mgr *service.Resources)</span></span> (*httpClientInput, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// 拿到限速器的标签</span></span><br><span class="line">    rate_limit, _ := conf.FieldString(<span class="string">"rate_time"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否在 rate_limit_resources 中注册对应标签的限速器</span></span><br><span class="line">    <span class="keyword">if</span> rate_limit != <span class="string">""</span> {</span><br><span class="line">        <span class="keyword">if</span> !mgr.HasRateLimit(rate_limit) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"rate_limit resources %v not found"</span>, rate_limit)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这里是发送HTTP请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpClient)</span></span> Send(ctx context.Content) ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> !h.waitForAccess(ctx) {</span><br><span class="line">        <span class="keyword">if</span> ctx.Err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errTimeout</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正调用限速器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpClient)</span></span> waitForAccess(ctx) <span class="type">bool</span> {</span><br><span class="line">    <span class="keyword">if</span> h.rateLimit == <span class="string">""</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">var</span> period time.Duration</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">        <span class="comment">// 获取限速器实例</span></span><br><span class="line"><span class="keyword">if</span> rerr := h.mgr.AccessRateLimit(ctx, h.rateLimit, <span class="function"><span class="keyword">func</span><span class="params">(rl service.RateLimit)</span></span> {</span><br><span class="line">period, err = rl.Access(ctx)</span><br><span class="line">}); rerr != <span class="literal">nil</span> {</span><br><span class="line">err = rerr</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">h.log.Errorf(<span class="string">"Rate limit error: %v\n"</span>, err)</span><br><span class="line">period = time.Second</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> period &gt; <span class="number">0</span> { <span class="comment">// 等待一定时间</span></span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(period):</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果组件内本身不提供<code>rate_limit</code>, 或不想在组件内写上这个配置并在初始化的时候使用, 可以通过使用<code>processor</code>结合限速器, 利用背压机制, 即下游阻塞上游也阻塞, 配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">csv:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./foo.csv</span></span><br><span class="line">  <span class="attr">processors:</span> <span class="comment"># 在Input组件csv之后紧接着一个 rate_limit 处理器, 利用背压机制间接限速 input</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">        <span class="attr">resource:</span> <span class="string">my_limit</span></span><br></pre></td></tr></table></figure><hr><p>以上所有限速器均为本地实现, 无法跨实例使用, 如果有次需求需要使用<code>Redis</code>或其他方案做限速器, 例如基于<code>Benthos</code>的<code>connect</code>的实现 <a href="https://github.com/redpanda-data/connect/blob/main/internal/impl/redis/rate_limit.go">https://github.com/redpanda-data/connect/blob/main/internal/impl/redis/rate_limit.go</a>, 不过需要注意其限速器只是限制速率, 功能上类似漏桶, 如果需要控制QPS需要另行实现令牌桶版本的限速器</p><h2 id="如何动态调整限速器的限速值"><a href="#如何动态调整限速器的限速值" class="headerlink" title="如何动态调整限速器的限速值"></a>如何动态调整限速器的限速值</h2><p>一个基本的限速器配置如下(框架原生)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rate_limit_resources:</span>  <span class="comment"># 固有字段, 表示限速器的资源</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">my_limite</span> <span class="comment"># 限速器资源标签</span></span><br><span class="line">    <span class="attr">local:</span> <span class="comment"># 本地限速器, 只能在单个实例内部生效</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">500</span>  <span class="comment"># 一下表示每秒500次处理</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure><p>如果想要动态的修改其中的 <code>count</code>字段, 可以考虑一下方法</p><ol><li><p>使用配置热重载的方式</p><p> 启动<code>Benthos</code>二进制时为框架加上 <code>-w</code> 或 <code>--watcher</code>, 让其可以在配置文件发生变化的时候自动重载配置, 使用此种方式时, 将会全量读取新的配置文件, 并且等待所有未确认消息处理完毕并确认后, 重新载入配置并重载组件. <strong>但是需要注意, 如果更新配置文件后存在配置错误将会导致Benthos服务不可用, 其将会持续读取配置文件并解析配置错误, 并不会沿用原有配置文件</strong></p></li><li><p>使用流模式 <code>streams</code> 启动, 通过 HTTP 动态修改配置</p><p> 配置中设置好api的端口, 或使用默认端口 <code>4195</code></p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span> <span class="comment"># 为benthos开启一个HTTP服务, 包含一些基础的请求访问, 例如 /ping /ready /version三个api, 可以通过访问/endpoints获取所有api</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:4195</span></span><br><span class="line">  <span class="attr">debug_endpoints:</span> <span class="literal">false</span> <span class="comment"># 是否开启debug模式</span></span><br></pre></td></tr></table></figure><p> 使用流模式启动</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./BenthosApp streams ./streams_config/*.yaml</span><br></pre></td></tr></table></figure><p> 获取所有流</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:4195/streams <span class="comment"># 获取所有流, 一个配置文件为一个流</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新指定流的配置, 需要传入完整的配置</span></span><br><span class="line">curl -X PUT http://localhost:4195/streams/one_stream --data-binary @- &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">input:</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看流的配置</span></span><br><span class="line">curl http://localhost:4195/streams/one_stream</span><br><span class="line"><span class="comment"># 修正指定流的配置</span></span><br><span class="line">curl -X PATCH http://localhost:4195/streams/one_stream \</span><br><span class="line">  --data-binary @- &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">{</span></span><br><span class="line"><span class="string">  "input": {</span></span><br><span class="line"><span class="string">    "my_input": {</span></span><br><span class="line"><span class="string">      "timeout": "92s"</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li></ol><hr><p> 以上方法, 均是通过修改配置的方式执行, 也就是说如果想要实现降级, <strong>需要配合外部监控平台</strong>, 通过监控pod状态或一些指标, 来<strong>从外部对Benthos的限速器进行修改</strong>, 那是否可能存在一种方法可以在运行时在程序内部自行修改呢?</p><p> 通过查阅Benthos相关文档可以得知, 当组件作为资源被引用时, 具备可重用性, 每种命名资源只会创建一个实例, 可以在多个位置使用, 原文如下 <a href="https://docs.redpanda.com/redpanda-connect/configuration/resources/">https://docs.redpanda.com/redpanda-connect/configuration/resources/</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resources <span class="keyword">are</span> components <span class="keyword">within</span> Redpanda <span class="keyword">Connect</span> that <span class="keyword">are</span> declared <span class="keyword">with</span> a <span class="keyword">unique</span> label <span class="keyword">and</span> can be referenced <span class="keyword">any</span> number <span class="keyword">of</span> times <span class="keyword">within</span> a configuration. <span class="keyword">Only</span> <span class="keyword">one</span> instance <span class="keyword">of</span> <span class="keyword">each</span> named resource <span class="keyword">is</span> created, but it <span class="keyword">is</span> safe <span class="keyword">to</span> use it <span class="keyword">in</span> multiple places <span class="keyword">as</span> they can be shared <span class="keyword">without</span> consequence.</span><br><span class="line">资源是 Redpanda <span class="keyword">Connect</span> 中的组件，它们使用唯一标签声明，并且可以在配置中引用任意次数。每个命名资源只会创建一个实例，但可以安全地在多个位置使用，因为它们可以共享而不会产生任何后果。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Some</span> components such <span class="keyword">as</span> caches <span class="keyword">and</span> rate limits can <span class="keyword">only</span> be created <span class="keyword">as</span> a resource. </span><br><span class="line">某些组件，如缓存和速率限制，只能作为资源创建。</span><br></pre></td></tr></table></figure><p> 以上说明可以简单的通过编写一个Benthos框架的代码验证</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">inputs:</span> <span class="comment"># 使用 broker 包裹两个完全一致的输入, 使用同一个标签的限速器 </span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">rdb_input:</span> {}</span><br><span class="line">        <span class="attr">processors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span> <span class="comment"># 给每条消息加上来源和当前时间</span></span><br><span class="line">              <span class="string">root.message</span> <span class="string">=</span> <span class="string">this.string()</span></span><br><span class="line">              <span class="string">root.source</span> <span class="string">=</span> <span class="string">"input_11111"</span></span><br><span class="line">              <span class="string">root.meta.process_time</span> <span class="string">=</span> <span class="string">now()</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">rdb_input:</span> {}</span><br><span class="line">        <span class="attr">processors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              root.message = this.string()</span></span><br><span class="line"><span class="string">              root.source = "input_22222"</span></span><br><span class="line"><span class="string">              root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="comment"># 自定义了一个 mu_local_limiter, 实现完全与框架原生的一致, 但是在初始化阶段打印了一个日志</span></span><br><span class="line"><span class="attr">rate_limit_resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">    <span class="attr">mut_rate_limit_local:</span>  <span class="comment"># 限速为每秒一条</span></span><br><span class="line">      <span class="attr">maxcount:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure><p>其中 <code>input</code> 组件为简单的从Redis中<code>RPop</code>内容, 大致如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rdbInput)</span></span> Read(ctx context.Context) (*service.Message, service.AckFunc, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接没有考虑Redis为空的情况, 在程序启动前给Redis提前填充了数据</span></span><br><span class="line">d, err := r.l.Pop(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">msg := service.NewMessage(d)</span><br><span class="line"><span class="keyword">return</span> msg, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>限速器组件实现大致如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">err := service.RegisterRateLimit(<span class="string">"mut_rate_limit_local"</span>,</span><br><span class="line">limiterConfig(), newMutRateLimitLocal)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMutRateLimitLocal</span><span class="params">(conf *service.ParsedConfig, mgr *service.Resources)</span></span> (service.RateLimit, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    limiter := &amp;my_limit{</span><br><span class="line">        log: mgr.Logger(),</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这里输出一下日志</span></span><br><span class="line">limiter.log.Infof(<span class="string">"I am Init !!!!!!"</span>)</span><br><span class="line"><span class="keyword">return</span> limiter, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>主程序启动前提前填充redis</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">l := lists.GetLists()</span><br><span class="line"><span class="comment">// 按顺序填充 1-100</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">_ = l.Push(context.Background(), []<span class="type">byte</span>(strconv.Itoa(i)))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">service.RunCLI(context.Background())</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>程序启动后观察日志输出如下</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"benthos_version"</span>:<span class="string">"v4.48.0"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Running main config from specified file"</span>,<span class="string">"path"</span>:<span class="string">"config.yaml"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"mu_local_limiter"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"I am Init !!!!!!"</span>,<span class="string">"path"</span>:<span class="string">"root.rate_limit_resources"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Listening for HTTP requests at: http://0.0.0.0:4195"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Input type rdb_input is now active"</span>,<span class="string">"path"</span>:<span class="string">"root.input.broker.inputs.0"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Input type rdb_input is now active"</span>,<span class="string">"path"</span>:<span class="string">"root.input.broker.inputs.1"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Output type stdout is now active"</span>,<span class="string">"path"</span>:<span class="string">"root.output"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"Launching a Benthos instance, use CTRL+C to close"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"1"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:51.181221041+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"3"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:52.181650517+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"4"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:53.181898361+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"0"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:54.18314283+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_22222"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"5"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:55.183107806+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"6"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:56.183515111+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"2"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:57.183863343+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_22222"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"7"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:58.184574384+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_22222"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"8"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-28T20:04:59.18518018+08:00"</span>},<span class="string">"source"</span>:<span class="string">"input_11111"</span>}</span><br></pre></td></tr></table></figure><p>可以得出以下现象:</p><ol><li>根据消息的乱序输出, 且来源都不一致, 说明两个<code>input</code>在同时工作</li><li>在乱序的情况下, 消息保持每秒一条的速率</li><li><p><code>rate_limit</code>组件的<code>I am Init !!!!!!</code> 日志仅输出了一次</p><p>由此说明<code>rate_limit</code>组件作为资源加载时, <strong>全局单例</strong>, 根据这个特性, 可以设计出一个速率可变的限速器, 其应该继承框架原本的<code>rate_limit</code>方法, 同时额外暴露一些修改限速值的方法, 包内直接单例模式, 例如</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gLimit mutRateLimitLocal</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mutRateLimitLocal <span class="keyword">struct</span> {</span><br><span class="line">log         *service.Logger</span><br><span class="line">mut         sync.Mutex</span><br><span class="line">curSize     <span class="type">int</span></span><br><span class="line">lastRefresh time.Time</span><br><span class="line"></span><br><span class="line">minSize   <span class="type">int</span></span><br><span class="line">benchSize <span class="type">int</span></span><br><span class="line">maxSize   <span class="type">int</span></span><br><span class="line">period    time.Duration</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 Benthos 的 RateLimit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mutRateLimitLocal)</span></span> Access(ctx context.Context) (time.Duration, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 Benthos 的 RateLimit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mutRateLimitLocal)</span></span> Close(_ context.Context) <span class="type">error</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加限速值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upgrade</span><span class="params">()</span></span> {</span><br><span class="line">gLimit.mut.Lock()</span><br><span class="line"><span class="keyword">defer</span> gLimit.mut.Unlock()</span><br><span class="line"></span><br><span class="line">ori := gLimit.benchSize</span><br><span class="line">gLimit.benchSize *= <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> gLimit.benchSize &gt; gLimit.maxSize {</span><br><span class="line">gLimit.benchSize = gLimit.maxSize</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">gLimit.log.Infof(<span class="string">"limiter upgrade from %d to %d"</span>, ori, gLimit.benchSize)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降低限速值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DownGrade</span><span class="params">()</span></span> {</span><br><span class="line">gLimit.mut.Lock()</span><br><span class="line"><span class="keyword">defer</span> gLimit.mut.Unlock()</span><br><span class="line"></span><br><span class="line">ori := gLimit.benchSize</span><br><span class="line">gLimit.benchSize /= <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> gLimit.benchSize &lt; gLimit.minSize {</span><br><span class="line">gLimit.benchSize = gLimit.minSize</span><br><span class="line">}</span><br><span class="line">gLimit.log.Infof(<span class="string">"limiter downGrade from %d to %d"</span>, ori, gLimit.benchSize)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>现在进行验证, 将<code>input</code>组件修改为单个组件, 保证数据的顺序性, 并在读取到特定内容时进行升级降级操作, 并观察输出, 代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rdbInput)</span></span> Read(ctx context.Context) (*service.Message, service.AckFunc, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">d, err := r.l.Pop(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">string</span>(d) == <span class="string">"5"</span> {</span><br><span class="line">mut_rate_limit_local.Upgrade()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">string</span>(d) == <span class="string">"10"</span> {</span><br><span class="line">mut_rate_limit_local.DownGrade()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">msg := service.NewMessage(d)</span><br><span class="line"><span class="keyword">return</span> msg, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>input</code>组件相关配置修改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">rate_limit:</span></span><br><span class="line">        <span class="attr">resource:</span> <span class="string">mu_local_limiter</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br></pre></td></tr></table></figure><p>由于数据是顺序输出的, 所以一定会先出现5, 后出现10, 此时启动程序观察输出为</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">{<span class="string">"message"</span>:<span class="string">"1"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:49.100212661+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"2"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:49.100586456+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"3"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:50.096771614+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"4"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:50.096806286+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"mu_local_limiter"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limiter upgrade from 2 to 4"</span>,<span class="string">"path"</span>:<span class="string">"root.rate_limit_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"5"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.097508536+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"6"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.097554408+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"7"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.097980122+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"8"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:51.098075563+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"mu_local_limiter"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limiter downGrade from 4 to 2"</span>,<span class="string">"path"</span>:<span class="string">"root.rate_limit_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"9"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:52.098415253+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"10"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:52.09846423+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"11"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:53.09906257+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"12"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:53.099122656+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"13"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:54.099771808+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"14"</span>,<span class="string">"meta"</span>:{<span class="string">"process_time"</span>:<span class="string">"2025-04-29T09:45:54.099812208+08:00"</span>}}</span><br></pre></td></tr></table></figure><p>可以观察到当读取到5之后, 限速从2升级为4, 消息速率有每秒两条变为每秒四条, 读取到10的时候降级为2, 此后维持2的限速运行.</p><h2 id="背压机制对消息处理速率的影响"><a href="#背压机制对消息处理速率的影响" class="headerlink" title="背压机制对消息处理速率的影响"></a>背压机制对消息处理速率的影响</h2><p>在Benthos中, 限速器组件能够限速的本质原理是, 通过一个给定的时间间隔, 以及在此时间间隔内, <code>Input</code>组件调用<code>Read</code>或<code>ReadBatch</code>(如果是<code>batchInput</code>)的次数, 来限制整体速率, 例如以下限速器配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rate_limit_resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">local_limiter</span></span><br><span class="line">    <span class="attr">local:</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure><p>表示限制每秒调用1次<code>Input</code>组件的<code>Read</code>方法或<code>ReadBatch</code>, 其原理是当调用次数超过一次后, 下次调用将会强制等待到大于给定等待时间间隔为止., 本质上其是依赖<code>Benthos</code>的背压机制来达到对消息进行限速的目的, 那如何验证这一机制? 可以简单的写一段Benthos配置来对其进行验证</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span> </span><br><span class="line">  <span class="attr">max_in_flight:</span> <span class="number">0</span> <span class="comment"># 表示不限制待确认消息的数量</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">1</span>  <span class="comment"># 保持每次只处理一个数据</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sleep:</span> <span class="comment"># 任何类型消息在这里将会 sleep 一秒钟</span></span><br><span class="line">        <span class="attr">duration:</span> <span class="string">1s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">my_stdout:</span> {}</span><br></pre></td></tr></table></figure><p>以上配置下, Benthos的输出为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:12.227711335+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:12.22788404+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:13.22813145+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"4"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:14.228667279+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"5"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:15.229376735+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"6"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:16.229656828+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"7"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:17.230157291+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"8"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:27:18.230574692+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure><p>可以观察到, 从第二条消息开始, 每条消息间隔了一秒钟才被取出来, 那如果将 <code>pipeline.threads</code> 参数变大, 则能代表每秒可以取出来更多消息, 这些消息等待一秒后, 才能取出来下一批消息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">5</span>  <span class="comment"># 每次同時处理5个数据</span></span><br></pre></td></tr></table></figure><p>修改后输出同理论一致, 第一秒取出了六条数据, 在第六条数据进入<code>processor</code>阶段时, 前五条数据都在sleep中, 整条链路被阻塞了, 直到下一秒, 前五条消息处理完毕后, 继续处理下五条</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214659776+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214329751+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214761512+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"4"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.214990298+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"5"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.215094723+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"6"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:15.215260697+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"7"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.214789636+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"8"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215151017+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"9"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215217328+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"10"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215294076+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"15"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215655737+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"11"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:16.215366317+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"12"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215124804+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"13"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215432139+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"14"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215565551+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"20"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216655332+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"19"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216587464+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"18"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216449435+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"17"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:18.216183862+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"16"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T14:30:17.215772375+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure><p>那这与<code>Input</code>组件的<code>max_in_flight</code>参数有什么关系? <strong>在<code>Input</code>组件中 <code>max_in_flight</code> 参数表示系统可接受的未确认消息的数量</strong>, 可以简单比喻成一个萝卜一个坑, 每次调用<code>Read</code>或<code>ReadBatch</code>都会得到一根萝卜, <code>max_in_flight</code> 表示有多少个坑, 当坑里的萝卜没有被拔出来时(消息未被确认), 无法把新的萝卜放进去, 可以通过以下方式简单验证</p><p>保持<code>pipeline.threads</code>不变, 修改<code>Input</code>组件的<code>max_in_flight</code>为1, 表示只接受一个未确认的消息, 配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sleep:</span></span><br><span class="line">        <span class="attr">duration:</span> <span class="string">1s</span></span><br></pre></td></tr></table></figure><p>此时输出将会是每秒钟一条消息, 因为只能接受一条未确认消息, 而每条消息又会等待1秒钟</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:40.014691582+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:41.015494086+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:42.016571178+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"4"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:43.017364452+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"5"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:44.017900917+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"6"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:45.018384+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"7"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T15:05:46.019051633+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure><p>同样的, <code>output</code>组件如果出现阻塞, 也会由于背压机制影响到上游的处理效率, 例如以下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.process_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sleep:</span></span><br><span class="line">        <span class="attr">duration:</span> <span class="string">1s</span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">my_stdout_batch:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">batching:</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">100</span>        <span class="comment"># 当收集到100条消息时处理批次</span></span><br><span class="line">      <span class="attr">byte_size:</span> <span class="number">1048576</span> <span class="comment"># 或当批次大小达到1MB时处理</span></span><br><span class="line">      <span class="attr">period:</span> <span class="string">"1s"</span>      <span class="comment"># 或每秒至少处理一次批次</span></span><br><span class="line">      <span class="attr">check:</span> <span class="string">""</span>         <span class="comment"># 可选的条件检查</span></span><br><span class="line">      <span class="attr">processors:</span> []    <span class="comment"># 可选的批次处理器</span></span><br></pre></td></tr></table></figure><p>由于<code>output</code>组件存在<code>1s</code>的超时, 所以整个链路将会变为两每秒钟一条消息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"1"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T16:04:43.781875208+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T16:04:45.782621816+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"message"</span><span class="punctuation">:</span><span class="string">"3"</span><span class="punctuation">,</span><span class="attr">"meta"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"process_time"</span><span class="punctuation">:</span><span class="string">"2025-04-29T16:04:47.783167403+08:00"</span><span class="punctuation">}</span><span class="punctuation">}</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="max-in-flight参数在-Input组件和output组件中的差异"><a href="#max-in-flight参数在-Input组件和output组件中的差异" class="headerlink" title="max_in_flight参数在 Input组件和output组件中的差异"></a><code>max_in_flight</code>参数在 <code>Input</code>组件和<code>output</code>组件中的差异</h4><h5 id="输入-Input-组件中的max-in-flight"><a href="#输入-Input-组件中的max-in-flight" class="headerlink" title="输入(Input)组件中的max_in_flight"></a>输入(Input)组件中的<code>max_in_flight</code></h5><p>在输入组件中，<code>max_in_flight</code>参数：</p><ul><li>设置一个限制，控制在任何给定时间内可以在Benthos流中流动的待确认消息数量</li><li>默认值为<code>0</code>，表示没有限制</li><li>一旦消息被确认(acknowledged)或拒绝(nacked)，它就不再被视为待处理</li><li>如果输入产生逻辑批次，则每个批次被视为对最大值的单次计数, 即限制的是<code>Read</code>和<code>ReadBatch</code>的调用次数而并非具体几条消息</li><li>警告：如果此字段限制的消息数量低于输出级别的批处理阈值，则输出级别的批处理策略将会停滞</li></ul><h5 id="输出-Output-组件中的max-in-flight"><a href="#输出-Output-组件中的max-in-flight" class="headerlink" title="输出(Output)组件中的max_in_flight"></a>输出(Output)组件中的<code>max_in_flight</code></h5><p>在输出组件中，<code>max_in_flight</code>参数：</p><ul><li>控制在给定时间内可以有多少消息或消息批次同时处理</li><li>增加此值可以提高吞吐量</li></ul></blockquote><h2 id="利用背压机制制作限速器"><a href="#利用背压机制制作限速器" class="headerlink" title="利用背压机制制作限速器"></a>利用背压机制制作限速器</h2><p>在上面的探索中, 已经大致搞清了Benthos框架原生的限速器的工作原理, 即利用框架的背压机制, 在下游制造压力, 传导到上游进而限制上游消息的读取速率, 根据这一原理, 可以实现这样一个<code>processor</code>组件:</p><ol><li>不处理消息, 将消息原样返回</li><li>记录消息个数或<code>Input</code>组件调用次数</li><li>如果大于指定速率, 就<code>sleep</code>, 将压力传导至上游<code>Input</code>组件</li><li>监测一些指标, 当达到某些条件时降低限速, 反之提高限速</li></ol><p>而这个组件可以放在</p><ol><li>紧跟着<code>Input</code>组件之后, 可以通过消息数, <code>Read</code>或<code>ReadBatch</code>的调用数, 系统的CPU占用/内存占用等不依赖具体消息内容的指标来进行降级升级</li><li>放在<code>Processor</code>组件的末端或中端, 可以通过消息设置的<code>meta</code>信息中处理耗时, 失败次数等与消息内容相关的指标进行升降级</li><li>同时放在<code>Input</code>和<code>Processor</code>中, 对多个指标进行监测</li></ol><p>而为了保证限速器的可重用性, 最好是将其放在<code>resources</code>中, 通过 <code>label</code>在需要使用的地方引用, 同时通过这种方式也可以保证限速器全局唯一, 如果需要多个限速器, 则创建多个<code>label</code>即可, 限速器应该使用<code>Processor</code>实现而非<code>batchProcessor</code>来确保其对消息限速的粒度为单条消息</p><blockquote><p>Benthos框架在batch组件和非batch组件会自动转换, 例如当<code>Input</code>是batch, <code>Processor</code>为非batch的时候, 此时<code>Input</code>每次都会读取一批消息, 一条一条的交给<code>Processor</code>, 直到所有消息都处理完毕, <code>Input</code>才会读取下一批消息, 所以使用非batch的<code>Processor</code>可以更好的控制单条消息速率</p></blockquote><h3 id="Example-利用背压机制结合对消息或CPU的监控制作的动态限速器"><a href="#Example-利用背压机制结合对消息或CPU的监控制作的动态限速器" class="headerlink" title="Example: 利用背压机制结合对消息或CPU的监控制作的动态限速器"></a>Example: 利用背压机制结合对消息或CPU的监控制作的动态限速器</h3><p>利用背压机制, 结合 <code>golang.org/x/time/rate</code> 制作一个基于令牌桶的限速器, 通过监测过去一段时间内的消息中特定错误出现频率或CPU使用率动态调节限速值</p><blockquote><p>选择<code>golang.org/x/time/rate</code>有一个比较重要的原因是其支持运行中修改限速值</p></blockquote><p>结构定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"benthos_test/lib/consts/errorx"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"github.com/redpanda-data/benthos/v4/public/service"</span></span><br><span class="line"><span class="string">"golang.org/x/time/rate"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">limitProcess <span class="keyword">struct</span> {</span><br><span class="line">log     *service.Logger</span><br><span class="line">limit   *rate.Limiter</span><br><span class="line">minEach rate.Limit</span><br><span class="line">maxEach rate.Limit</span><br><span class="line"></span><br><span class="line">wg           sync.WaitGroup</span><br><span class="line">shutdownChan <span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">cpuC         *cpuChecker</span><br><span class="line">msgC         *msgChecker</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cpuChecker <span class="keyword">struct</span> {</span><br><span class="line">checkInterval time.Duration</span><br><span class="line">cpuMax        <span class="type">float64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">msgChecker <span class="keyword">struct</span> {</span><br><span class="line">checkInterval time.Duration</span><br><span class="line">failureMax    <span class="type">float64</span></span><br><span class="line">sucCnt        atomic.Int32</span><br><span class="line">falCnt        atomic.Int32</span><br><span class="line">}</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在Benthos中注册时使用如下配置配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">limit_process:</span></span><br><span class="line">  <span class="attr">minEach:</span> <span class="number">1</span> <span class="comment"># 最低速率, 每秒钟 1 调小</span></span><br><span class="line">  <span class="attr">each:</span> <span class="number">2</span> <span class="comment"># 初始速率</span></span><br><span class="line">  <span class="attr">maxEach:</span> <span class="number">10</span> <span class="comment"># 最大速率</span></span><br><span class="line">  <span class="attr">capacity:</span> <span class="number">1</span> <span class="comment"># 令牌桶容量, 默认为 1 即可</span></span><br><span class="line">  <span class="attr">msgChecker:</span> <span class="comment"># 启用消息检查</span></span><br><span class="line">    <span class="attr">checkInterval:</span> <span class="string">5s</span> <span class="comment"># 每5s检查一次</span></span><br><span class="line">    <span class="attr">failureMax:</span> <span class="number">0.1</span> <span class="comment"># 允许的消息出现特定错误频率为10%, 超过则需要降级, 反之升级</span></span><br><span class="line">    <span class="attr">specialErr:</span> <span class="string">"xxx"</span> <span class="comment"># 这里可以在加个这个配置, 可以识别指定错误</span></span><br><span class="line"><span class="string">func</span> <span class="string">limitProcessConf()</span> <span class="string">*service.ConfigSpec</span> {</span><br><span class="line"><span class="string">res</span> <span class="string">:=</span> <span class="string">service.NewConfigSpec()</span></span><br><span class="line"><span class="string">res.Stable().Summary("limit</span> <span class="string">processor")</span></span><br><span class="line"><span class="string">res.Fields(</span></span><br><span class="line"><span class="string">service.NewFloatField("each")</span>,</span><br><span class="line"><span class="string">service.NewFloatField("minEach").Optional()</span>,</span><br><span class="line"><span class="string">service.NewFloatField("maxEach").Optional()</span>,</span><br><span class="line"><span class="string">service.NewIntField("capacity")</span>,</span><br><span class="line"><span class="string">service.NewObjectField("cpuChecker"</span>,</span><br><span class="line"><span class="string">service.NewDurationField("checkInterval")</span>,</span><br><span class="line"><span class="string">service.NewFloatField("cpuMax")</span>,</span><br><span class="line"><span class="string">).Optional()</span>,</span><br><span class="line"><span class="string">service.NewObjectField("msgChecker"</span>,</span><br><span class="line"><span class="string">service.NewDurationField("checkInterval")</span>,</span><br><span class="line"><span class="string">service.NewFloatField("failureMax")</span>,</span><br><span class="line"><span class="string">).Optional()</span>,</span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">return</span> <span class="string">res</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>构造Processor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLimitProcess</span><span class="params">(conf *service.ParsedConfig, mgr *service.Resources)</span></span> (service.Processor, <span class="type">error</span>) {</span><br><span class="line"> <span class="comment">// ... 读取配置</span></span><br><span class="line">res := &amp;limitProcess{</span><br><span class="line"><span class="comment">// ... 初始化</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心机制: 启动监测器</span></span><br><span class="line">res.checkerStart()</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在处理消息时, 记录消息错误, 并从令牌桶中请求令牌</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> Process(ctx context.Context, message *service.Message) (service.MessageBatch, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// 记录消息中的错误</span></span><br><span class="line">l.recordMsg(message.GetError())</span><br><span class="line">err := l.limit.Wait(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">l.log.Errorf(<span class="string">"limit process wait error, msg %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> service.MessageBatch{message}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> recordMsg(err <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">if</span> l.msgC == <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用了一个特定的错误, 例如 ErrGptLimit, 也可以添加配置在配置中设置, 再通过检查错误来记录</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; errors.Is(err, errorx.ErrGptLimit) {</span><br><span class="line">l.msgC.falCnt.Add(<span class="number">1</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">l.msgC.sucCnt.Add(<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在启动的监测器中, 定时监测状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> cpuCheckerLoop() {</span><br><span class="line"><span class="keyword">defer</span> l.wg.Done()</span><br><span class="line"><span class="comment">// 检查CPU使用率的代码...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitProcess)</span></span> msgCheckerLoop() {</span><br><span class="line"><span class="keyword">defer</span> l.wg.Done()</span><br><span class="line">tc := time.NewTicker(l.msgC.checkInterval)</span><br><span class="line"><span class="keyword">defer</span> tc.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-l.shutdownChan:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tc.C:</span><br><span class="line">sucCnt := l.msgC.sucCnt.Swap(<span class="number">0</span>)</span><br><span class="line">falCnt := l.msgC.falCnt.Swap(<span class="number">0</span>)</span><br><span class="line">allCnt := sucCnt + falCnt</span><br><span class="line"><span class="keyword">if</span> allCnt == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">failRate := <span class="type">float64</span>(falCnt) / <span class="type">float64</span>(allCnt)</span><br><span class="line"><span class="keyword">if</span> failRate &gt; l.msgC.failureMax { <span class="comment">// 超过给定频率就降级</span></span><br><span class="line">l.downgrade()</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">l.upgrade() <span class="comment">// 反之升级</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>最后在Benthos中使用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">rdb_input:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this.string()</span></span><br><span class="line"><span class="string">        root.meta.get_time = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">error_process_re</span> <span class="comment"># 这个插件经过调整, 会对前20条消息抛出错误 ErrGPTLimit</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">limit_process_re</span> <span class="comment"># 接近着会产生特定错误的组件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">bloblang:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root = this</span></span><br><span class="line"><span class="string">        root.meta.processed = now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">my_stdout:</span></span><br><span class="line">    <span class="attr">max_in_flight:</span> <span class="number">100</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">processor_resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">limit_process_re</span></span><br><span class="line">    <span class="attr">limit_process:</span></span><br><span class="line">      <span class="attr">minEach:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">each:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">maxEach:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">capacity:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">msgChecker:</span></span><br><span class="line">        <span class="attr">checkInterval:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">failureMax:</span> <span class="number">0.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">error_process_re</span></span><br><span class="line">    <span class="attr">error_process:</span> {}</span><br></pre></td></tr></table></figure><p>最终达成的效果是, 在前期会进行降级, 后期升级, 直到到达最大限制</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"error"</span>,<span class="string">"msg"</span>:<span class="string">"Failed to send message to my_stdout: gpt returns code 429"</span>,<span class="string">"path"</span>:<span class="string">"root.output"</span>}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor downgrade, each from 2.000 to 1.000, minEach 1.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">""</span>,<span class="string">"level"</span>:<span class="string">"error"</span>,<span class="string">"msg"</span>:<span class="string">"Failed to send message to my_stdout: gpt returns code 429"</span>,<span class="string">"path"</span>:<span class="string">"root.output"</span>}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"24"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:21.266977435+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:21.267019259+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"25"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:22.266920475+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:22.266979673+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor upgrade, each from 1.000 to 2.000, maxEach 10.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"55"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:33.766272232+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:33.766325021+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor upgrade, each from 4.000 to 8.000, maxEach 10.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"56"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:34.016153723+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:34.016195951+08:00"</span>}}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"57"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:34.265191395+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:34.265236555+08:00"</span>}}</span><br><span class="line">...</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"95"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:39.015952884+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:39.016003045+08:00"</span>}}</span><br><span class="line">{<span class="string">"@service"</span>:<span class="string">"benthos"</span>,<span class="string">"label"</span>:<span class="string">"limit_process_re"</span>,<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"msg"</span>:<span class="string">"limit processor upgrade, each from 8.000 to 10.000, maxEach 10.000"</span>,<span class="string">"path"</span>:<span class="string">"root.processor_resources"</span>}</span><br><span class="line">{<span class="string">"message"</span>:<span class="string">"96"</span>,<span class="string">"meta"</span>:{<span class="string">"get_time"</span>:<span class="string">"2025-04-30T15:28:39.141389556+08:00"</span>,<span class="string">"processed"</span>:<span class="string">"2025-04-30T15:28:39.141453408+08:00"</span>}}</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>利用Benthos本身背压机制所制作的限速器, 较为灵活, 适用性强, 可以放在处理链路中的任意环节, 通过对其上游施加压力达到限速效果, 但是需要注意以下几点</p><ol><li>限速逻辑需要可以支持运行时调整限速值</li><li>明确模块的升级/降级触发条件, 可以使资源的占用, 特定的错误, 处理的耗时等</li><li>如果需要分布式下的多副本共同限速, 需要使用支持分布式的限速器库或代码</li></ol><p>过程中的一些代码： <a href="/download/Benthos 框架下的限速器降级方案探索/benthos_test.zip" download>benthos_test.zip</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Benthos-框架下的限速器降级方案探索&quot;&gt;&lt;a href=&quot;#Benthos-框架下的限速器降级方案探索&quot; class=&quot;headerlink&quot; title=&quot;Benthos 框架下的限速器降级方案探索&quot;&gt;&lt;/a&gt;Benthos 框架下的限速器降级方案探索&lt;/h1&gt;&lt;h2 id=&quot;rate-limit限速器&quot;&gt;&lt;a href=&quot;#rate-limit限速器&quot; class=&quot;headerlink&quot; title=&quot;rate_limit限速器&quot;&gt;&lt;/a&gt;&lt;code&gt;rate_limit&lt;/code&gt;限速器&lt;/h2&gt;&lt;p&gt;用于限制Benthos中并行组件(或跨实例)之间的共享资源使用, 一般使用&lt;code&gt;resources&lt;/code&gt;配置, 如下&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;rate_limit_resources:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 固有字段, 表示限速器的资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;label:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;my_limite&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 限速器资源标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;local:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 本地限速器, 只能在单个实例内部生效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;count:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 表示每秒500次处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;interval:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;1s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一些内部组件支持直接在配置中带上&lt;code&gt;rate_limit&lt;/code&gt;配置, 例如&lt;code&gt;http_client&lt;/code&gt;, 其原理是在组件内部通过&lt;code&gt;*service.Resources&lt;/code&gt;的&lt;code&gt;AccessRateLimit&lt;/code&gt;方法直接获取对应资源&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;input:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;http_client:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;url:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;TODO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;verb:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;GET&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;rate_limit:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;my_limite&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这种方式使用速率限制，可以保证输入仅以每秒 500 个请求的速率轮询 HTTP 源, 其内部实现大致如下&lt;/p&gt;</summary>
    
    
    
    <category term="benthos" scheme="http://zhaozhuolin.com/categories/benthos/"/>
    
    
    <category term="benthos" scheme="http://zhaozhuolin.com/tags/benthos/"/>
    
    <category term="go" scheme="http://zhaozhuolin.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>benthos中SetStructured和SetBytes差异</title>
    <link href="http://zhaozhuolin.com/2025/05/20250507.html"/>
    <id>http://zhaozhuolin.com/2025/05/20250507.html</id>
    <published>2025-05-07T11:20:00.000Z</published>
    <updated>2025-05-08T12:12:32.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="benthos中SetStructured和SetBytes差异"><a href="#benthos中SetStructured和SetBytes差异" class="headerlink" title="benthos中SetStructured和SetBytes差异"></a>benthos中SetStructured和SetBytes差异</h1><p>在 Benthos 中，<code>message.SetStructured()</code> 和 <code>message.SetBytes()</code> 是两种不同的消息内容设置方式，它们会影响消息的内部表示形式以及后续处理器的行为。以下是它们的区别和 Benthos 的处理方式：</p><blockquote><p>在 Benthos 的 <code>message</code> 实现中，<strong>不能同时有效保存 <code>SetBytes</code> 和 <code>SetStructured</code> 的内容</strong>。两种设置方式会互相覆盖，最终生效的是最后一次调用的方法。</p><ul><li><strong>最后调用的方法决定当前有效形式</strong><br>  无论先调用哪个方法，​<strong>​只有最后一次设置的内容会生效​</strong>​，另一种形式会被隐式转换或丢弃。</li><li><strong>自动转换逻辑</strong><br>  当访问另一种形式时，Benthos 会按需触发转换</li></ul></blockquote><span id="more"></span><hr><h4 id="1-SetBytes-：原始字节数据"><a href="#1-SetBytes-：原始字节数据" class="headerlink" title="1. SetBytes()：原始字节数据"></a><strong>1. <code>SetBytes()</code>：原始字节数据</strong></h4><h5 id="行为特点："><a href="#行为特点：" class="headerlink" title="行为特点："></a>行为特点：</h5><ul><li><strong>直接设置消息的原始字节内容</strong>，适用于非结构化数据（如纯文本、二进制数据、未解析的 JSON 等）。</li><li>消息会被标记为 <code>part.ContentIsBytes()</code>，Benthos 将其视为<strong>不透明的二进制数据</strong>。</li><li>后续处理器如果需要结构化访问（如 JSON 解析、字段提取），会<strong>隐式尝试解析</strong>（如自动解析 JSON）。</li></ul><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置原始 JSON 字符串（未解析）</span></span><br><span class="line">err := msg.SetBytes([]<span class="type">byte</span>(<span class="string">`{"foo":"bar"}`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置纯文本</span></span><br><span class="line">err := msg.SetBytes([]<span class="type">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置二进制数据（如 Protobuf）</span></span><br><span class="line">err := msg.SetBytes(binaryData)</span><br></pre></td></tr></table></figure><h5 id="Benthos-处理："><a href="#Benthos-处理：" class="headerlink" title="Benthos 处理："></a>Benthos 处理：</h5><ul><li>如果后续处理器需要结构化数据（如 <code>jmespath</code> 或 <code>mapping</code> 处理器），Benthos 会<strong>临时解析字节内容</strong>（如将 JSON 字符串转为 <code>interface{}</code>）。</li><li>每次访问结构化内容时都会触发解析，可能带来少量性能开销。</li></ul><hr><h4 id="2-SetStructured-：结构化数据"><a href="#2-SetStructured-：结构化数据" class="headerlink" title="2. SetStructured()：结构化数据"></a><strong>2. <code>SetStructured()</code>：结构化数据</strong></h4><h5 id="行为特点：-1"><a href="#行为特点：-1" class="headerlink" title="行为特点："></a>行为特点：</h5><ul><li><strong>直接设置消息的结构化对象</strong>（如 <code>map[string]interface{}</code>、<code>[]interface{}</code> 等），跳过字节解析步骤。</li><li>消息会被标记为 <code>part.ContentIsStructured()</code>，Benthos 直接使用该结构，<strong>无需反复解析</strong>。</li><li>如果后续操作需要原始字节（如输出到文件/Kafka），Benthos 会<strong>按需序列化</strong>（如转为 JSON 字符串）。</li></ul><h5 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置结构化对象（如已解析的 JSON）</span></span><br><span class="line">data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"foo"</span>: <span class="string">"bar"</span>}</span><br><span class="line">err := msg.SetStructured(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数组</span></span><br><span class="line">err := msg.SetStructured([]<span class="keyword">interface</span>{}{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>})</span><br></pre></td></tr></table></figure><h5 id="Benthos-处理：-1"><a href="#Benthos-处理：-1" class="headerlink" title="Benthos 处理："></a>Benthos 处理：</h5><ul><li><p>结构化数据在处理器间传递时<strong>保持为对象</strong>，避免解析/序列化开销。</p></li><li><p>对结构化数据的操作（如字段修改）更高效：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接修改字段（无需解析）</span></span><br><span class="line">structured, _ := msg.AsStructured()</span><br><span class="line">structured.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{})[<span class="string">"foo"</span>] = <span class="string">"new_value"</span></span><br><span class="line">msg.SetStructured(structured)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-关键区别总结"><a href="#3-关键区别总结" class="headerlink" title="3. 关键区别总结"></a><strong>3. 关键区别总结</strong></h4><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center"><code>SetBytes()</code></th><th style="text-align:center"><code>SetStructured()</code></th></tr></thead><tbody><tr><td style="text-align:center"><strong>内部存储形式</strong></td><td style="text-align:center">原始字节（<code>[]byte</code>）</td><td style="text-align:center">结构化对象（<code>interface{}</code>）</td></tr><tr><td style="text-align:center"><strong>解析开销</strong></td><td style="text-align:center">按需触发解析（可能多次）</td><td style="text-align:center">无解析（直接使用对象）</td></tr><tr><td style="text-align:center"><strong>序列化开销</strong></td><td style="text-align:center">无（已是字节）</td><td style="text-align:center">按需序列化（如输出时转 JSON）</td></tr><tr><td style="text-align:center"><strong>适用场景</strong></td><td style="text-align:center">原始数据、二进制协议</td><td style="text-align:center">已解析的 JSON/结构化数据</td></tr><tr><td style="text-align:center"><strong>性能优化</strong></td><td style="text-align:center">适合一次性处理</td><td style="text-align:center">适合多次操作结构化内容</td></tr></tbody></table></div><hr><h4 id="4-Benthos-的隐式转换逻辑"><a href="#4-Benthos-的隐式转换逻辑" class="headerlink" title="4. Benthos 的隐式转换逻辑"></a><strong>4. Benthos 的隐式转换逻辑</strong></h4><p>当消息在处理器间传递时，Benthos 会自动处理两种形式的转换：</p><ol><li><p><strong><code>SetBytes</code> → 结构化访问</strong><br> 如果调用 <code>msg.AsStructured()</code>，Benthos 会尝试解析字节（如 JSON 解码）并缓存结果。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.SetBytes([]<span class="type">byte</span>(<span class="string">`{"foo":"bar"}`</span>))</span><br><span class="line">structured, _ := msg.AsStructured() <span class="comment">// 触发 JSON 解析</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>SetStructured</code> → 字节访问</strong><br> 如果调用 <code>msg.AsBytes()</code>，Benthos 会序列化结构化数据（如 JSON 编码）。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.SetStructured(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"foo"</span>: <span class="string">"bar"</span>})</span><br><span class="line">bytes, _ := msg.AsBytes() <span class="comment">// 触发 JSON 序列化</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="5-最佳实践建议"><a href="#5-最佳实践建议" class="headerlink" title="5. 最佳实践建议"></a><strong>5. 最佳实践建议</strong></h4><ol><li><p><strong>优先用 <code>SetStructured</code> 如果：</strong></p><ul><li>数据已经是结构化对象（如从 <code>json</code> 处理器解析后的结果）。</li><li>需要多次操作字段（避免重复解析）。</li></ul></li><li><p><strong>优先用 <code>SetBytes</code> 如果：</strong></p><ul><li>数据是原始字节且后续无需修改（如直接转发）。</li><li>处理非 JSON 数据（如 CSV、二进制协议）。</li></ul></li><li><p><strong>避免混用导致的性能问题：</strong></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：频繁切换会触发序列化/解析</span></span><br><span class="line">msg.SetBytes(...)</span><br><span class="line">msg.AsStructured() <span class="comment">// 解析</span></span><br><span class="line">msg.SetStructured(...)</span><br><span class="line">msg.AsBytes()      <span class="comment">// 序列化</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a><strong>示例场景</strong></h4><h5 id="场景-1：修改-JSON-字段"><a href="#场景-1：修改-JSON-字段" class="headerlink" title="场景 1：修改 JSON 字段"></a>场景 1：修改 JSON 字段</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高效做法（直接操作结构化数据）</span></span><br><span class="line">structured, _ := msg.AsStructured()</span><br><span class="line">structured.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{})[<span class="string">"foo"</span>] = <span class="string">"new_value"</span></span><br><span class="line">msg.SetStructured(structured) <span class="comment">// 无需序列化直到最终输出</span></span><br></pre></td></tr></table></figure><h5 id="场景-2：直接转发原始数据"><a href="#场景-2：直接转发原始数据" class="headerlink" title="场景 2：直接转发原始数据"></a>场景 2：直接转发原始数据</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无需解析时，保持为字节</span></span><br><span class="line">msg.SetBytes(rawData)</span><br><span class="line"><span class="comment">// ...直接传递给输出（如 Kafka）</span></span><br></pre></td></tr></table></figure><p>通过合理选择这两种方法，可以显著优化 Benthos 流程的性能。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;benthos中SetStructured和SetBytes差异&quot;&gt;&lt;a href=&quot;#benthos中SetStructured和SetBytes差异&quot; class=&quot;headerlink&quot; title=&quot;benthos中SetStructured和SetBytes差异&quot;&gt;&lt;/a&gt;benthos中SetStructured和SetBytes差异&lt;/h1&gt;&lt;p&gt;在 Benthos 中，&lt;code&gt;message.SetStructured()&lt;/code&gt; 和 &lt;code&gt;message.SetBytes()&lt;/code&gt; 是两种不同的消息内容设置方式，它们会影响消息的内部表示形式以及后续处理器的行为。以下是它们的区别和 Benthos 的处理方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Benthos 的 &lt;code&gt;message&lt;/code&gt; 实现中，&lt;strong&gt;不能同时有效保存 &lt;code&gt;SetBytes&lt;/code&gt; 和 &lt;code&gt;SetStructured&lt;/code&gt; 的内容&lt;/strong&gt;。两种设置方式会互相覆盖，最终生效的是最后一次调用的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最后调用的方法决定当前有效形式&lt;/strong&gt;&lt;br&gt;  无论先调用哪个方法，​&lt;strong&gt;​只有最后一次设置的内容会生效​&lt;/strong&gt;​，另一种形式会被隐式转换或丢弃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动转换逻辑&lt;/strong&gt;&lt;br&gt;  当访问另一种形式时，Benthos 会按需触发转换&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="benthos" scheme="http://zhaozhuolin.com/categories/benthos/"/>
    
    
    <category term="benthos" scheme="http://zhaozhuolin.com/tags/benthos/"/>
    
    <category term="go" scheme="http://zhaozhuolin.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言数据转发处理框架Benthos基础结构及配置</title>
    <link href="http://zhaozhuolin.com/2025/05/20250506.html"/>
    <id>http://zhaozhuolin.com/2025/05/20250506.html</id>
    <published>2025-05-06T11:20:00.000Z</published>
    <updated>2025-05-08T12:12:06.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言数据转发处理框架Benthos基础结构及配置"><a href="#Go语言数据转发处理框架Benthos基础结构及配置" class="headerlink" title="Go语言数据转发处理框架Benthos基础结构及配置"></a>Go语言数据转发处理框架<code>Benthos</code>基础结构及配置</h1><h2 id="benthos基本配置"><a href="#benthos基本配置" class="headerlink" title="benthos基本配置"></a>benthos基本配置</h2><p>benthos的配置文件格式为<code>yaml</code>, 按照逻辑基本可以划分为三个段落, <code>input</code>, <code>processor</code>, <code>output</code>, 数据自<code>input</code>接收, 经过 <code>processor</code>处理, 通过<code>output</code>产出, 另外还有一些<code>logger</code>等其余配置, 各个常用内容大致如下:</p><ul><li><code>input</code>: 数据的输入源</li><li><code>processors</code>: 一系列处理器</li><li><code>caches</code>: 一种键/值存储，可供某些组件用于诸如重复数据删除或数据连接等应用, 一般使用 <code>cache_resources</code> 配置</li><li><code>rate limits</code>: 限速器, 一般使用 <code>rate_limit_resources</code> 配置</li><li><code>buffers</code>: 缓冲区, 一般紧接着 <code>input</code>, 用于缓冲输入到下游之间的数据</li><li><code>metrics</code>: 审计内容</li><li><code>tracers</code>: 追踪器, 用于消息的跟踪</li></ul><p>一个基础的<code>benthos</code>配置文件可以参考如下</p><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span> <span class="comment"># 为benthos开启一个HTTP服务, 包含一些基础的请求访问, 例如 /ping /ready /version三个api, 可以通过访问/endpoints获取所有api</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:4195</span></span><br><span class="line">  <span class="attr">debug_endpoints:</span> <span class="literal">false</span> <span class="comment"># 是否开启debug模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据的输入, 这里使用了kafka组件</span></span><br><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">addresses:</span> [ <span class="string">TODO</span> ]</span><br><span class="line">    <span class="attr">topics:</span> [ <span class="string">foo</span>, <span class="string">bar</span> ]</span><br><span class="line">    <span class="attr">consumer_group:</span> <span class="string">foogroup</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># buffer用于在input之后的缓冲, 可以在此对数据分组或其他操作</span></span><br><span class="line"><span class="attr">buffer:</span></span><br><span class="line">  <span class="attr">none:</span> {}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道, 表示数据的处理流程, 数据将会按照processors中数组定义的顺序依次执行</span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      root.message = this</span></span><br><span class="line"><span class="string">      root.meta.link_count = this.links.length()</span></span><br><span class="line"><span class="string"></span>  <span class="bullet">-</span> <span class="attr">custom_process:</span> {}</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">resources:</span> <span class="string">some_processor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出器, 数据最终将通过此组件输出</span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">aws_s3:</span></span><br><span class="line">    <span class="attr">bucket:</span> <span class="string">TODO</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">'${! meta("kafka_topic") }/${! json("message.id") }.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各种resources定义, 以下的命名是benthos的关键字, 不能随便改</span></span><br><span class="line"><span class="comment"># 在这里可以预先定义好input, processor等, 并使用label标记, 随后在对应组件位置使用</span></span><br><span class="line"><span class="attr">input_resources:</span> []</span><br><span class="line"><span class="attr">cache_resources:</span> []</span><br><span class="line"><span class="attr">processor_resources:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lable:</span> <span class="string">some_processor</span></span><br><span class="line">    <span class="attr">do_something:</span> {}</span><br><span class="line"><span class="attr">rate_limit_resources:</span> []</span><br><span class="line"><span class="attr">output_resources:</span> []</span><br><span class="line"></span><br><span class="line"><span class="attr">logger:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">INFO</span></span><br><span class="line">  <span class="attr">static_fields:</span></span><br><span class="line">    <span class="string">'@service'</span><span class="string">:</span> <span class="string">benthos</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metrics:</span></span><br><span class="line">  <span class="attr">prometheus:</span> {}</span><br><span class="line"></span><br><span class="line"><span class="attr">shutdown_timeout:</span> <span class="string">20s</span></span><br><span class="line"><span class="attr">shutdown_delay:</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><blockquote><p>http.debug_endpoints 开关开启后, 将包含一下接口</p><ul><li><code>/debug/config/json</code>以 JSON 形式返回已加载的配置。</li><li><code>/debug/config/yaml</code>以 YAML 形式返回已加载的配置。</li><li><code>/debug/pprof/block</code>以 pprof 格式的块配置文件进行响应。</li><li><code>/debug/pprof/heap</code>以 pprof 格式的堆配置文件进行响应。</li><li><code>/debug/pprof/mutex</code>以 pprof 格式的互斥配置文件进行响应。</li><li><code>/debug/pprof/profile</code>以 pprof 格式的 CPU 配置文件进行响应。</li><li><code>/debug/pprof/goroutine</code>以 pprof 格式的 goroutine 配置文件进行响应。</li><li><code>/debug/pprof/symbol</code>查找请求中列出的程序计数器，并以将程序计数器映射到函数名称的表进行响应。</li><li><code>/debug/pprof/trace</code>以二进制形式响应执行跟踪。跟踪持续时间（以秒为单位，由 GET 参数指定），如果未指定，则为 1 秒。</li><li><code>/debug/stack</code>返回当前服务堆栈跟踪的快照。</li></ul></blockquote><h2 id="input组件"><a href="#input组件" class="headerlink" title="input组件"></a><code>input</code>组件</h2><p><code>input</code>组件分为<code>input</code>和<code>batchInput</code>, 定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AckFunc 是一个通用函数，由输入组件返回，用于消费消息的确认，每个消息被消费后必须调用一次。</span></span><br><span class="line"><span class="comment">// 这个函数的作用是确保消息来源接收到要么是确认（err 为 nil），要么是一个错误，错误要么作为 nack 传播到上游，要么触发重新投递相同消息的机制。</span></span><br><span class="line"><span class="comment">// 如果你的输入组件实现中没有具体处理 nack 的机制，那么你可以包装你的输入组件实现 AutoRetryNacks，以获得自动重试。</span></span><br><span class="line"><span class="keyword">type</span> AckFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Closer 由支持停止和清理其底层资源的组件实现</span></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// 关闭组件，直到底层资源被清理或上下文被取消时阻塞。若上下文被取消，则返回一个错误。</span></span><br><span class="line">Close(ctx context.Context) <span class="type">error</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Input 是由 Benthos 输入实现的接口。对 Read 的调用应当阻塞，直到接收到消息、连接丢失或提供的上下文被取消。 </span></span><br><span class="line"><span class="keyword">type</span> Input <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// 建立与上游服务的连接。在实例化读取器时，将始终首先调用 Connect，并将连续调用，直到返回 nil 错误。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="comment">// 提供的上下文仅在连接阶段期间保持打开，不应用于建立连接本身的生命周期。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="comment">// 一旦 Connect 返回 nil 错误，将调用 Read 方法，直到返回 ErrNotConnected 或读取器被关闭。</span></span><br><span class="line">Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从源中读取单个消息，以及在消息可以被确认（成功发送或故意过滤）或否定（未能处理或发送到输出）时调用的函数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="comment">// AckFunc 将至少为每条消息调用一次，但没有保证会在何时发生。如果您的输入实现没有特定的机制来处理 nack，您可以将输入实现包装在 AutoRetryNacks 中，以获得自动重试。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果此方法返回 ErrNotConnected，则在 Connect 返回 nil 错误之前将不会再次调用 Read。如果返回 ErrEndOfInput，则不再调用 Read，处理管道将优雅地终止。</span></span><br><span class="line">Read(context.Context) (*Message, AckFunc, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchInput 是一个接口，由 Benthos 输入实现，该输入以批量方式生成</span></span><br><span class="line"><span class="comment">// 消息，在处理和发送整个批次时希望作为一个逻辑组，而不是单个消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ReadBatch 的调用应该阻塞，直到准备好处理一批消息、连接丢失或</span></span><br><span class="line"><span class="comment">// 提供的上下文被取消。</span></span><br><span class="line"><span class="keyword">type</span> BatchInput <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// 建立与上游服务的连接。Connect 在读取器实例化时总是</span></span><br><span class="line"><span class="comment">// 首先被调用，并将持续调用，采用退避策略，直到返回 nil 错误。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提供的上下文仅在连接阶段持续有效，不应用于建立</span></span><br><span class="line"><span class="comment">// 连接本身的生命周期。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 一旦 Connect 返回 nil 错误，将会调用 Read 方法，直到</span></span><br><span class="line"><span class="comment">// 返回 ErrNotConnected，或关闭读取器。</span></span><br><span class="line">Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从源读取一批消息，以及一个函数，该函数将在整个批次</span></span><br><span class="line"><span class="comment">// 可以被成功确认（已成功发送或故意过滤）或被否认（处理失败或</span></span><br><span class="line"><span class="comment">// 无法发送到输出）时被调用。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// AckFunc 将至少为每个消息批次调用一次，但没有保证</span></span><br><span class="line"><span class="comment">// 何时会发生。如果您的输入实现没有特定的机制来处理 nack，</span></span><br><span class="line"><span class="comment">// 则可以使用 AutoRetryNacksBatched 来包装您的输入实现</span></span><br><span class="line"><span class="comment">// 以获得自动重试。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果此方法返回 ErrNotConnected，则 ReadBatch 不会</span></span><br><span class="line"><span class="comment">// 再次被调用，直到 Connect 返回 nil 错误。如果返回 ErrEndOfInput，</span></span><br><span class="line"><span class="comment">// 则将不再调用 Read，管道将优雅地终止。</span></span><br><span class="line">ReadBatch(context.Context) (MessageBatch, AckFunc, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">Closer</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>自定义的<code>Input</code>组件应该实现以上两种方法之一, 并在包的<code>init</code>方法中注册, 使用 <code>RegisterInput</code> 或 <code>RegisterBatchInput</code>, <code>Input</code>组件的工作流程大致如下:</p><ol><li>不断调用<code>Connect</code>方法, 直到其返回<code>nil</code></li><li>不断调用<code>Read</code>/<code>ReadBatch</code>方法, 直到其返回 <code>ErrNotConnected</code>, 此时将会重新从第一步开始, 返回<code>ErrEndOfInput</code>则会终止整个流水线, 或者当ctx超时</li><li>在退出时调用 <code>Close</code>方法</li></ol><p>一个<code>input</code>组件可参考如下, 其从<code>Redis</code>的<code>stream</code>中接收数据并处理</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">my_redis_input</span> <span class="comment"># 这个标签和input_resources中不是一个东西, 这个是方便做metric用的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用benthos自带的redis_streams组件</span></span><br><span class="line">  <span class="attr">redis_streams:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">tcp://localhost:6379</span></span><br><span class="line">    <span class="attr">streams:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">benthos_stream</span></span><br><span class="line">    <span class="attr">body_key:</span> <span class="string">body</span></span><br><span class="line">    <span class="attr">consumer_group:</span> <span class="string">benthos_group</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Optional list of processing steps</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">       root.document = this.without("links")</span></span><br><span class="line"><span class="string">       root.link_count = this.links.length()</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="关于input组件所返回的ackfun"><a href="#关于input组件所返回的ackfun" class="headerlink" title="关于input组件所返回的ackfun"></a>关于<code>input</code>组件所返回的ackfun</h3><h5 id="ackfunc的调用时机"><a href="#ackfunc的调用时机" class="headerlink" title="ackfunc的调用时机"></a>ackfunc的调用时机</h5><p>在Benthos中，消息确认函数(ackfunc)的调用时机与消息处理流程密切相关。当消息成功到达输出目的地并被确认后，ackfunc才会被调用, 这遵循Benthos的严格传递保证机制。</p><p>例如，在同步响应场景中，文档明确指出：</p><p>然而，重要的是要记住，由于Redpanda Connect的严格传递保证，响应消息实际上不会被返回，直到消息已经到达其输出目的地并且可以进行确认。</p><h5 id="错误处理与ackfunc的关系"><a href="#错误处理与ackfunc的关系" class="headerlink" title="错误处理与ackfunc的关系"></a>错误处理与ackfunc的关系</h5><p>当处理器中发生错误时，Benthos不会简单地丢弃消息，而是会标记这些消息并继续尝试发送它们：</p><p>一些处理器有可能失败的条件, Benthos不会丢弃失败的消息，而是仍然尝试将这些消息发送出去，并且有过滤、恢复或死信队列处理失败消息的机制。</p><h5 id="处理器错误与ackfunc"><a href="#处理器错误与ackfunc" class="headerlink" title="处理器错误与ackfunc"></a>处理器错误与ackfunc</h5><p>当处理器返回非nil的错误时，消息会被标记为失败，但仍会继续通过管道传递。这些错误不会直接传递到input的ackfunc中，而是会：</p><ol><li>增加相应处理器的错误指标</li><li>生成描述错误的调试级别日志</li><li>为消息添加错误标志</li></ol><h5 id="ackfunc捕获链路中错误信息"><a href="#ackfunc捕获链路中错误信息" class="headerlink" title="ackfunc捕获链路中错误信息"></a>ackfunc捕获链路中错误信息</h5><p>需要保证一下几点</p><ol><li>中间processor不重置消息</li><li>在output组件中将message中的错误信息返回</li></ol></blockquote><h3 id="broker包装器"><a href="#broker包装器" class="headerlink" title="broker包装器"></a><code>broker</code>包装器</h3><p>在正常情况下, 一个配置文件只允许存在一个<code>Input</code>组件, 如果有多个, 需要使用包装器<code>broker</code>来组合多个输入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># All config fields, showing default values</span></span><br><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">copies:</span> <span class="number">1</span> <span class="comment"># 如果副本数大于零，则列表将被复制该次数。例如，如果您的输入类型为 foo 和 bar，且“copies”设置为“2”，则最终将得到两个“foo”输入和两个“bar”输入</span></span><br><span class="line">    <span class="attr">inputs:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">amqp_0_9:</span> <span class="comment"># 这个是官网配置, 总是这就是一个组件</span></span><br><span class="line">          <span class="attr">urls:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">amqp://guest:guest@localhost:5672/</span></span><br><span class="line">          <span class="attr">consumer_tag:</span> <span class="string">benthos-consumer</span></span><br><span class="line">          <span class="attr">queue:</span> <span class="string">benthos-queue</span></span><br><span class="line">          <span class="comment"># Optional list of input specific processing steps</span></span><br><span class="line">        <span class="attr">processors:</span> <span class="comment"># 这里可以紧接一个processor来对数据做处理, 不影响接下来的流程</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">              root.message = this</span></span><br><span class="line"><span class="string">              root.meta.link_count = this.links.length()</span></span><br><span class="line"><span class="string">              root.user.age = this.user.age.number()</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">kafka:</span> <span class="comment"># 第二个输入源, kafka</span></span><br><span class="line">          <span class="attr">addresses:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">localhost:9092</span></span><br><span class="line">          <span class="attr">client_id:</span> <span class="string">benthos_kafka_input</span></span><br><span class="line">          <span class="attr">consumer_group:</span> <span class="string">benthos_consumer_group</span></span><br><span class="line">          <span class="attr">topics:</span> [ <span class="string">benthos_stream:0</span> ]</span><br><span class="line">    <span class="attr">batching:</span> <span class="comment"># 可以使用批处理字段为代理配置批处理策略。执行此作时，将合并来自所有子 Importing 的源。某些内置的 inputs 组件不支持基于代理的批处理，并在其文档中指定了这一点。</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">0</span> <span class="comment"># 指定批次应刷新的消息数量。如果设置为 0 则禁用基于计数的批次。</span></span><br><span class="line">      <span class="attr">byte_size:</span> <span class="number">0</span> <span class="comment"># 指定批次刷新的字节数。如果设置为 0 则禁用基于大小的批次刷新。</span></span><br><span class="line">      <span class="attr">period:</span> <span class="string">""</span> <span class="comment"># 无论批次大小如何，都应刷新不完整批次的时间段。其实就是超时时间, 可以使1s 1m, 15s这样的字符串</span></span><br><span class="line">      <span class="attr">check:</span> <span class="string">""</span> <span class="comment"># Bloblang 查询应返回一个布尔值，指示消息是否应结束批处理。</span></span><br><span class="line">      <span class="attr">processors:</span> [] <span class="comment"># No default (optional) # 刷新批次时应用的处理器列表。这允许您以合适的方式聚合和归档批次。请注意，所有生成的消息都将作为单个批次刷新，因此使用这些处理器将批次拆分为更小的批次是无操作的。这里可以接一些简短的处理组件, 例如format之类的</span></span><br></pre></td></tr></table></figure><h3 id="grnrtate组件"><a href="#grnrtate组件" class="headerlink" title="grnrtate组件"></a><code>grnrtate</code>组件</h3><p>使用无需上下文即可执行的Bloblang映射，按给定间隔生成消息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Config fields, showing default values</span></span><br><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">generate:</span></span><br><span class="line">    <span class="attr">mapping:</span> <span class="string">root</span> <span class="string">=</span> <span class="string">"hello world"</span> <span class="comment"># No default (required), 用于生成消息</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">1s</span> <span class="comment"># 时间间隔, 还可以是 1m, 1h, 0,30 */2 * * * *, '@every 1s' TZ=Europe/London 30 3-6,20-23 * * * 的形式</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">0</span> <span class="comment"># 可选生成的消息数量，如果设置为 0 以上，则会生成指定数量的消息，然后输入将关闭。</span></span><br><span class="line">    <span class="attr">batch_size:</span> <span class="number">1</span> <span class="comment"># 按照指定的时间间隔刷新到每批中应累积的生成消息的数量</span></span><br><span class="line">    <span class="attr">auto_replay_nacks:</span> <span class="literal">true</span> <span class="comment"># 是否应无限期地自动重放输出级别被拒绝（nack）的消息，如果拒绝的原因持续存在，最终会导致背压。如果设置为“否”，false这些消息将被删除。禁用自动重放可以大大提高高吞吐量流的内存效率，因为数据的原始形状可以在消费和更改时立即丢弃。</span></span><br></pre></td></tr></table></figure><blockquote><p>更多组件参考 <a href="https://docs.redpanda.com/redpanda-connect/components/inputs/about/">https://docs.redpanda.com/redpanda-connect/components/inputs/about/</a></p></blockquote><h2 id="processor组件"><a href="#processor组件" class="headerlink" title="processor组件"></a><code>processor</code>组件</h2><p>processor组件分为<code>Processor</code>和<code>BatchProcessor</code>, 定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Processor 是 Benthos 处理器的一种实现，用于处理单个消息。</span></span><br><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// Process 将一个消息处理成一个或多个结果消息，或在消息无法被处理时返回错误。若返回零条消息且错误为 nil，则表明该消息已被过滤。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当返回错误时，输入消息将继续沿管道传递但会带有错误标记（通过 *message.SetError），同时会记录指标和日志。失败的消息可以按照 https://docs.redpanda.com/redpanda-connect/configuration/error_handling 中的模式进行处理。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回的 Message 类型必须来源于提供的消息，且不可自定义 Message 实例。如需复制提供的消息，请使用 Copy 方法。</span></span><br><span class="line">Process(context.Context, *Message) (MessageBatch, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchProcessor 是 Benthos 处理器的一种实现，用于处理消息批次，这使得滑动窗口处理得以实现。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 消息批次必须由上游组件（如输入组件、缓冲组件等）创建，否则该处理器将只能处理包含单个消息的批次。</span></span><br><span class="line"><span class="keyword">type</span> BatchProcessor <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// Process a batch of messages into one或多个结果 batches，若整个批次无法被处理则返回错误。若返回零条消息且错误为 nil，则表明所有消息均被过滤。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提供的 MessageBatch 不得被修改，如需返回修改后的批次 Tortoise，必须创建一个切片的副本。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当返回错误时，所有输入消息将继续沿管道传递但会带有错误标记（通过 *message.SetError），同时会记录指标和日志。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如需向批次中的单个消息添加供下游处理的错误，使用 *message.SetError(err) 方法，并在结果批次中将其返回，同时错误参数为 nil。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回的 Message 类型必须来源于所提供的消息，不可自定义 Message 实例。如需复制提供的消息，请使用 Copy 方法。</span></span><br><span class="line">ProcessBatch(context.Context, MessageBatch) ([]MessageBatch, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">Closer</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果想要实现自定义<code>processor</code>直接实现以上两种方法之一即可, 需要注意的一些点为</p><ol><li><p>整个流程中, 如果某个或多个<code>Process</code>或<code>ProcessBatch</code>返回了非<code>nil</code>的<code>error</code>, <strong>不会导致数据处理流程中断,</strong> <strong>而是会继续流转</strong>, 直到最终走到<code>output</code>组件后, 层层返回<code>Ack</code>, 如果想要实现中间一个流程失败, 后续处理器都不处理或做其他处理等可以参考以下写法</p><ol><li><p>在<code>Process</code>方法中处理, 存在错误则直接跳过消息处理</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *myPerssor)</span></span> Process(ctx context.Context, msg *service.Message) (service.MessageBatch, <span class="type">error</span>) {</span><br><span class="line">err := msg.GetError() <span class="comment">// 从消息中获取错误, 如果获取到的非空, 就直接返回, 跳过该消息的处理</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>在配置中通过<code>catch</code>或<code>try</code>处理, 通过<code>catch</code>捕获失败的处理, 或通过<code>try</code>尝试处理</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">foo</span> <span class="comment"># 先使用 foo 处理器处理</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">catch:</span> <span class="comment"># 如果上一步处理错误, 将会执行 bar 和 baz</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">bar</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">baz</span></span><br><span class="line">    <span class="comment">#当消息离开 catch 块时, 错误标记将会被清除</span></span><br></pre></td></tr></table></figure> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">try:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Skip if processor_1 fails</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_3</span> <span class="comment"># Skip if processor_1 or processor_2 fails</span></span><br></pre></td></tr></table></figure> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">try:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_3</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">catch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">log:</span></span><br><span class="line">          <span class="attr">message:</span> <span class="string">"Processor ${!error_source_label()} failed due to: ${!error()}"</span></span><br></pre></td></tr></table></figure> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_3</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">catch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          root = this</span></span><br><span class="line"><span class="string">          root.meta.error = error()</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>switch</code>处理器检查错误</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_1</span> <span class="comment"># Processor that might fail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">switch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">errored()</span></span><br><span class="line">        <span class="attr">processors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">resource:</span> <span class="string">processor_2</span> <span class="comment"># Processes rerouted messages</span></span><br></pre></td></tr></table></figure></li><li><p>更错错误处理等参考 <a href="https://docs.redpanda.com/redpanda-connect/configuration/error_handling/">https://docs.redpanda.com/redpanda-connect/configuration/error_handling/</a></p></li></ol></li><li><p>在整个流程中, 消息始终存在一份, 如果没有特殊情况, 应该将输入修改后直接传出, 不能在消息内直接新建消息返回</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *myPerssor)</span></span> Process(ctx context.Context, msg *service.Message) (service.MessageBatch, <span class="type">error</span>) {</span><br><span class="line">err := msg.GetError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回消息中存储的结构化数据, 其中 Mut 后缀代表你可以直接对返回值进行修改</span></span><br><span class="line">    tmpTask, err := msg.AsStructuredMut()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    task := tmpTask.(*types.TaskProcess)</span><br><span class="line">    task.SomeVal = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接返回原始消息</span></span><br><span class="line">    <span class="keyword">return</span> service.MessageBatch{msg}, <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新set数据</span></span><br><span class="line">    msg.SetStructuredMut(newTask())</span><br><span class="line">    msg.SetStructuredMut(task)</span><br><span class="line">    <span class="keyword">return</span> service.MessageBatch{msg}, <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// !!! 不能这么干 !!!</span></span><br><span class="line">    <span class="keyword">return</span> service.MessageBatch{service.NewMessage([]<span class="type">byte</span>(<span class="string">"xxx"</span>))}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ol><h3 id="processor常见配置"><a href="#processor常见配置" class="headerlink" title="processor常见配置"></a><code>processor</code>常见配置</h3><p>处理器是通过 config 设置的，根据它们在配置中的位置，它们将在特定输入之后（在 input 部分中设置）、所有消息（在 pipeline 部分中设置）或特定输出之前（在 output 部分中设置）立即运行。大多数处理器适用于所有消息，并且可以放置在 pipeline 部分中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">my_cool_mapping</span></span><br><span class="line">      <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root.message = this</span></span><br><span class="line"><span class="string">        root.meta.link_count = this.links.length()</span></span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>pipeline</code>:</p><p>在 Redpanda Connect 配置中，<code>input</code>和<code>output</code>之间是一个<code>pipeline</code>部分。本节介绍将应用于所有消息且不绑定到任何特定 input 或 output 的处理器数组。</p><p>如果处理器占用大量 CPU，并且不依赖于某个特定的输入或输出，则它们最适合 pipeline 部分。使用 pipeline 部分是有利的，因为它允许您设置并行执行线程的显式数量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input:</span></span><br><span class="line">  <span class="attr">resource:</span> <span class="string">foo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">4</span> <span class="comment"># 如果字段 threads 设置为 -1（默认值），它将自动匹配可用的逻辑 CPU 数量</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        root = this</span></span><br><span class="line"><span class="string">        fans = fans.map_each(match {</span></span><br><span class="line"><span class="string">          this.obsession &gt; 0.5 =&gt; this</span></span><br><span class="line"><span class="string">          _ =&gt; deleted()</span></span><br><span class="line"><span class="string">        })</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">resource:</span> <span class="string">bar</span></span><br></pre></td></tr></table></figure></blockquote><p>也可以使用<code>processor</code>作为输出并配合<code>reject</code>, 前提是<code>processor</code>可以返回错误并且是唯一错误, 例如<code>Redis</code>的插入失败等, 配置如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">reject:</span> <span class="string">'failed to send data: ${! error() }'</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">try:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">redis:</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">tcp://localhost:6379</span></span><br><span class="line">            <span class="attr">command:</span> <span class="string">sadd</span></span><br><span class="line">            <span class="attr">args_mapping:</span> <span class="string">'root = [ this.key, this.value ]'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">root</span> <span class="string">=</span> <span class="string">deleted()</span></span><br></pre></td></tr></table></figure><p>以上配置描述的执行流程为</p><ol><li>如果<code>redis</code>处理器执行成功, 则执行 <code>mapping</code>处理器</li><li>如果<code>redis</code>处理器执行失败, <code>mapping</code>处理器将不会执行, 消息路由到<code>reject</code>输出, 其将会返回一个<code>Nack</code></li></ol><h4 id="switch组件"><a href="#switch组件" class="headerlink" title="switch组件"></a><code>switch</code>组件</h4><p>根据消息的内容有条件地处理消息, 对于每个 switch case，将执行一个 <code>Bloblang</code>查询 ，如果结果为 true（或检查为空），则对消息执行子处理器, 其字段如下</p><ul><li><code>[].check</code> 一个<code>bloblang</code>查询, 应返回 <code>true</code>/<code>false</code>, 如果留空，则 case 始终通过。如果检查映射引发错误，则消息将被标记为失败 ，并且不会针对任何其他case进行测试。</li><li><code>[].processors</code> 处理器集合, 将要对消息执行处理的处理器列表, 将会按顺序处理</li><li><code>[].fallthrough</code> 布尔值 如果此 case 通过消息，是否还应执行下一个 case</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">processors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">switch:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">this.user.name.first</span> <span class="type">!=</span> <span class="string">"George"</span></span><br><span class="line">          <span class="attr">processors:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">metric:</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">counter</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">MessagesWeCareAbout</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">processors:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">metric:</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">GeorgesAnger</span></span><br><span class="line">                <span class="attr">value:</span> <span class="string">${!</span> <span class="string">json("user.anger")</span> <span class="string">}</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">root</span> <span class="string">=</span> <span class="string">deleted()</span></span><br></pre></td></tr></table></figure><h4 id="branch组件"><a href="#branch组件" class="headerlink" title="branch组件"></a><code>branch</code>组件</h4><p><code>branch</code>组件可以通过<code>bloblang mapping</code>创建新的请求消息, 对请求消息执行一些列处理器后, 将结果映射回原始消息, 可以用于在替换内容时需要保留原始消息内容, 字段如下</p><ul><li><code>request_map</code> 字符串, 描述如何创建分支内的消息, 如果留空则表示将原始消息复制一份传进来</li><li><code>processors</code> array, 处理器列表</li><li><code>result_map</code> 字符串, 用于描述将<code>branch</code>处理器中一系列<code>processor</code>处理完毕后的消息映射回原始消息, 如果留空则原始消息不会改变</li></ul><p>如果 <code>request_map</code> 失败，则不会执行子处理器。如果子处理器本身导致 （未捕获的） 错误，则不会执行 <code>result_map</code>。如果 <code>result_map</code> 失败，则消息将保持不变</p><hr><p>更多组件参照</p><p><a href="https://docs.redpanda.com/redpanda-connect/components/processors/about/">https://docs.redpanda.com/redpanda-connect/components/processors/about/</a></p><h2 id="Output组件"><a href="#Output组件" class="headerlink" title="Output组件"></a><code>Output</code>组件</h2><p><code>output</code>组件为消息最终的输出端, 在 Redpanda Connect 配置的根目录中仅配置了一个输出。但是，输出可以是在所选代理模式下组合多个输出的<code>broker</code> ，也可以是用于多路复用不同输出的 <code>switch</code>, 其结构定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output 是一个由 Benthos 实现的接口，用于支持单条消息的写入操作。每个调用 Write 的次数</span></span><br><span class="line"><span class="comment">// 安排应阻塞直到消息成功或不成功发送，或上下文被取消。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 支持并行调用的最大并发数由输出组件的构造函数提供的 MaxInFlight 参数</span></span><br><span class="line"><span class="comment">// 指示。</span></span><br><span class="line"><span class="keyword">type</span> Output <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// 与下游服务建立连接。Connect 总是会在输出组件实例化时被首次调用，</span></span><br><span class="line"><span class="comment">// 并会循环调用（带有回退机制）直到返回 nil 错误。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 提供的上下文仅在连接阶段有效，不应用于控制连接本身的生命周期。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当 Connect 返回 nil 错误后，Write 方法会被调用，直到返回 ErrNotConnected</span></span><br><span class="line"><span class="comment">// 错误或输出组件被关闭。</span></span><br><span class="line">Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write 将消息写入目标，若传递失败则返回相应的错误。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 若该方法返回 ErrNotConnected，则表示输出组件已断开连接，此时 Write</span></span><br><span class="line"><span class="comment">// 方法不会再被调用，直到 Connect 返回 nil 错误。</span></span><br><span class="line">Write(context.Context, *Message) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchOutput 是一个由 Benthos 实现的接口，用于支持批量消息的写入操作。每个调用 WriteBatch 的次数</span></span><br><span class="line"><span class="comment">// 安排应阻塞直到该批次中的所有消息成功或不成功发送，或上下文被取消。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 支持并行调用的最大并发数由输出组件的构造函数提供的 MaxInFlight 参数</span></span><br><span class="line"><span class="comment">// 指示。</span></span><br><span class="line"><span class="keyword">type</span> BatchOutput <span class="keyword">interface</span> {</span><br><span class="line"><span class="comment">// 连接方法，如返回 nil 则表示连接成功，否则可能会重复调用并会进行回退</span></span><br><span class="line"><span class="comment">// 尝试，直到成功结束连接操作</span></span><br><span class="line">Connect(context.Context) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteBatch 将消息批次写入目标，若传递失败则返回相应的错误。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 若该方法返回 ErrNotConnected，则表示输出组件已断开连接，此时 WriteBatch</span></span><br><span class="line"><span class="comment">// 方法不会再被调用，直到 Connect 返回 nil 错误。</span></span><br><span class="line">WriteBatch(context.Context, MessageBatch) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Closer</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="output的一些机制"><a href="#output的一些机制" class="headerlink" title="output的一些机制"></a><code>output</code>的一些机制</h3><h4 id="背压机制-Back-pressure"><a href="#背压机制-Back-pressure" class="headerlink" title="背压机制 (Back pressure)"></a>背压机制 (Back pressure)</h4><p>输出端的压力将会传递到上游, 例如把水管的出口堵死, 入口就冲不进水, 当<code>output</code>被阻塞时(可能是网络问题或者是什么怪问题), 整个流水线将会停止, 直到<code>output</code>变得正常</p><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>当<code>output</code>无法发送消息时(可以是<code>output</code>本身的问题, 或者上游某个步骤失败走到了这里)，错误将传递回<code>input</code>，根据协议，它将被作为 Nack 推送回源（例如 AMQP），或者将无限期地重新尝试提交直到成功（例如 Kafka）。也可以使用<code>retey</code>包装器让其无限重试, 直到成功, <code>broker</code>也可以这么操作, 常见用法如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># All config fields, showing default values</span></span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="attr">max_retries:</span> <span class="number">0</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">    <span class="attr">backoff:</span></span><br><span class="line">      <span class="attr">initial_interval:</span> <span class="string">500ms</span> <span class="comment"># 退避时间的初始等待时间</span></span><br><span class="line">      <span class="attr">max_interval:</span> <span class="string">3s</span> <span class="comment"># 最大退避时间</span></span><br><span class="line">      <span class="attr">max_elapsed_time:</span> <span class="string">0s</span> <span class="comment"># 整个退避操作的整体超时时间, 如果为0则不限制</span></span><br><span class="line">    <span class="attr">output:</span> <span class="literal">null</span> <span class="comment"># No default (required) # output组件</span></span><br></pre></td></tr></table></figure><h4 id="死信队列-Dead-letter-queues"><a href="#死信队列-Dead-letter-queues" class="headerlink" title="死信队列 (Dead letter queues)"></a>死信队列 (Dead letter queues)</h4><p>可以使用<code>fallback</code>包装器指定当原输出目标失败时的回退输出, 并按照给定好的顺序依次执行, 例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">fallback:</span> <span class="comment"># 表示如果 aws_sqs 失败, 则使用 http_client 输出</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">aws_sqs:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">https://sqs.us-west-2.amazonaws.com/TODO/TODO</span></span><br><span class="line">        <span class="attr">max_in_flight:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http_client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://backup:1234/dlq</span></span><br><span class="line">        <span class="attr">verb:</span> <span class="string">POST</span></span><br></pre></td></tr></table></figure><h4 id="多路复用输出-Multiplexing-outputs"><a href="#多路复用输出-Multiplexing-outputs" class="headerlink" title="多路复用输出 (Multiplexing outputs)"></a>多路复用输出 (Multiplexing outputs)</h4><h5 id="插值多路复用"><a href="#插值多路复用" class="headerlink" title="插值多路复用"></a>插值多路复用</h5><p>配置中支持直接使用配置插值, 例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">addresses:</span> [ <span class="string">TODO:6379</span> ]</span><br><span class="line">    <span class="attr">topic:</span> <span class="string">${!</span> <span class="string">meta("target_topic")</span> <span class="string">}</span> <span class="comment"># 使用消息的 meta 中存放的 target_topic 作为 kafka 输出 topic</span></span><br></pre></td></tr></table></figure><h5 id="switch多路复用"><a href="#switch多路复用" class="headerlink" title="switch多路复用"></a><code>switch</code>多路复用</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output:</span></span><br><span class="line">  <span class="attr">switch:</span></span><br><span class="line">    <span class="attr">cases:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">this.type</span> <span class="string">==</span> <span class="string">"foo"</span></span><br><span class="line">        <span class="attr">output:</span></span><br><span class="line">          <span class="attr">amqp_1:</span></span><br><span class="line">            <span class="attr">urls:</span> [ <span class="string">amqps://guest:guest@localhost:5672/</span> ]</span><br><span class="line">            <span class="attr">target_address:</span> <span class="string">queue:/the_foos</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">check:</span> <span class="string">this.type</span> <span class="string">==</span> <span class="string">"bar"</span></span><br><span class="line">        <span class="attr">output:</span></span><br><span class="line">          <span class="attr">gcp_pubsub:</span></span><br><span class="line">            <span class="attr">project:</span> <span class="string">dealing_with_mike</span></span><br><span class="line">            <span class="attr">topic:</span> <span class="string">mikes_bars</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面都没匹配上, 就会走到这里</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">output:</span></span><br><span class="line">          <span class="attr">redis_streams:</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">tcp://localhost:6379</span></span><br><span class="line">            <span class="attr">stream:</span> <span class="string">everything_else</span></span><br><span class="line">          <span class="attr">processors:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line"><span class="string">                root = this</span></span><br><span class="line"><span class="string">                root.type = this.type.not_null() | "unknown"</span></span><br></pre></td></tr></table></figure><hr><p><code>output</code>相关组件及包装器参照 <a href="https://docs.redpanda.com/redpanda-connect/components/outputs/about/">https://docs.redpanda.com/redpanda-connect/components/outputs/about/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Go语言数据转发处理框架Benthos基础结构及配置&quot;&gt;&lt;a href=&quot;#Go语言数据转发处理框架Benthos基础结构及配置&quot; class=&quot;headerlink&quot; title=&quot;Go语言数据转发处理框架Benthos基础结构及配置&quot;&gt;&lt;/a&gt;Go语言数据转发处理框架&lt;code&gt;Benthos&lt;/code&gt;基础结构及配置&lt;/h1&gt;&lt;h2 id=&quot;benthos基本配置&quot;&gt;&lt;a href=&quot;#benthos基本配置&quot; class=&quot;headerlink&quot; title=&quot;benthos基本配置&quot;&gt;&lt;/a&gt;benthos基本配置&lt;/h2&gt;&lt;p&gt;benthos的配置文件格式为&lt;code&gt;yaml&lt;/code&gt;, 按照逻辑基本可以划分为三个段落, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;processor&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, 数据自&lt;code&gt;input&lt;/code&gt;接收, 经过 &lt;code&gt;processor&lt;/code&gt;处理, 通过&lt;code&gt;output&lt;/code&gt;产出, 另外还有一些&lt;code&gt;logger&lt;/code&gt;等其余配置, 各个常用内容大致如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;input&lt;/code&gt;: 数据的输入源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;processors&lt;/code&gt;: 一系列处理器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;caches&lt;/code&gt;: 一种键/值存储，可供某些组件用于诸如重复数据删除或数据连接等应用, 一般使用 &lt;code&gt;cache_resources&lt;/code&gt; 配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rate limits&lt;/code&gt;: 限速器, 一般使用 &lt;code&gt;rate_limit_resources&lt;/code&gt; 配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buffers&lt;/code&gt;: 缓冲区, 一般紧接着 &lt;code&gt;input&lt;/code&gt;, 用于缓冲输入到下游之间的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;metrics&lt;/code&gt;: 审计内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tracers&lt;/code&gt;: 追踪器, 用于消息的跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个基础的&lt;code&gt;benthos&lt;/code&gt;配置文件可以参考如下&lt;/p&gt;</summary>
    
    
    
    <category term="benthos" scheme="http://zhaozhuolin.com/categories/benthos/"/>
    
    
    <category term="benthos" scheme="http://zhaozhuolin.com/tags/benthos/"/>
    
    <category term="go" scheme="http://zhaozhuolin.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar消费者提交与消费机制小结</title>
    <link href="http://zhaozhuolin.com/2025/05/20250505.html"/>
    <id>http://zhaozhuolin.com/2025/05/20250505.html</id>
    <published>2025-05-05T11:20:00.000Z</published>
    <updated>2025-05-08T12:11:11.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pulsar消费者提交与消费机制小结"><a href="#Pulsar消费者提交与消费机制小结" class="headerlink" title="Pulsar消费者提交与消费机制小结"></a>Pulsar消费者提交与消费机制小结</h1><h2 id="消费偏移量与提交偏移量"><a href="#消费偏移量与提交偏移量" class="headerlink" title="消费偏移量与提交偏移量"></a>消费偏移量与提交偏移量</h2><p>Pulsar中消费者的消费偏移量（consumption offset）和提交偏移量（committed offset）并不是同一个概念。</p><ol><li>消费偏移量（Consumption Offset）<ul><li>消费偏移量指的是消费者当前正在消费的消息的偏移量。它表示消费者已经从消息流中读取到的位置。</li><li>消费偏移量是消费者在消费消息时记录的当前位置，但它并不一定意味着这些消息已经被处理完毕或确认。</li></ul></li><li>提交偏移量（Committed Offset）<ul><li>提交偏移量是消费者已经成功处理并确认的消息的偏移量。它表示消费者已经处理完这些消息，并且可以安全地认为这些消息不会被再次消费。</li><li>提交偏移量通常是通过消费者显式地调用提交偏移量的API来完成的，例如<code>acknowledge</code>或<code>commit</code>方法。</li></ul></li></ol><span id="more"></span><p><strong>区别：</strong></p><ul><li><strong>消费偏移量</strong>是消费者当前正在处理的消息的位置，而<strong>提交偏移量</strong>是消费者已经处理完毕并确认的消息的位置。</li><li>提交偏移量通常是消费偏移量的一个子集，表示已经处理完毕的消息。</li></ul><p><strong>在Pulsar默认情况下, 消费者进程不重启, 无论消费者以怎样的顺序提交消息, 都不会影响当前消费的偏移量</strong></p><h2 id="ackTimeout与DLQ"><a href="#ackTimeout与DLQ" class="headerlink" title="ackTimeout与DLQ"></a>ackTimeout与DLQ</h2><h3 id="1、ackTimeout-Pulsar消费者的配置项-默认情况下是关闭状态"><a href="#1、ackTimeout-Pulsar消费者的配置项-默认情况下是关闭状态" class="headerlink" title="1、ackTimeout - Pulsar消费者的配置项, 默认情况下是关闭状态"></a>1、ackTimeout - Pulsar消费者的配置项, <strong>默认情况下是关闭状态</strong></h3><ul><li><code>ackTimeout</code> 默认值为 <code>0</code><ul><li>如果 <code>ackTimeout</code> 未设置或设置为 <code>0</code>，Pulsar 不会自动重新投递未确认的消息。</li><li>这意味着，如果消费者消费了消息但没有提交确认（<code>ack</code>），这些消息会一直保留在消费者的未确认队列中，直到消费者显式地提交确认或重新投递。</li></ul></li><li>未确认消息的处理<ul><li>如果消费者一直不提交确认，未确认的消息会占用 Pulsar 的内存或磁盘资源（取决于 Pulsar 的存储模式）。</li><li>如果未确认的消息过多，可能会导致资源耗尽，影响系统性能。</li></ul></li></ul><p><strong>go语言的Pulsar客户端不支持该选项</strong></p><p>git Issues:</p><ul><li><a href="https://github.com/streamnative/pulsar-client-go/issues/44">https://github.com/streamnative/pulsar-client-go/issues/44</a></li><li><a href="https://github.com/apache/pulsar-client-go/pull/197">https://github.com/apache/pulsar-client-go/pull/197</a></li></ul><blockquote><ol><li><strong>Go客户端不支持ack timeout功能</strong>，这是有意为之的。</li><li><strong>negativeAck</strong>被认为是解决问题的首选方法，而<strong>ackTimeout</strong>被视为遗留功能。</li><li>未明确说明未来会支持该选项</li></ol></blockquote><h3 id="2、DLQ-Dead-Letter-Queue-死信队列"><a href="#2、DLQ-Dead-Letter-Queue-死信队列" class="headerlink" title="2、DLQ - Dead Letter Queue 死信队列"></a>2、DLQ - <strong>Dead Letter Queue</strong> 死信队列</h3><p>死信队列用于处理那些多次重试后仍然无法成功处理的消息。当消息的重试次数超过配置的最大重试次数时，Pulsar 会将这些消息发送到死信队列，避免无限重试。</p><p>go语言启用死信队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置死信队列策略</span></span><br><span class="line">deadLetterPolicy := pulsar.DeadLetterPolicy{</span><br><span class="line">    MaxRedeliverCount: <span class="number">3</span>, <span class="comment">// 最大重试次数, 如果消息的重试次数超过此值，Pulsar 会将消息发送到死信队列。</span></span><br><span class="line">    DeadLetterTopic:   <span class="string">"my-dead-letter-topic"</span>, <span class="comment">// 死信队列的 Topic, 如果未指定，Pulsar 会自动生成一个死信队列 Topic。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">consumer, err := client.Subscribe(pulsar.ConsumerOptions{</span><br><span class="line">    Topic:               <span class="string">"my-topic"</span>,</span><br><span class="line">    SubscriptionName:    <span class="string">"my-subscription"</span>,</span><br><span class="line">    Type:                pulsar.Shared,</span><br><span class="line">    DeadLetterPolicy:    &amp;deadLetterPolicy, <span class="comment">// 启用死信队列</span></span><br><span class="line">})</span><br></pre></td></tr></table></figure><p><strong>死信队列的工作流程</strong></p><ol><li>消息重试<ul><li>消费者消费消息后，如果处理失败，可以使用 <code>Nack</code> 或 <code>ackTimeout</code> 触发消息重试。</li><li>消息会被重新投递给消费者，直到达到 <code>MaxRedeliverCount</code> 指定的最大重试次数。</li></ul></li><li>发送到死信队列<ul><li>如果消息的重试次数超过 <code>MaxRedeliverCount</code>，Pulsar 会将消息发送到指定的死信队列 Topic。</li><li>死信队列中的消息可以被单独处理，例如记录日志、人工干预等。</li></ul></li><li>避免无限重试<ul><li>通过死信队列，可以避免消息无限重试，防止资源浪费。</li></ul></li></ol><blockquote><p>git Issues: <a href="https://github.com/streamnative/pulsar-client-go/issues/173">https://github.com/streamnative/pulsar-client-go/issues/173</a></p><p>go客户端与Java客户端对死信队列中 MaxRedeliverCount 配置存在差异：</p><p>在Pulsar的DLQPolicy中，<code>MaxDeliveries</code>属性的含义不明确，导致Java和Go客户端的实现和测试中存在差异。</p><p>关键点讨论：</p><ol><li><strong>Java客户端定义</strong>：<code>MaxDeliveries</code>表示消息在被发送到死信队列之前将重新传递的最大次数。</li><li><strong>Go客户端定义</strong>：<code>MaxDeliveries</code>表示消息在被发送到死信队列之前将传递的最大次数。</li><li>测试中的差异<ul><li>Java客户端测试中，<code>Nack</code>和<code>reconsumeLater</code>的预期结果不同，<code>Nack</code>测试期望得到<code>redelivery+1</code>条消息。</li><li>Go客户端测试中，<code>Nack</code>测试的预期结果是总传递次数，与Java客户端的<code>reconsumeLater</code>测试预期不同。</li></ul></li><li><strong>命名问题</strong>：Go客户端的命名可能存在问题，因为<code>MaxDeliveries</code>实际上用于提供最大重新传递次数。</li></ol><p>总结：<br><code>MaxDeliveries</code>属性的含义在不同客户端和测试中不一致，导致混淆。需要明确其定义并统一各客户端的实现和测试预期。</p><h4 id="Java客户端的例子"><a href="#Java客户端的例子" class="headerlink" title="Java客户端的例子"></a><strong>Java客户端的例子</strong></h4><p>假设我们设置<code>MaxDeliveries = 3</code>，即消息最多重新传递3次。</p><ol><li><strong>第一次传递</strong>：消息被传递给消费者。</li><li><strong>第一次重试</strong>：消费者<code>Nack</code>消息，消息被重新传递。</li><li><strong>第二次重试</strong>：消费者再次<code>Nack</code>消息，消息再次被重新传递。</li><li><strong>第三次重试</strong>：消费者再次<code>Nack</code>消息，消息再次被重新传递。</li><li><strong>第四次传递</strong>：如果消费者再次<code>Nack</code>消息，消息将被发送到死信队列（DLQ）。</li></ol><p><strong>总结</strong>：</p><ul><li><code>MaxDeliveries = 3</code>表示消息最多被重新传递3次。</li><li>总共传递次数为4次（1次原始传递 + 3次重试）。</li></ul><hr><h4 id="Go客户端的例子"><a href="#Go客户端的例子" class="headerlink" title="Go客户端的例子"></a><strong>Go客户端的例子</strong></h4><p>同样设置<code>MaxDeliveries = 3</code>，即消息最多传递3次。</p><ol><li><strong>第一次传递</strong>：消息被传递给消费者。</li><li><strong>第二次传递</strong>：消费者<code>Nack</code>消息，消息被重新传递。</li><li><strong>第三次传递</strong>：消费者再次<code>Nack</code>消息，消息被重新传递。</li><li><strong>第四次传递</strong>：如果消费者再次<code>Nack</code>消息，消息将被发送到死信队列（DLQ）。</li></ol><p><strong>总结</strong>：</p><ul><li><code>MaxDeliveries = 3</code>表示消息最多被传递3次。</li><li>总共传递次数为3次（1次原始传递 + 2次重试）。</li></ul><hr><h4 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a><strong>差异对比</strong></h4><div class="table-container"><table><thead><tr><th style="text-align:left">客户端</th><th style="text-align:left"><code>MaxDeliveries</code> 含义</th><th style="text-align:left">总共传递次数</th></tr></thead><tbody><tr><td style="text-align:left">Java</td><td style="text-align:left">重新传递次数</td><td style="text-align:left">4次</td></tr><tr><td style="text-align:left">Go</td><td style="text-align:left">总传递次数</td><td style="text-align:left">3次</td></tr></tbody></table></div><hr><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>Java客户端的<code>MaxDeliveries</code>表示“重新传递的次数”，而Go客户端的<code>MaxDeliveries</code>表示“总传递的次数”。这种差异导致了在测试和实际使用中的混淆。</p></blockquote><h2 id="消费者的消费行为"><a href="#消费者的消费行为" class="headerlink" title="消费者的消费行为"></a>消费者的消费行为</h2><h4 id="1、消费者的消费模式"><a href="#1、消费者的消费模式" class="headerlink" title="1、消费者的消费模式"></a>1、<strong>消费者的消费模式</strong></h4><p>在默认情况下，Pulsar 消费者的工作模式是基于 <strong>消息确认（Acknowledgment, Ack）</strong> 的。消费者的消费行为可以分为以下几个阶段：</p><ol><li><strong>消费消息</strong>：消费者从 Pulsar 的 Topic 中拉取消息。</li><li><strong>处理消息</strong>：消费者处理消息。</li><li><strong>确认消息</strong>：消费者调用 <code>Ack</code> 确认消息，表示消息已被成功处理。</li></ol><h4 id="2、消息确认机制"><a href="#2、消息确认机制" class="headerlink" title="2、消息确认机制"></a>2、<strong>消息确认机制</strong></h4><ul><li><strong>已确认的消息</strong>：消费者调用 <code>Ack</code> 的消息会被标记为已确认，Pulsar 会从消费者的未确认队列中移除这些消息。</li><li><strong>未确认的消息</strong>：消费者未调用 <code>Ack</code> 的消息会保留在未确认队列中。</li></ul><h4 id="3、-程序崩溃后的行为"><a href="#3、-程序崩溃后的行为" class="headerlink" title="3、 程序崩溃后的行为"></a>3、 <strong>程序崩溃后的行为</strong></h4><p>当消费者程序崩溃后重新启动时，Pulsar 消费者会从 <strong>未确认的消息</strong> 开始消费。</p><p>例如</p><ul><li>生产者生产了 <code>1, 2, 3, 4, 5</code>消费者全部消费成功, 但仅仅提交了 <code>1, 3, 4, 5</code>,</li><li>没有提交<code>2</code>的时候, 程序崩溃重启, 同时假设生产者在<code>5</code>之后并未生产消息</li><li>消费者重新启动之后消费的顺序将是<code>2</code>, 不会重新消费<code>3, 4, 5</code>, 因为他们是已经确认的消息</li></ul><p>或</p><ul><li>生产者生产了 <code>1, 2, 3, 4, 5</code>消费者全部消费成功, 但仅仅提交了 <code>1, 3, 4, 5</code>,</li><li>没有提交<code>2</code>的时候, 程序崩溃重启, 同时假设生产者在<code>5</code>之后生产了<code>6, 7, 8</code></li><li>消费者重新启动之后消费的顺序将是<code>2, 6, 7, 8</code>, 不会重新消费<code>3, 4, 5</code>, 因为他们是已经确认的消息</li></ul><p>可能会影响以上行为的配置项如下</p><div class="table-container"><table><thead><tr><th style="text-align:left">配置项</th><th style="text-align:left">作用</th><th style="text-align:left">默认值</th><th style="text-align:left">影响</th></tr></thead><tbody><tr><td style="text-align:left"><code>ackTimeout</code></td><td style="text-align:left">未确认消息的超时时间，触发自动重新投递。</td><td style="text-align:left">0</td><td style="text-align:left">如果设置为非零值，未确认的消息会在超时后自动重新投递。</td></tr><tr><td style="text-align:left"><code>ackTimeoutTickTime</code></td><td style="text-align:left">检查未确认消息的时间间隔。</td><td style="text-align:left">1 秒</td><td style="text-align:left">影响 <code>ackTimeout</code> 的检查频率。</td></tr><tr><td style="text-align:left"><code>negativeAckRedeliveryDelay</code></td><td style="text-align:left"><code>Nack</code> 触发重新投递的延迟时间。</td><td style="text-align:left">1 分钟</td><td style="text-align:left">影响 <code>Nack</code> 触发重新投递的时间。</td></tr><tr><td style="text-align:left"><code>replicateSubscriptionState</code></td><td style="text-align:left">是否将订阅状态复制到其他集群。</td><td style="text-align:left">false</td><td style="text-align:left">影响跨集群故障切换时的未确认消息处理。如果设置为 <code>false</code>，订阅状态不会复制，重启后只会从本地未确认的消息开始消费</td></tr><tr><td style="text-align:left"><code>maxUnackedMessagesPerConsumer</code></td><td style="text-align:left">每个消费者允许的最大未确认消息数量。</td><td style="text-align:left">50000</td><td style="text-align:left">影响消费者的未确认消息数量限制。</td></tr><tr><td style="text-align:left"><code>enableBatchIndexAcknowledgment</code></td><td style="text-align:left">是否启用批量消息的索引级别确认。</td><td style="text-align:left">false</td><td style="text-align:left">影响批量消息的确认粒度。如果设置为 <code>true</code>，消费者可以确认批量消息中的部分消息，而不是整个批量消息</td></tr><tr><td style="text-align:left"><code>autoUpdatePartitions</code></td><td style="text-align:left">是否自动更新分区信息。</td><td style="text-align:left">true</td><td style="text-align:left">影响消费者对新分区的订阅行为。如果设置为 <code>false</code>，消费者不会订阅新创建的分区，重启后可能会丢失新分区的消息。</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Pulsar消费者提交与消费机制小结&quot;&gt;&lt;a href=&quot;#Pulsar消费者提交与消费机制小结&quot; class=&quot;headerlink&quot; title=&quot;Pulsar消费者提交与消费机制小结&quot;&gt;&lt;/a&gt;Pulsar消费者提交与消费机制小结&lt;/h1&gt;&lt;h2 id=&quot;消费偏移量与提交偏移量&quot;&gt;&lt;a href=&quot;#消费偏移量与提交偏移量&quot; class=&quot;headerlink&quot; title=&quot;消费偏移量与提交偏移量&quot;&gt;&lt;/a&gt;消费偏移量与提交偏移量&lt;/h2&gt;&lt;p&gt;Pulsar中消费者的消费偏移量（consumption offset）和提交偏移量（committed offset）并不是同一个概念。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消费偏移量（Consumption Offset）&lt;ul&gt;
&lt;li&gt;消费偏移量指的是消费者当前正在消费的消息的偏移量。它表示消费者已经从消息流中读取到的位置。&lt;/li&gt;
&lt;li&gt;消费偏移量是消费者在消费消息时记录的当前位置，但它并不一定意味着这些消息已经被处理完毕或确认。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提交偏移量（Committed Offset）&lt;ul&gt;
&lt;li&gt;提交偏移量是消费者已经成功处理并确认的消息的偏移量。它表示消费者已经处理完这些消息，并且可以安全地认为这些消息不会被再次消费。&lt;/li&gt;
&lt;li&gt;提交偏移量通常是通过消费者显式地调用提交偏移量的API来完成的，例如&lt;code&gt;acknowledge&lt;/code&gt;或&lt;code&gt;commit&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="pulsar" scheme="http://zhaozhuolin.com/categories/pulsar/"/>
    
    
    <category term="go" scheme="http://zhaozhuolin.com/tags/go/"/>
    
    <category term="pulsar" scheme="http://zhaozhuolin.com/tags/pulsar/"/>
    
  </entry>
  
  <entry>
    <title>在MIPS及LoongArch的架构下编译go语言二进制</title>
    <link href="http://zhaozhuolin.com/2024/05/20240520.html"/>
    <id>http://zhaozhuolin.com/2024/05/20240520.html</id>
    <published>2024-05-20T01:47:50.000Z</published>
    <updated>2024-05-26T03:48:10.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在MIPS及LoongArch的架构下编译go语言二进制"><a href="#在MIPS及LoongArch的架构下编译go语言二进制" class="headerlink" title="在MIPS及LoongArch的架构下编译go语言二进制"></a>在<code>MIPS</code>及<code>LoongArch</code>的架构下编译go语言二进制</h1><h3 id="首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境"><a href="#首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境" class="headerlink" title="首先需要找到一个已经安装go的机器, 可以是X86或ARM等任何可以执行go的环境"></a>首先需要找到一个已经安装go的机器, 可以是<code>X86</code>或<code>ARM</code>等任何可以执行go的环境</h3><p>其次准备好go源码</p><p>接着进行如下操作</p><ol><li><p>解压go源码</p></li><li><p>设定环境变量 <code>GOROOT_BOOTSTRAP</code>/<code>GOOS</code>/<code>GOARCH</code><br> 其中 <code>GOROOT_BOOTSTRAP</code> 为当前可以执行 go 文件的安装目录, 例如当前环境的 go 可执行文件为<code>/usr/local/go/bin/go</code>, 则 <code>GOROOT_BOOTSTRAP</code> 应设置为 <code>/usr/local/go</code><br> <code>GOOS</code> 为目标环境系统<br> <code>GOARCH</code> 为目标架构<br> 关于 <code>GOOS</code> 以及 <code>GOARCH</code>, 可以使用命令, go tool dist list 查看, 版本越高的go支持的越多</p> <span id="more"></span></li><li><p><img src="/2024/05/20240520/image-20240416195706201.png" alt="image-20240416195706201"></p></li><li><p>设定好环境变量后, 进入源码目录下的<code>src</code>目录, 执行脚本 <code>bootstrap.bash</code></p></li></ol><p>​    <img src="/2024/05/20240520/image-20240416195943599.png" alt="image-20240416195943599">    </p><ol><li><p>等待脚本执行完毕, 会在<code>src</code>目录的上层的上层目录 即 <code>../../</code> 目录 (脚本最后一般会输出文件路径)下生成 一个<code>tbz</code>文件, 将此文件拷贝至目标机器, 并解压</p></li><li><p>解压后, 进入 <code>$&#123;解压后的目录&#125;/bin</code> , 此时应该存在 <code>go</code>,  <code>gofmt</code> 两个二进制文件, 执行以下 <code>./go version</code> , 看看能否正常运行</p><ol><li><p>这里在<code>loongarrch</code>架构碰到一个问题, 执行后出现 段错误</p><p> <img src="/2024/05/20240520/image-20240416200939524.png" alt="image-20240416200939524"></p></li><li><p><code>gdb</code>了一下发现是在编译的时候似乎把依赖路径硬编码进去了(也可能是没有设置好环境变量)</p></li><li><p>将解压后的文件放到与编译时的文件同一个路径即可</p></li></ol></li></ol><ol><li><p>在目标机器设定环境变量, <code>GOROOT_BOOTSTRAP</code> , <code>GOROOT</code>, 将源码文件解压到任何你想解压到的地方, 其中</p><ol><li><p><code>GOROOT_BOOTSTRAP</code> 为之前编译出来的<code>tbz</code>文件的解压路径</p></li><li><p><code>GOROOT</code> 为解压后的go源码文件路径</p></li></ol></li><li><p>进入 <code>$GOROOT/scr</code>, 执行 <code>./all.bash</code>, 此步骤耗时较久, 会测试一些东西</p></li><li><p>执行完毕后, <code>$GOROOT</code>目录即会多出一个bin目录, 此时将整个<code>$GOROOT</code>目录挪到任何你想挪到的地方, 并将 <code>$GOROOT/bin</code> 添加到环境变量即可</p></li></ol><h3 id="如果在进行测试时失败-可以看一下有没有超时-测试项完成后会显示使用时间-默认为3分钟-类似下图"><a href="#如果在进行测试时失败-可以看一下有没有超时-测试项完成后会显示使用时间-默认为3分钟-类似下图" class="headerlink" title="如果在进行测试时失败, 可以看一下有没有超时, 测试项完成后会显示使用时间, 默认为3分钟, 类似下图"></a>如果在进行测试时失败, 可以看一下有没有超时, 测试项完成后会显示使用时间, 默认为3分钟, 类似下图</h3><p><img src="/2024/05/20240520/image2023-2-17_11-24-37.png" alt="image2023-2-17_11-24-37"></p><p>解决方式是设定环境变量 <code>GO_TEST_TIMEOUT_SCALE</code> = 2, 这会将超时时间倍乘二, 变为 6 分钟</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;在MIPS及LoongArch的架构下编译go语言二进制&quot;&gt;&lt;a href=&quot;#在MIPS及LoongArch的架构下编译go语言二进制&quot; class=&quot;headerlink&quot; title=&quot;在MIPS及LoongArch的架构下编译go语言二进制&quot;&gt;&lt;/a&gt;在&lt;code&gt;MIPS&lt;/code&gt;及&lt;code&gt;LoongArch&lt;/code&gt;的架构下编译go语言二进制&lt;/h1&gt;&lt;h3 id=&quot;首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境&quot;&gt;&lt;a href=&quot;#首先需要找到一个已经安装go的机器-可以是X86或ARM等任何可以执行go的环境&quot; class=&quot;headerlink&quot; title=&quot;首先需要找到一个已经安装go的机器, 可以是X86或ARM等任何可以执行go的环境&quot;&gt;&lt;/a&gt;首先需要找到一个已经安装go的机器, 可以是&lt;code&gt;X86&lt;/code&gt;或&lt;code&gt;ARM&lt;/code&gt;等任何可以执行go的环境&lt;/h3&gt;&lt;p&gt;其次准备好go源码&lt;/p&gt;
&lt;p&gt;接着进行如下操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解压go源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设定环境变量 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt;/&lt;code&gt;GOOS&lt;/code&gt;/&lt;code&gt;GOARCH&lt;/code&gt;&lt;br&gt; 其中 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 为当前可以执行 go 文件的安装目录, 例如当前环境的 go 可执行文件为&lt;code&gt;/usr/local/go/bin/go&lt;/code&gt;, 则 &lt;code&gt;GOROOT_BOOTSTRAP&lt;/code&gt; 应设置为 &lt;code&gt;/usr/local/go&lt;/code&gt;&lt;br&gt; &lt;code&gt;GOOS&lt;/code&gt; 为目标环境系统&lt;br&gt; &lt;code&gt;GOARCH&lt;/code&gt; 为目标架构&lt;br&gt; 关于 &lt;code&gt;GOOS&lt;/code&gt; 以及 &lt;code&gt;GOARCH&lt;/code&gt;, 可以使用命令, go tool dist list 查看, 版本越高的go支持的越多&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信创系统-凝思606替换GLIBC库以运行QT的可行性调查</title>
    <link href="http://zhaozhuolin.com/2024/05/20240518.html"/>
    <id>http://zhaozhuolin.com/2024/05/20240518.html</id>
    <published>2024-05-18T01:47:50.000Z</published>
    <updated>2024-05-26T03:48:10.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信创系统-凝思606替换GLIBC库以运行QT的可行性调查"><a href="#信创系统-凝思606替换GLIBC库以运行QT的可行性调查" class="headerlink" title="信创系统-凝思606替换GLIBC库以运行QT的可行性调查"></a>信创系统-凝思606替换GLIBC库以运行QT的可行性调查</h1><ol><li><p>安装CentOS7编译的带UI的QT程序，其中systemctl相关服务已被替换为service</p><p> 由于606系统libc.so.6版本过低，无法正常运行</p></li><li><p>尝试替换其他高版本的libc.so至本地的lib目录，同时替换其依赖</p><p> <img src="/2024/05/20240518/image-20240508143943090.png" alt="image-20240508143943090"></p><p> <img src="/2024/05/20240518/image-20240508143957295-17151504030681.png" alt="image-20240508143957295"></p> <span id="more"></span></li><li><p>替换完成后，碰到一些系统命令调用的问题，由于eps_service脚本会指定LD_LIBRARY_PATH，所以在该脚本中执行的系统调用命令会优先使用刚在替换的库，先在尝试将这些命令也替换为高版本gcc编译出的可执行文件，为了避免造成系统出错，这里将脚本中的系统命令换位执行本地目录的命令</p><ol><li><p>替换/增加的文件有</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span>、ln、sleep、pidof、mkdir、dirname</span><br><span class="line"><span class="attribute">ld</span>-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> -&gt; ld-<span class="number">2</span>.<span class="number">17</span>.so</span><br><span class="line"><span class="attribute">libtinfo</span>.so.<span class="number">5</span> -&gt; libtinfo.so.<span class="number">5</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">libgcc_s</span>.so.<span class="number">1</span> -&gt; libgcc_s-<span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span>-<span class="number">20150702</span>.so.<span class="number">1</span></span><br><span class="line"><span class="attribute">libm</span>.so.<span class="number">6</span> -&gt; libm-<span class="number">2</span>.<span class="number">17</span>.so</span><br><span class="line"><span class="attribute">libstdc</span>++.so.<span class="number">6</span> -&gt; libstdc++.so.<span class="number">6</span>.<span class="number">0</span>.<span class="number">19</span></span><br><span class="line"><span class="attribute">libc</span>.so.<span class="number">6</span> -&gt; libc-<span class="number">2</span>.<span class="number">17</span>.so</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol><li><p>替换这些文件后， 报错信息仍然如下</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relocation error: /opt/apps/xxx/lib/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference</span><br></pre></td></tr></table></figure></li><li><p>经查阅(<a href="https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host">https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host</a>)</p><p> <code>ld-linux-x86-64.so.2</code>所指向的ld-2.17.so是一个链接器，他是可执行的，并且可执行文件所需要的链接器路径是写死在文件头信息中的，可通过工具<code>patchelf</code>来修改文件头部信息，命令如下</p><p> <code>patchelf --set-interpreter $&#123;从别处拷贝的链接器(ld-linux-x86-64.so.2)&#125; --set-rpath $&#123;自己的lib目录&#125; $&#123;文件名&#125;</code></p><p> 例如<code>patchelf --set-interpreter /opt/apps/xxx/lib/ld-linux-x86-64.so.2 --set-rpath /opt/apps/xxx/lib/ /opt/apps/xxx/bin/bash</code></p><p> 同时，也可直接使用<code>ld-linux-x86-64.so.2</code>文件本身来单次指定链接器，<strong>仅当次生效</strong>，这在设置了<code>LD_LIBRARY_PATH</code>后想要执行系统自身命令，如想要使用gdb看看情况时==非常有用==。可以用低版本系统本身的<code>ld-linux-x86-64.so.2</code>指向系统本身的库，如下</p><p> <code>/lib64/ld-linux-x86-64.so.2 --library-path /lib64 /usr/bin/gdb ./edr_monitor</code></p></li><li><p>当做完这些后，发现仍然无法启动程序，启动报段错误，使用<code>/lib64/ld-linux-x86-64.so.2 --library-path /lib64 /usr/bin/gdb ./app</code>调试，未能发现其他问题，而==导入环境变量后直接执行程序会段错误==</p></li></ol><h2 id="改变思路"><a href="#改变思路" class="headerlink" title="改变思路"></a>改变思路</h2><ol><li><p>在凝思606上安装gcc4.8.5编译器</p> <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -<span class="keyword">enable</span>-checking=<span class="keyword">release</span> -<span class="keyword">enable</span>-languages=c,c++ -<span class="keyword">disable</span>-multilib</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>编译QT5.9.8</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -<span class="keyword">confirm</span>-license -opensource -release -prefix <span class="string">&quot;/tmp/qt&quot;</span> -nomake tests -nomake examples -<span class="keyword">no</span>-compile-examples -qt-xcb -<span class="keyword">no</span>-openssl -skip webengine -skip tools -skip <span class="number">3</span>d -skip gamepad -skip multimedia -skip doc -skip location -skip sensors -skip androidextras -<span class="keyword">c</span>++std <span class="keyword">c</span>++<span class="number">11</span> -<span class="keyword">no</span>-static -<span class="keyword">no</span>-use-gold-linker -<span class="keyword">no</span>-glib -<span class="keyword">no</span>-<span class="built_in">iconv</span> -<span class="keyword">no</span>-icu -qt-freetype -qt-harfbuzz -<span class="keyword">no</span>-fontconfig -<span class="keyword">no</span>-xkbcommon-evdev -<span class="keyword">no</span>-gtk -qt-libjpeg -qt-libpng -<span class="keyword">no</span>-libinput -<span class="keyword">no</span>-cups -dbus-<span class="keyword">runtime</span> -<span class="keyword">no</span>-eglfs -skip wayland -optimize-size -skip serialport -skip virtualkeyboard -skip connectivity -skip activeqt -<span class="keyword">no</span>-avx2</span><br></pre></td></tr></table></figure><p> 其中<code>-no-avx2</code>这个参数很重要, <strong>指定编译用的CPU指令集不包含avx2</strong>, qt的configure在这个环境下无法自动检测, 会造成一些编译错误, 例如下图</p><p> <img src="/2024/05/20240518/image-20240508144334144.png" alt="image-20240508144334144"></p></li><li><p>编译代码(部分三方库需要重编, 因为glibc库此时还是低版本的)</p></li><li><p>此时编译出来的终端除了ui外其他都可以正常运行, 经排查, 是系统libstdc++.so版本问题, 尝试将高版本库放入终端lib目录</p></li><li><p>引入高版本libstdc++.so此时UI程序报 段错误，经排查，是由于其中一个list进行push_back操作导致</p><p> <img src="/2024/05/20240518/image-20240508144424382.png" alt="image-20240508144424382"></p><p> 虽然不能找出具体原因，但是替换为vector后即可正常使用</p></li><li><p>此时QT的画笔模块出现问题</p><p> <img src="/2024/05/20240518/image-20240508144450629.png" alt="image-20240508144450629"></p></li><li><p>对比了可以正常运行版本的依赖，发现依赖数量相差九个</p><p> <img src="/2024/05/20240518/image-20240508144503912.png" alt="image-20240508144503912"></p></li><li><p>经排查多出来的为libGL.so的依赖，属于OpenGL库，遂安装mesa-10.1.0，此时安装后，依赖数量仍差两个，此时UI仍然无法正常启动，问题同之前，通过gdb调试得到其崩溃是因为QT库的问题，程序异常退出并存在信号SIGFPE</p></li><li><p>编译debug版本的QT，重新编译UI准备调试，此时托盘图标页无法弹出，通过gdb运行发现有信号SIGABRT，经过追踪，确定问题出在加载托盘图标，实例化QIcon这一步，其中有一个函数获取系统不透明度格式时返回了非法值，触发了接下来的一个assert，从而导致出现问题，通过将QT源码改写，将原来出问题的函数中的连续三次指针调用成员函数改为分三句执行，发现最重要的第三步无法跟进去，同时gdb报<code>RTTI symobl not found for class &#39;QXcbScreen&#39;</code>，怀疑其和QXcbScreen这个类有关，同时也在该类中找到了同名函数format</p></li></ol><p><img src="/2024/05/20240518/image-20240508144536501.png" alt="image-20240508144536501"></p><p><img src="/2024/05/20240518/image-20240508144549717.png" alt="image-20240508144549717"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;信创系统-凝思606替换GLIBC库以运行QT的可行性调查&quot;&gt;&lt;a href=&quot;#信创系统-凝思606替换GLIBC库以运行QT的可行性调查&quot; class=&quot;headerlink&quot; title=&quot;信创系统-凝思606替换GLIBC库以运行QT的可行性调查&quot;&gt;&lt;/a&gt;信创系统-凝思606替换GLIBC库以运行QT的可行性调查&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装CentOS7编译的带UI的QT程序，其中systemctl相关服务已被替换为service&lt;/p&gt;
&lt;p&gt; 由于606系统libc.so.6版本过低，无法正常运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试替换其他高版本的libc.so至本地的lib目录，同时替换其依赖&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/2024/05/20240518/image-20240508143943090.png&quot; alt=&quot;image-20240508143943090&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/2024/05/20240518/image-20240508143957295-17151504030681.png&quot; alt=&quot;image-20240508143957295&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://zhaozhuolin.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Rust-枚举与模式匹配</title>
    <link href="http://zhaozhuolin.com/2023/05/20230512.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230512.html</id>
    <published>2023-05-12T01:47:50.000Z</published>
    <updated>2024-05-26T03:48:10.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>结构体将字段与数据聚合，而枚举可以将同一类型的东西（同时你可以将它可能的情况列举出来）作为一个集合，使用IP地址举例如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">v4,</span><br><span class="line">v6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>可使用<code>::</code>访问枚举值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ipv4</span> = IpAddrKind::v4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ipv6</span> = IpAddrKind::v6;</span><br></pre></td></tr></table></figure><p>也可将其传入函数，如<code>func(IpAddrKind::v4)</code></p><span id="more"></span><p>也可结合结构体使用如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可直接指定枚举值类型如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><p>此时，<code>IpAddr::V4()</code>实际上为一个获取<code>String</code>参数并返回<code>IpAddr</code>类型示例的函数调用，而这些构造函数会被自动定义，枚举可以为每个值指定不同的数据类型，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>可以将任意类型的数据放入枚举成员中，例如字符串，数字或者结构体，甚至可以嵌套枚举</p></blockquote><p>以下为一个多种成员类型的枚举类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该枚举类型有四个成员，分别为：</p><ul><li><code>Quit</code> 没有关联任何数据。</li><li><code>Move</code> 类似结构体包含命名字段。</li><li><code>Write</code> 包含单独一个 <code>String</code>。</li><li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li></ul><p>如果使用结构体的话，他将会是这样，如果不能使用枚举类型的话，使用结构体需要定义四个不同的结构体类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QuitMessage</span>; <span class="comment">// 类单元结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MoveMessage</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteMessage</span>(<span class="type">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChangeColorMessage</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></table></figure><p>枚举同结构体一样可以使用<code>impl</code>来定义方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure><h2 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a><code>Option</code>枚举</h2><p><code>Option</code>是标准库定义的另一个枚举，这个枚举可以表示一个空值，Rust没有<code>nil</code>，<code>nullptr</code>，<code>NULL</code>那样的空值，取而代之为如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="literal">None</span>,</span><br><span class="line"><span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以不使用<code>Option::</code>前缀来直接使用<code>Some</code>与<code>None</code>，但即便如此<code>Option&lt;T&gt;</code>也是常规的枚举， <code>Some&lt;T&gt;</code>与<code>None</code>是其成员，以下是一些例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_num</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure><p>在上述例子中，<code>some_num</code>的类型是<code>Option&lt;i32&gt;</code>，<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>，对于<code>absent_num</code>则通过<code>: Option&lt;i32&gt;</code>显示的指明其类型</p><p>当有一个<code>Some</code>值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。这样做会比空值更好，因为<code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = x + y; <span class="comment">//这两个值不能相加，因为不是同一个类型</span></span><br></pre></td></tr></table></figure><h1 id="match控制流"><a href="#match控制流" class="headerlink" title="match控制流"></a><code>match</code>控制流</h1><p>允许讲一个值与一系列的模式相比较，并根据与相匹配的模式执行相应的代码。模式可以由字面值、变量以及通配符等其他内容构成，以下为一个案例，利用<code>match</code>语法获取对应衣服尺码的袖长</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ClothingSize</span> &#123;</span><br><span class="line">    Size_XS,</span><br><span class="line">    Szie_S,</span><br><span class="line">    Size_M,</span><br><span class="line">    Size_L,</span><br><span class="line">    Size_XL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_sleeve_len</span>(clothing_size: ClothingSize) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> clothing_size &#123;</span><br><span class="line">        ClothingSize::Size_XS =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;This is XS&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125; <span class="comment">//使用 &#123;&#125; 形式时 逗号可写可不写</span></span><br><span class="line">        ClothingSize::Szie_S =&gt; <span class="number">20</span>,</span><br><span class="line">        ClothingSize::Size_M =&gt; <span class="number">30</span>,</span><br><span class="line">        ClothingSize::Size_L =&gt; <span class="number">40</span>,</span><br><span class="line">        ClothingSize::Size_XL =&gt; <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h2><p>匹配分支的另一个功能是可以绑定匹配模式的部分值，这也就是如何从枚举成员中提取值的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    AAA,</span><br><span class="line">    BBB</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ClothingSize</span> &#123;</span><br><span class="line">    Size_XS,</span><br><span class="line">    Szie_S,</span><br><span class="line">    Size_M,</span><br><span class="line">    <span class="title function_ invoke__">Size_L</span>(Brand),</span><br><span class="line">    Size_XL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_sleeve_len</span>(clothing_size: ClothingSize) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> clothing_size &#123;</span><br><span class="line">        ClothingSize::Size_XS =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;This is XS&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125; <span class="comment">//使用 &#123;&#125; 形式时 逗号可写可不写</span></span><br><span class="line">        ClothingSize::Szie_S =&gt; <span class="number">20</span>,</span><br><span class="line">        ClothingSize::Size_M =&gt; <span class="number">30</span>,</span><br><span class="line">        ClothingSize::<span class="title function_ invoke__">Size_L</span>(brand) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;clothing brand is &#123;:?&#125;&quot;</span>, brand);</span><br><span class="line">            <span class="number">40</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ClothingSize::Size_XL =&gt; <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上场景中，调用<code>get_sleeve_len(ClothingSize::Size_L(Brand::AAA))</code>，传入函数内部的<code>clothing_size</code>遇到<code>ClothingSize::Size_L(brand)</code>会匹配上，接着就可以直接使用<code>AAA</code>这个值</p><h2 id="匹配Option-lt-T-gt"><a href="#匹配Option-lt-T-gt" class="headerlink" title="匹配Option&lt;T&gt;"></a>匹配<code>Option&lt;T&gt;</code></h2><p><code>Option&lt;T&gt;</code>也可以被用作<code>match</code>匹配，例如一个函数，接受一个类型为<code>Option&lt;T&gt;</code>的参数，如果其中有值，则将其加一，如果没有则不进行操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure><h2 id="匹配的穷尽性，通配模式与占位符"><a href="#匹配的穷尽性，通配模式与占位符" class="headerlink" title="匹配的穷尽性，通配模式与占位符_"></a>匹配的穷尽性，通配模式与占位符<code>_</code></h2><p>匹配需要列出所有的可能，所有可能出现的值都必须能匹配到，在<code>Rust</code>中可以使用通配模式与<code>_</code>占位符来实现穷尽例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">rand</span>();</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">deal_seven</span>(),</span><br><span class="line">    <span class="number">9</span> =&gt; <span class="title function_ invoke__">deal_nine</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">deal_other</span>(other),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_seven</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_nine</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_other</span>(num: <span class="type">u8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于前两个分支，匹配模式是字面值 <code>7</code> 和 <code>9</code>，最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 <code>other</code> 的一个变量。<code>other</code> 分支的代码通过将其传递给 <code>deal_other</code> 函数来使用这个变量。</p><blockquote><p>通配模式应该放在最后一位，因为<code>match</code>是按照分支顺序依次匹配的</p></blockquote><p>如果不想使用通配模式获取的值，使用<code>_</code>来替代，其可以匹配任意值而不绑定到该值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">rand</span>();</span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">deal_seven</span>(),</span><br><span class="line">    <span class="number">9</span> =&gt; <span class="title function_ invoke__">deal_nine</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">deal_other</span>(),</span><br><span class="line">    <span class="comment">// 如果不想做任何事，可以使用以下写法，返回一个空的元组</span></span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_seven</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_nine</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deal_other</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="if-let简洁控制流"><a href="#if-let简洁控制流" class="headerlink" title="if let简洁控制流"></a><code>if let</code>简洁控制流</h1><p>如果有以下类似的逻辑</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅关心<code>Some</code>得值，其余不做任何操作，可使用<code>if let</code>来简写</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h1&gt;&lt;p&gt;结构体将字段与数据聚合，而枚举可以将同一类型的东西（同时你可以将它可能的情况列举出来）作为一个集合，使用IP地址举例如下&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;IpAddrKind&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	v4,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	v6,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;枚举值&quot;&gt;&lt;a href=&quot;#枚举值&quot; class=&quot;headerlink&quot; title=&quot;枚举值&quot;&gt;&lt;/a&gt;枚举值&lt;/h2&gt;&lt;p&gt;可使用&lt;code&gt;::&lt;/code&gt;访问枚举值&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;ipv4&lt;/span&gt; = IpAddrKind::v4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;ipv6&lt;/span&gt; = IpAddrKind::v6;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也可将其传入函数，如&lt;code&gt;func(IpAddrKind::v4)&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-结构体</title>
    <link href="http://zhaozhuolin.com/2023/05/20230509.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230509.html</id>
    <published>2023-05-09T07:20:20.000Z</published>
    <updated>2024-05-26T03:48:10.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体的定义与实例化"><a href="#结构体的定义与实例化" class="headerlink" title="结构体的定义与实例化"></a>结构体的定义与实例化</h1><p>举例如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">active: <span class="type">bool</span>,</span><br><span class="line">username: <span class="type">String</span>,</span><br><span class="line">email: <span class="type">String</span>,</span><br><span class="line">sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">active: <span class="literal">true</span>,</span><br><span class="line">username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;email@email.com&quot;</span>),</span><br><span class="line">sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//若要使用值，则同C/C++</span></span><br><span class="line"><span class="comment">//若要修改值，则示例需是可变的，如下</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user2</span> = User &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">user2.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><p>作为函数返回值如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果函数参数和字段名相同，则可以使用简化写法</strong>如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用结构体更新语法从其他实例创建"><a href="#使用结构体更新语法从其他实例创建" class="headerlink" title="使用结构体更新语法从其他实例创建"></a>使用结构体更新语法从其他实例创建</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    active: user1.active,</span><br><span class="line">    username: user1.username,</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可使用简化写法，使用<code>..</code>来指定剩余没有变化的值，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>..user1</code>必须放在最后</strong></p><blockquote><p>请注意，转移与克隆的规则在此处仍然适用，例如用<code>user1</code>的<code>username</code>与<code>email</code>字段更新<code>user2</code>之后，这两个字段被转移到<code>user2</code>中，其余值则拷贝了一份，此时<code>user1</code>不能再使用。</p><p>而如果<code>user2</code>的那两个字段使用<code>String::from()</code>来进行赋值，其余从<code>user1</code>更新，那二者都可使用</p></blockquote><h2 id="元组结构体-匿名结构体"><a href="#元组结构体-匿名结构体" class="headerlink" title="元组结构体/匿名结构体"></a>元组结构体/匿名结构体</h2><p>类似如下形式，使用时同元组，使用下标</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有字段名称的类单元结构体"><a href="#没有字段名称的类单元结构体" class="headerlink" title="没有字段名称的类单元结构体"></a>没有字段名称的类单元结构体</h2><p>即元组类型中的<code>unit</code>类型，类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。形式如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h2><p>在上面的示例中，<code>User</code>结构体中的字符串类型使用了<code>String</code>而非<code>&amp;str</code>，这是因为想要这个结构体拥有它所有的数据，由此，只要整个结构体是有效的，那其中的数据也一定有效。</p><p>也可以是结构体存储被其他对象拥有的数据的引用（切片类型），不过需要用上生命周期标识符。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的</p><h1 id="结构体的示例程序"><a href="#结构体的示例程序" class="headerlink" title="结构体的示例程序"></a>结构体的示例程序</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rectangle: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过派生trait增加实用功能"><a href="#通过派生trait增加实用功能" class="headerlink" title="通过派生trait增加实用功能"></a>通过派生<code>trait</code>增加实用功能</h2><p>在上面实现的结构体，无法直接通过<code>println!</code>，但可通过以下方式进行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">//定义外部属性</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">    dbg!(&amp;rect1); <span class="comment">//另一种方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法语句"><a href="#方法语句" class="headerlink" title="方法语句"></a>方法语句</h1><p>关键字为<code>impl</code>，<code>impl</code>块中所有内容都将与结构体类型相关联，如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数<code>area</code>中，<code>&amp;self</code>实际上是<code>self: &amp;self</code>的缩写，他会借用调用对象的值，而不获取他的所有权</p><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>所有在<code>impl</code>块中定义的函数被称为 <strong>关联函数</strong> （静态成员函数），因为其与<code>impl</code>后面命名的类型先关。可以定义不以<code>self</code>为第一参数的关联函数，因此他不是方法，不是方法的关联函数通常会被用作返回一个结构体新实例的构造函数，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sq</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>使用<code>::</code>来使用结构体的关联函数，<code>::</code>语法用于关联函数和模块创建的命名空间</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;结构体的定义与实例化&quot;&gt;&lt;a href=&quot;#结构体的定义与实例化&quot; class=&quot;headerlink&quot; title=&quot;结构体的定义与实例化&quot;&gt;&lt;/a&gt;结构体的定义与实例化&lt;/h1&gt;&lt;p&gt;举例如下&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;User&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	active: &lt;span class=&quot;type&quot;&gt;bool&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	username: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	email: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sign_in_count: &lt;span class=&quot;type&quot;&gt;u64&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例化如下&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;user1&lt;/span&gt; = User &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	active: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	username: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	email: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;email@email.com&amp;quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sign_in_count: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//若要使用值，则同C/C++&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//若要修改值，则示例需是可变的，如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;user2&lt;/span&gt; = User &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;user2.email = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-所有权、引用与Slice</title>
    <link href="http://zhaozhuolin.com/2023/05/20230508.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230508.html</id>
    <published>2023-05-08T12:12:50.000Z</published>
    <updated>2024-05-26T03:48:10.544Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 通过所有权系统管理内存，编译器在编译时会根据一系列规则进行检查，如果违反了这些规则，程序不能通过编译。在运行时，所有权系统的任何功能都不会减缓程序的运行</p><h1 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h1><blockquote><ol><li>Rust 中的每一个值都有一个<strong>所有者</strong></li><li>值在任意时刻有且仅有一个所有者</li><li>当所有者（变量）离开作用域，这个值将被丢弃</li></ol></blockquote><span id="more"></span><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>同C语言，以 Rust 中的<code>String</code>类型举例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量<code>str</code>离开作用域时，会自动调用一个名为<code>drop</code>的函数，类似C++中的<code>RAII</code></p><h2 id="变量与数据交互的方式：移动"><a href="#变量与数据交互的方式：移动" class="headerlink" title="变量与数据交互的方式：移动"></a>变量与数据交互的方式：移动</h2><p>对于以下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>其将5绑定到<code>x</code>，接着生成一个<code>x</code>的拷贝并绑定到<code>y</code>，两个变量都在栈上</p><p>而对于以下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p>变量<code>s1</code>实际内容是存放在堆中，<code>String</code>对象由指向字符串内容的指针，一个长度与一个容量组成，这一部分数据是在栈上的，此处的操作类似于C++11中的<code>std::move()</code>操作，将<code>s1</code>中长度与容量赋值给<code>s2</code>，将<code>s2</code>的指针指向<code>s1</code>所指向的字符串内容，在C++11中，<code>std::move()</code>这一操作一般是对将亡值使用，在Rust中并无这一限制，但是在Rust中一旦使用这样的<strong>移动</strong>，则移动前的变量将不再有效，不能使用，这样就避免了变量离开作用域时的多次释放导致的未定义行为</p><p>简单来说，以上的操作是直接将<code>s1</code>认定为将亡值并使用移动语义将其内容转义到<code>s2</code>中</p><h2 id="变量与数据的交互方式：克隆"><a href="#变量与数据的交互方式：克隆" class="headerlink" title="变量与数据的交互方式：克隆"></a>变量与数据的交互方式：克隆</h2><p>如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure><p>类似C++中的拷贝构造</p><h3 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a>只在栈上的数据：拷贝</h3><p>如果数据本身大小已知，且整个存储在栈上，则在赋值时会进行拷贝操作，Rust 中存在一个 <code>Copy</code>traitde的特殊注解，可以用在类似整型这样存储在栈上的类型上，一个类型如果实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。同时，<strong>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。</strong>如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。</p><p>一下是一些实现了 <code>Copy</code> trait 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul><h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数与给变量赋值类似，可能会移动或赋值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">                                    <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处（没有调用drop析构）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure><h2 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h2><p>返回值也可以转移所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 转移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中，</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 会将</span></span><br><span class="line">                                             <span class="comment">// 返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域。</span></span><br><span class="line">    </span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string </span></span><br><span class="line">                                             <span class="comment">// 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用可以不获取所有权就可以使用值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tets&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">get_str_len</span>(&amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_str_len</span>(<span class="type">str</span>: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;s1</code>语法可以创建一个指向值<code>s1</code>的引用，但不拥有它，这种行为被称为<strong>借用，借用的变量不能进行修改</strong></p><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在增加了<code>mut</code>关键字后，可以对引用值进行修改，但需要注意的是，如果<strong>拥有一个对该变量的可变引用，那就不能再对该变量创建引用</strong>，不能同一时间多次将一个值作为可变变量借用，这样的限制可以避免数据竞争，数据竞争主要由以下三个行为造成：</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><p>当然，可以使用花括号来划分不同的作用域来实现同意值得多次借用，但在同一个作用域内，这样的行为不被允许。<strong>而可变引用与不可变引用也不能在同一个作用域中出现，但不可变引用可以在同一作用域出现多个</strong>，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p3</span> = &amp;<span class="keyword">mut</span> <span class="type">str</span>;<span class="comment">//有毛病</span></span><br></pre></td></tr></table></figure><p>不过，<strong>一个引用的作用域是从声明的地方到最后一次使用位置</strong>，所以可以进行如下改造</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = &amp;<span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p3</span> = &amp;<span class="keyword">mut</span> <span class="type">str</span>;<span class="comment">//没毛病</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p3);</span><br></pre></td></tr></table></figure><h2 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h2><p>我习惯称为野引用，指被借用的值的生命周期小于引用，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">str</span> = <span class="title function_ invoke__">get_str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_str</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效的。</li></ul><h1 id="Slice类型"><a href="#Slice类型" class="headerlink" title="Slice类型"></a>Slice类型</h1><p><code>slice</code>允许引用集合中一段连续的元素序列，而不是引用整个集合，它是一类引用，所以没有所有权。</p><p>现在假设一个场景，在一个以空格为分隔符的字符串中，找到第一个子串并返回，如果没有空格则返回其本身，在不使用<code>slice</code>的情况下，我们没有办法真正获取<strong>部分</strong>字符串，但可以返回索引，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s); <span class="comment">// word 的值为 5</span></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 这清空了字符串，使其等于 &quot;&quot;</span></span><br><span class="line">    <span class="comment">// word 在此处的值仍然是 5，</span></span><br><span class="line">    <span class="comment">// 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会引发一个问题，索引和字符串本身没什么关系，但凡字符串有改动，那么拿到的索引就会失效</p><h2 id="字符串slice"><a href="#字符串slice" class="headerlink" title="字符串slice"></a>字符串<code>slice</code></h2><p>字符串<code>slice</code>是<code>String</code>中一部分值的引用，写法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure><p>不同于<code>String</code>的引用，通过切片，将其分为了两个引用，分别是从第0个元素到第5个元素前，第6个元素到第11个元素前，形式为<code>[start_idx..end_idx]</code>，如果<code>start_idx</code>的值为0，那么也可以简写为<code>[..end_idx]</code>，如果<code>end_idx</code>的值为最后一个元素的位置，那么也可写作<code>[start_idx..]</code>，若要获取整个元素的切片，可以写作<code>[..]</code></p><p>现在，试着使用切片重写获取第一个子串的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误！</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行编译是，会发现<code>sclear()</code>会引发编译错误，这是因为<code>clear</code>想要清空字符串，需要获取一个可变的引用，而其下一句<code>println!</code>则使用了字符串中的不可变引用，rust中，可变引用和不可变引用不能同时存在，可变引用的最后一次使用应该位于不可变引用最后一次使用前</p><h2 id="字符串面值也是slice"><a href="#字符串面值也是slice" class="headerlink" title="字符串面值也是slice"></a>字符串面值也是<code>slice</code></h2><p>例如<code>let s = &quot;hello world&quot;;</code>此处<code>s</code>的类型是<code>&amp;str</code>，其是指向二进制程序特定位置的<code>slice</code>（静态区），所以<code>&amp;str</code>是一个不可变引用</p><h2 id="字符串slice做参数"><a href="#字符串slice做参数" class="headerlink" title="字符串slice做参数"></a>字符串<code>slice</code>做参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于以下函数定义</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line"><span class="comment">//也可写作</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>对第二种写法，如果有一个字符串<code>slice</code>，可以传递，如果有一个<code>String</code>，则可以传递整个<code>String</code>的引用或对<code>String</code>的引用，即这里会进行一次隐式类型转换，在使用时可如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// first_word 适用于String（的 slice），部分或全部</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line"><span class="comment">// first_word 也适用于 String 的引用，</span></span><br><span class="line"><span class="comment">// 这等价于整个 String 的 slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first_word 适用于字符串字面值，部分或全部</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为字符串字面值已经是字符串 slice 了，</span></span><br><span class="line"><span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br></pre></td></tr></table></figure><h2 id="其他类型slice"><a href="#其他类型slice" class="headerlink" title="其他类型slice"></a>其他类型<code>slice</code></h2><p>跟<code>string</code>差裘不多</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 通过所有权系统管理内存，编译器在编译时会根据一系列规则进行检查，如果违反了这些规则，程序不能通过编译。在运行时，所有权系统的任何功能都不会减缓程序的运行&lt;/p&gt;
&lt;h1 id=&quot;所有权规则&quot;&gt;&lt;a href=&quot;#所有权规则&quot; class=&quot;headerlink&quot; title=&quot;所有权规则&quot;&gt;&lt;/a&gt;所有权规则&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Rust 中的每一个值都有一个&lt;strong&gt;所有者&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;值在任意时刻有且仅有一个所有者&lt;/li&gt;
&lt;li&gt;当所有者（变量）离开作用域，这个值将被丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-变量、函数与控制流</title>
    <link href="http://zhaozhuolin.com/2023/05/20230507.html"/>
    <id>http://zhaozhuolin.com/2023/05/20230507.html</id>
    <published>2023-05-07T11:20:01.000Z</published>
    <updated>2024-05-26T03:48:10.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-hello-world-开始"><a href="#从-hello-world-开始" class="headerlink" title="从 hello world 开始"></a>从 hello world 开始</h1><p>创建一个 <code>main.rs</code> 文件，写入以下内容</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用以下命令进行编译运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><ul><li>也可使用<code>Cargo</code>工具进行构建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo new  <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;project_name&#125;</span></span><br><span class="line"><span class="comment">#这将会创建如下结构</span></span><br><span class="line"><span class="variable">$&#123;project_name&#125;</span></span><br><span class="line">src/main.rs</span><br><span class="line">Cargo.toml</span><br></pre></td></tr></table></figure><span id="more"></span><p>其中，<code>toml</code>文件内容如下</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;project_name&quot;</span> <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#项目版本</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#Rust版本，当前为2015 2018 2021，默认为2015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span> <span class="comment">#依赖的包</span></span><br></pre></td></tr></table></figure><p>在 <code>src/main.rs</code> 中写入内容， 使用<code>cargo build/cargo build --release</code> 进行构建，编译产物将会放在<code>target/debug/$&#123;project_name&#125; or target/release/$&#123;project_name&#125;</code>下，也可使用<code>cargo run</code>直接编译运行，也可使用<code>cargo check</code>来进行编译检查</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>变量与可变性</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">//不可变</span></span><br><span class="line">x = <span class="number">6</span>; <span class="comment">//编译失败</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">6</span>; <span class="comment">//可变</span></span><br><span class="line">y = <span class="number">6</span>; <span class="comment">//正确的，没问题的</span></span><br></pre></td></tr></table></figure><ul><li>常量</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SOME_VALUE: <span class="type">u32</span> = <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>常量使用<code>const</code>关键字进行声明，常量可以在任何作用域中声明，并且声明常量时<strong>必须注明值的类型</strong></p><ul><li>隐藏</li></ul><p>当定义多个同名的变量时，只有之前的变量都会被最后一次定义的变量隐藏，直到最后一次定义的变量作用于结束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码，首先将<code>x</code>绑定到值<code>5</code>上， 接着通过<code>let x =</code>创建了新的变量<code>x</code>，获取初始值并加一，此时<code>x</code>的值变为<code>6</code>，接着在花括号创建的作用于内，<code>x</code>又被隐藏了一次，此时<code>x</code>的值为12，在作用于结束时，隐藏也结束了，<code>x</code>又变回6，因此以上程序输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.31s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure><p>隐藏实际上是创建了一个新的同名变量，可以改变变量值类型，并复用这个名字，而<code>mut</code>关键字无法做到这一点，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二次为数字类型，使用隐藏可以做到这一点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="comment">//第一次定义 spaces 为字符串类型，第二句则尝试讲一个数字类型赋值给一个字符串类型的变量，此时编译会失败</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每一个值都属于某一个数据类型，这将高速Rust编译器它被指定为何种数据，一遍明确数据处理方式，存在两类数据源类型子集：<em>标量</em>与<em>复合</em></p><p>通常编译器可以自动推导数据类型，不过某些情况下需要显示的指定数据类型，例如数据类型可能有多种情况时，例如将字符串转为数字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number !&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>代表单独一个值，Rust中有四种基本标量类型：整形、浮点型、布尔型以及字符串类型</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>默认类型为<code>i32</code></p><div class="table-container"><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table></div><p>而对于数字面值，允许使用类型后缀，例如<code>64u8</code>为<code>u8</code>类型的64，也允许使用<code>_</code>下划线作为分隔符，例如<code>1_000</code>等价于<code>1000</code></p><div class="table-container"><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr><tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr><tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr><tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (单字节字符)(仅限于<code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table></div><blockquote><p>关于整型溢出，Debug模式下构建的二进制，在发生溢出时会panic，Release模式下构建的二进制会进行二进制补码操作，来绕回最小值，如256+1 = 0</p><p>对于整型溢出，可采用以下方式显示处理</p><ul><li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li><li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li><li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li><li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li></ul></blockquote><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p><code>f32</code>与<code>f64</code>，分别占32位于64位，默认为<code>f64</code>，浮点型数据都是有符号的</p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br></pre></td></tr></table></figure><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>关键字为<code>char</code>，类型大小为4个字节，并代表了一个Unicode标量值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>可将多个值组合成一个类型，存在两种原生的复合类型：元组与数组</p><h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><p>将多个其他类型的值组合仅一个复合类型，元组长度固定，一旦声明，其长度不会变化</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当想从元组中获取单个值时， 可以使用模式匹配来结构元组值，例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">1.23</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="comment">//创建了 x, y, z 来将 tup 分成了三个变量，</span></span><br></pre></td></tr></table></figure><p>也可使用<code>.</code>来进行访问，例如<code>tup.0</code>即为第一个值<code>500</code></p><p>不带任何值的元组有个特殊的名称，叫做 <strong>单元</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。<strong>如果表达式不返回任何其他值，则会隐式返回单元值。</strong></p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组中的每个元素类型必须相同，且数组的长度是固定的，数组在栈上分配空间</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">array2</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">//5个i32类型数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">array3</span> = [<span class="number">3</span>; <span class="number">5</span>];<span class="comment">//标识数组中有 5 个 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = array[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;number is &#123;one&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="函数与控制流"><a href="#函数与控制流" class="headerlink" title="函数与控制流"></a>函数与控制流</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用关键字<code>fun</code>声明，函数名与变量名使用Unix风格，小写字母，并使用下换线分割单词</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。</strong></p><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数必须声明参数类型，多个参数使用逗号分割</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><ul><li><strong>语句</strong> 执行一些操作但不返回值的指令，以分号结尾</li><li><strong>表达式</strong> 计算并产生一个值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>; <span class="comment">//语句不会返回任何值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = (<span class="keyword">let</span> <span class="variable">c</span> = <span class="number">2</span>);<span class="comment">//编译会失败 let c = 2 不会返回值</span></span><br></pre></td></tr></table></figure><p>在rust中，函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">1</span>;</span><br><span class="line">    b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时 a = 4</span></span><br></pre></td></tr></table></figure><h3 id="具有返回值的函数"><a href="#具有返回值的函数" class="headerlink" title="具有返回值的函数"></a>具有返回值的函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ret</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">ret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a><code>if</code>表达式</h3><p><strong><code>if</code>表达式使用的值必须为<code>bool</code>类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">5</span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &#123; <span class="comment">//不能这样使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>也可在<code>let</code>中使用，但是需要每个分支都必须是相同的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">flag</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="number">1</span>&#125;; <span class="comment">//可以</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num2</span> = <span class="keyword">if</span> flag &#123;<span class="number">0</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;one&quot;</span>&#125; <span class="comment">//不行</span></span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h4><p>无条件的循环，可以使用<code>break</code>从循环跳出，同时可以返回一个值，也可以使用<code>continue</code>跳过循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;loopping !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> cnt * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res = 200</span></span><br></pre></td></tr></table></figure><p><code>break</code>和<code>continue</code>仅能控制当前的循环，对于嵌套的循环，可以配合标签一起使用来控制循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">&#x27;loop_start</span>&#x27;: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cnt = &#123;cnt&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;loop_start</span>&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;End cnt = &#123;cnt&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="while条件循环"><a href="#while条件循环" class="headerlink" title="while条件循环"></a><code>while</code>条件循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> num != <span class="number">0</span> &#123;</span><br><span class="line">num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for遍历集合"><a href="#for遍历集合" class="headerlink" title="for遍历集合"></a><code>for</code>遍历集合</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">one</span> <span class="keyword">in</span> a &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;one&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从-hello-world-开始&quot;&gt;&lt;a href=&quot;#从-hello-world-开始&quot; class=&quot;headerlink&quot; title=&quot;从 hello world 开始&quot;&gt;&lt;/a&gt;从 hello world 开始&lt;/h1&gt;&lt;p&gt;创建一个 &lt;code&gt;main.rs&lt;/code&gt; 文件，写入以下内容&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;使用以下命令进行编译运行&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rustc main.rs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello, world!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;也可使用&lt;code&gt;Cargo&lt;/code&gt;工具进行构建&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cargo new  &lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#这将会创建如下结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;project_name&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	src/main.rs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Cargo.toml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://zhaozhuolin.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CMake语法小结</title>
    <link href="http://zhaozhuolin.com/2023/03/20230318.html"/>
    <id>http://zhaozhuolin.com/2023/03/20230318.html</id>
    <published>2023-03-18T12:55:09.000Z</published>
    <updated>2023-05-07T11:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h3><p><code>PROJECT(name)</code>指定工程名称， 默认支持所有语言</p><p><code>PROJECT(name CXX)</code>指定工程名称， 支持C++</p><p>会隐式定义两个变量</p><ul><li>${name}_BINARY_DIR</li><li>${name}_SOURCE_DIR</li></ul><p>修改工程名时会将这两个变量修改，可通过预定义两个变量<code>PROJECT_BINARY_DIR</code>以及<code>PROJECT_SOURCE_DIR</code>解决该问题</p><h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h3><p>设定值，<code>SET(SRC_LIST main.cpp a.cpp b.cpp)</code>，即设定了<code>SEC_LIST</code>的值</p><h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h3><p>输出自定义的信息，主要有三种</p><ul><li>SEND_ERROR，产生错误生成过程被跳过</li><li>STAUS，显示普通的消息</li><li>FATAL_ERROR，终止cmake过程</li></ul><span id="more"></span><h3 id="ADD-EXECUTABLE"><a href="#ADD-EXECUTABLE" class="headerlink" title="ADD_EXECUTABLE"></a>ADD_EXECUTABLE</h3><p>生成可执行文件<code>ADD_EXECUTABLE(target src)</code></p><h3 id="ADD-SUBDIRECTORY"><a href="#ADD-SUBDIRECTORY" class="headerlink" title="ADD_SUBDIRECTORY"></a>ADD_SUBDIRECTORY</h3><ul><li>添加存放源文件的子目录，并可指定中间二进制与目标二进制的存放位置</li><li><code>EXECULDE_FORM_ALL</code>可将参数从编译中排除</li><li><code>ADD_SUBDIRECTORY(src bin)</code><ul><li>将src目录加入工程并指定编译输出（包含中间结果）路径为bin目录</li><li>如果不进行 bin 目录指定， 那编译结果（包含中间文件）将会存放在指定的 执行cmake命令目录下的src</li></ul></li></ul><h3 id="关于更改二进制保存路径"><a href="#关于更改二进制保存路径" class="headerlink" title="关于更改二进制保存路径"></a>关于更改二进制保存路径</h3><ul><li><code>SET(EXECUTABLE_OUTPUT_PATH $(PROJECT_BINARY_DIR)/bin)</code></li><li><code>SET(LIBRARY_OUTPUT_PATH $(PROJECT_BINARY_DIR)/lib)</code></li></ul><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol><li>变量使用<code>$&#123;&#125;</code>取值，<strong>但在 IF 语句中直接使用变量名</strong></li><li>指令中的参数需使用<code>()</code>括起来，参数之间使用空格或分号分隔</li><li>指令大小写无关</li><li>如果参数中包含空格，则需要将参数使用双引号包括</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>INSTALL：安装指令，包括二进制，动态库，静态库以及文件，目录，脚本等</p><p>CMAKE_INSTALL_PREFIX：—prefix</p></blockquote><ul><li>安装文件：<code>INSTALL(FILES file1 file2 DESTINATION dst_dir)</code>，将<code>file1</code>以及<code>file2</code>安装到<code>dest_dir</code>中，其中<code>FILES</code>为文件，<code>DESTINATION</code>一般为：<ul><li>绝对路径</li><li>相对路径，即为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;DESTINATION&#125;</code>，<code>CMAKE_INSTALL_PREFIX</code>一般默认为<code>/usr/local/</code>，可使用<code>cmake -DCMAKE_INSTALL_PREFIX=/usr</code>指定该变量的值</li></ul></li><li>安装脚本：<code>INSTALL(PROGRAMS abc.sh bin)</code>，<code>PROGRAMS</code> 为非目标文件的可执行程序安装</li><li>安装目录：<ul><li>直接在需要安装的目录内创建CMakeList.txt，在其内写INSTALL file</li><li><code>INSTALL(DIRECTORY dir/ DESTINATION dst_dir)</code>：若为<code>dir/</code>则表示将<code>dir</code>目录下所有内容安装到<code>dst_dir</code>下，若为<code>dir</code>则表示将<code>dir</code>目录本身安装到<code>dst_dir</code></li></ul></li><li>安装库文件：<code>INSTALL(TARGET bin_name lib_name_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</code>，安装二进制，静态或动态库均需要使用<code>TARGET</code>，<code>ARCHIVE</code>特指静态库，<code>LIBRARY</code>特指动态库，<code>RUNTIME</code>特指可执行的目标二进制</li></ul><h2 id="构建静态库与动态库"><a href="#构建静态库与动态库" class="headerlink" title="构建静态库与动态库"></a>构建静态库与动态库</h2><p><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></p><ul><li>lib_name：库名称</li><li>SHARED：表示生成动态库，STATIC表示生成静态库</li><li>LIB_SRC：源文件</li></ul><blockquote><p>同时构建静态库与动态库的方式：</p><ol><li><p>使用两个名字，例如</p><ul><li><code>ADD_LIBRARY(lib_name SHARED $&#123;LIB_SRC&#125;)</code></li><li><code>ADD_LIBRARY(lib_name_static STATIC $&#123;LIB_SRC&#125;)</code></li></ul></li><li><p>使用<code>SET_TARGET_PROPERTIES</code>，设置输出名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIB_NAME_SRC lib_src.cpp)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name_static STATIC <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">//重命名lib_name_static为lib_name</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">//在构建新的目标时，会尝试清理掉其他使用使用这个名称的库，例如构建lib_name.so时会清除掉lib_name.a</span><br><span class="line">SET_TARGET_PROPETIES(lib_name_static PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(lib_name SHARED <span class="variable">$&#123;LIBNAME_SRC&#125;</span>)</span><br><span class="line">   </span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES OUTPUT <span class="string">&quot;lib_name&quot;</span>)</span><br><span class="line">SET_TARGET_PROPETIES(lib_name PROPETIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="动态库版本号设定"><a href="#动态库版本号设定" class="headerlink" title="动态库版本号设定"></a>动态库版本号设定</h3><p><code>SET_TARGET_PROPERTIES(lib_name PROPERTIES VERSION 1.2 SOVERSION 1)</code>，其中：</p><ul><li>VERSION：动态库版本</li><li>SOVERSION：API版本</li></ul><h2 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h2><p><code>INCLUDE_DIRECTORIES(head_path)</code>，指定头文件路径</p><p><code>LINK_DIRECTORIES(lib_path)</code>，指定库路径</p><p><code>TARGET_LINK_LIBRARIES(bin_name lib_name)</code>，指定二进制<code>lib_name</code>要链接的库文件</p><h2 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h2><ul><li><code>CMAKE_INCLUDE_PATH</code>，头文件路径</li><li><code>CMAKE_LIBRARY_PATH</code>，库文件路径</li><li><code>CMAKE_BUILD_TYPE</code>，release or debug等</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h1&gt;&lt;h2 id=&quot;关键字&quot;&gt;&lt;a href=&quot;#关键字&quot; class=&quot;headerlink&quot; title=&quot;关键字&quot;&gt;&lt;/a&gt;关键字&lt;/h2&gt;&lt;h3 id=&quot;PROJECT关键字&quot;&gt;&lt;a href=&quot;#PROJECT关键字&quot; class=&quot;headerlink&quot; title=&quot;PROJECT关键字&quot;&gt;&lt;/a&gt;PROJECT关键字&lt;/h3&gt;&lt;p&gt;&lt;code&gt;PROJECT(name)&lt;/code&gt;指定工程名称， 默认支持所有语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PROJECT(name CXX)&lt;/code&gt;指定工程名称， 支持C++&lt;/p&gt;
&lt;p&gt;会隐式定义两个变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${name}_BINARY_DIR&lt;/li&gt;
&lt;li&gt;${name}_SOURCE_DIR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改工程名时会将这两个变量修改，可通过预定义两个变量&lt;code&gt;PROJECT_BINARY_DIR&lt;/code&gt;以及&lt;code&gt;PROJECT_SOURCE_DIR&lt;/code&gt;解决该问题&lt;/p&gt;
&lt;h3 id=&quot;SET关键字&quot;&gt;&lt;a href=&quot;#SET关键字&quot; class=&quot;headerlink&quot; title=&quot;SET关键字&quot;&gt;&lt;/a&gt;SET关键字&lt;/h3&gt;&lt;p&gt;设定值，&lt;code&gt;SET(SRC_LIST main.cpp a.cpp b.cpp)&lt;/code&gt;，即设定了&lt;code&gt;SEC_LIST&lt;/code&gt;的值&lt;/p&gt;
&lt;h3 id=&quot;MESSAGE关键字&quot;&gt;&lt;a href=&quot;#MESSAGE关键字&quot; class=&quot;headerlink&quot; title=&quot;MESSAGE关键字&quot;&gt;&lt;/a&gt;MESSAGE关键字&lt;/h3&gt;&lt;p&gt;输出自定义的信息，主要有三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SEND_ERROR，产生错误生成过程被跳过&lt;/li&gt;
&lt;li&gt;STAUS，显示普通的消息&lt;/li&gt;
&lt;li&gt;FATAL_ERROR，终止cmake过程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://zhaozhuolin.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="cmake" scheme="http://zhaozhuolin.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://zhaozhuolin.com/2021/03/20210312.html"/>
    <id>http://zhaozhuolin.com/2021/03/20210312.html</id>
    <published>2021-03-12T05:08:09.000Z</published>
    <updated>2024-05-26T03:48:10.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的构成"><a href="#图的构成" class="headerlink" title="图的构成"></a>图的构成</h1><p><strong>顶点集合</strong>+<strong>边的集合</strong>：<code>G = (V, E)</code>，顶点集合<code>V = {x | x属于某个数据对象及}</code>是有穷非空集合</p><ul><li><p><code>E = {(x, y) | x, y属于V}</code>或者<code>E = {&lt;x, y&gt; | x, y属于V &amp;&amp; Path(x, y)}</code>是顶点间关系的有穷集合，也叫边集合</p></li><li><p><code>(x, y)</code>表示x到y的一条双向通道，即<code>(x, y)</code>是无方向的，<code>Path(x, y)</code>表示从x到y的一条单向通路，即<code>Path(x, y)是有方向的</code></p></li></ul><p>顶点和边：图中节点成为顶点，第i个顶点记作vi， 两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中第k条边记作ek，<code>ek = (vi, vj)</code>或<code>ek = &lt;vi, vj&gt;</code></p><ul><li>在有向图中，顶点对<code>&lt;x, y&gt;</code>是有序的，顶点对<code>&lt;x, y&gt;</code>称为顶点x到顶点y的一条边(弧)，<code>&lt;x, y&gt;</code>和<code>&lt;y ,x&gt;</code>是两条不同的边，如G3、G4</li><li>在无向图中，顶点对(x, y)是无序的，顶点对(x,y) 称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，如G1、G2</li><li>注意：<strong>无向边<code>(x, y)</code>等于有向边<code>&lt;x, y&gt;</code>和<code>&lt;y, x&gt;</code></strong></li></ul><span id="more"></span><p><em>可以表示</em>：社交关系</p><ul><li>社交关系中，每个人就是一个顶点，两个人是好友，他们之间就有了边，那么边的权值可以是他们的亲密度</li><li>无向图：QQ、微信类似的社交关系可以被看作是无向图（强社交关系，熟人社交）</li><li>有向图：微博（关注的关系）、抖音 （弱社交关系，陌生人社交、粉丝社交）</li><li>也可以用来表示地图（导航路线选择），网络连接（路由器选择）</li><li>vertex 顶点、edge 边、weight 权值</li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ol><li>完全图（即所有顶点相连接）：在有n个顶点的无向图中，若有<code>n * (n-1)/2</code>条边，即<em>任意两个顶点之间有且仅有一条边</em>，则称此图为<strong>无向完全图</strong>，如G1；在n个顶点的有向图中，若有<code>n * (n-1)</code>条边，即<em>任意两个顶点之间有且仅有方向</em> 相反的边，则称此图为<strong>有向完全图</strong>，如G4。</li><li>邻接顶点：在无向图中G中，若(u, v)是E(G)中的一条边，则称u和v互为邻接顶点，并称边(u,v)依附于顶点u 和v；在有向图G中，若是E(G)中的一条边，则称顶点u邻接到v，顶点v邻接自顶点u，并称边与 顶点u和顶点v相关联。</li><li>顶点的度：<u>顶点v的度是指与它相关联的边的条数</u>，记作<code>deg(v)</code>。在有向图中，顶点的度等于该顶点的入度与 出度之和，其中顶点v的入度是以v为终点的有向边的条数，记作<code>indev(v)</code>;顶点v的出度是以v为起始点的有向 边的条数，记作<code>outdev(v)</code>。因此：<code>dev(v) = indev(v) + outdev(v)</code>。注意：对于无向图，顶点的度等于该顶 点的入度和出度，即<code>dev(v) = indev(v) = outdev(v)</code>。</li><li>路径：在图<code>G = (V， E)</code>中，若从顶点vi出发有一组边使其可到达顶点vj，则称顶点vi到顶点vj的顶点序列为从 顶点vi到顶点vj的路径。</li><li>路径长度：对于不带权的图，一条路径的路径长度是指该路径上的边的条数；对于带权的图，一条路 径的路 径长度是指该路径上各个边权值的总和。</li></ol><p><img src="/2021/03/20210312/008eGmZEly1gpljuxnpgij30k00i1aby.jpg" alt="截屏2021-04-16 14.04.25"></p><ol><li>简单路径与回路：若路径上各顶点v1，v2，v3，…，vm均不重复，则称这样的路径为简单路径。若路 径上 第一个顶点v1和最后一个顶点vm重合，则称这样的路径为回路或环。即路径不重复为简单路径，重复则为回路</li><li>子图：某个图的一个部分（一部分边、一部分顶点等）称为其的子图</li><li>连通图：在<strong>无向图</strong>中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。如果图中任意一 对顶点 都是连通的，则称此图为连通图。（连通图不一定是完全图，但完全图一定是连通图，对连通图来说，仅需有路径即可，而完全图则要求两顶点邻接）</li><li>强连通图：在<strong>有向图</strong>中，若在每一对顶点vi和vj之间都存在一条从vi到vj的路径，也存在一条从vj到 vi的路 径，则称此图是强连通图</li><li>生成树（用最少的边把图连通）：一个连通图的最小连通子图称作该图的生成树。有n个顶点的连通图的生成树有n个顶点和n - 1条边。</li></ol><ul><li>图和树的区别：<ul><li>树可以认为是特殊的图，图不一定是树</li><li>联通图，且不带环（没有回路），就可以认为是树</li></ul></li></ul><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>保存节点以及边的关系</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>因为节点与节点之间的关系就是连通与否，即为0或者1，因此邻接矩阵(二维数组)即是：先用一个数组将顶点保存，然后采用矩阵来表示节点与节点之间的关系。</p><p><img src="/2021/03/20210312/008eGmZEly1gplp3axgjsj306n06wjrm.jpg" alt="截屏2021-04-16 17.05.50"></p><p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下</p><script type="math/tex; mode=display">edge = \left[ \begin{matrix}  & A & B & C & D \\ A & 0 & 1 & 0 & 1 \\ B & 1 & 0 & 1 & 0 \\ C & 0 & 1 & 0 & 1 \\ D & 1 & 0 & 1 & 0 \end{matrix} \right]</script><p><img src="/2021/03/20210312/008eGmZEly1gpltlbqflfj305i098jrl.jpg" alt="截屏2021-04-16 19.41.36"></p><p>用<code>vector&lt;char&gt; vertex</code>保存顶点，用矩阵<code>vector&lt;vector&lt;W&gt; &gt; edge</code>保存边，如下</p><script type="math/tex; mode=display">edge = \left[ \begin{matrix}  & A & B & C  \\ A & 0 & 1 & 0 \\ B & 1 & 0 & 1 \\ C & 0 & 0 & 0\end{matrix} \right]</script><ul><li>无向图的邻接矩阵是对称的，第i行(列)元素之和，就是顶点i的度。有向图的邻接矩阵则不一定是对称 的，第i行(列)元素之后就是顶点i 的出(入)度</li><li>如果边带有权值，并且两个节点之间是连通的，上图中的边的关系就用权值代替，如果两个顶点不通， 则使用无穷大代替</li><li>用邻接矩阵存储图的有点是能够快速知道两个顶点是否连通，缺陷是如果顶点比较多，边比较少时，矩 阵中存储了大量的0成为系数矩阵，比较浪费空间，并且要求两个节点之间的路径不是很好求。</li></ul><p><img src="/2021/03/20210312/008eGmZEly1gpluoyfacuj30m409f406.jpg" alt="截屏2021-04-16 20.18.53"></p><h3 id="邻接矩阵代码实现"><a href="#邻接矩阵代码实现" class="headerlink" title="邻接矩阵代码实现"></a>邻接矩阵代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vertex 顶点</span></span><br><span class="line"><span class="comment">//edge 边</span></span><br><span class="line"><span class="comment">//weight 权值</span></span><br><span class="line"><span class="comment">//matrix矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> matrix</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        {</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            _matrex.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                _matrex[i].<span class="built_in">resize</span>(n, <span class="built_in">W</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">"非法顶点"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            _matrex[srcIndex][dstIndex] = w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">                _matrex[dstIndex][srcIndex] = w;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;vector&lt;W&gt; &gt; _matrex;     <span class="comment">//表示邻接矩阵的边</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>使用数组表示顶点的集合，使用链表表示边的关系。</p><ul><li>图为无向图的邻接表存储</li></ul><p><img src="/2021/03/20210312/008eGmZEly1gpn1zc5fnyj30ir08adgk.jpg" alt="截屏2021-04-17 21.17.19"></p><ul><li>注意：无向图中同一条边在邻接表中出现了两次。如果想知道顶点vi的度，只需要知道顶点vi边链表集合中结点的数目即可</li><li>有向图则添加一个边的集合或者反向添加一次</li></ul><h2 id="邻接表的代码实现"><a href="#邻接表的代码实现" class="headerlink" title="邻接表的代码实现"></a>邻接表的代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> table</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> _srcIndex;</span><br><span class="line">        <span class="type">int</span> _dstIndex;</span><br><span class="line">        <span class="type">const</span> W&amp; _w;</span><br><span class="line"></span><br><span class="line">        EdgeNode&lt;W&gt;* _next;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">W</span>, <span class="type">bool</span> IsDirect = <span class="literal">false</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> Graph</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(V* vertexs, <span class="type">int</span> n)</span><br><span class="line">        {</span><br><span class="line">            _vertexs.<span class="built_in">reserve</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            {</span><br><span class="line">                _vertexs.<span class="built_in">push_back</span>(vertexs[i]);</span><br><span class="line">                _vertexIndexMap[vertexs[i]] = i;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            _linkTable.<span class="built_in">resize</span>(n, <span class="literal">nullptr</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexIndex</span><span class="params">(<span class="type">const</span> V&amp; v)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">auto</span> it = _vertexIndexMap.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it != _vertexIndexMap.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> it.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return -1;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">"非法顶点"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> V&amp; src, <span class="type">const</span> V&amp; dst, <span class="type">const</span> W&amp; w)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">            <span class="type">int</span> dstIndex = <span class="built_in">GetVertexIndex</span>(dst);</span><br><span class="line"></span><br><span class="line">            EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">            node-&gt;_srcIndex = srcIndex;</span><br><span class="line">            node-&gt;_dstIndex = dstIndex;</span><br><span class="line">            node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//挂起头</span></span><br><span class="line">            node-&gt;_next = _linkTable[srcIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">            _linkTable[srcIndex] = node;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(IsDirect == <span class="literal">false</span>)</span><br><span class="line">            {</span><br><span class="line">                EdgeNode&lt;W&gt;* node = <span class="keyword">new</span> EdgeNode&lt;W&gt;;</span><br><span class="line">                node-&gt;_srcIndex = dstIndex;</span><br><span class="line">                node-&gt;_dstIndex = srcIndex;</span><br><span class="line">                node-&gt;_w = w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//挂起头</span></span><br><span class="line">                node-&gt;_next = _linkTable[dstIndex];<span class="comment">//链表的头插操作</span></span><br><span class="line">                _linkTable[dstIndex] = node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;V&gt; _vertexs;             <span class="comment">//顶点集合</span></span><br><span class="line">        map&lt;V, <span class="type">int</span>&gt; _vertexIndexMap;    <span class="comment">//表示顶点的下表映射关系</span></span><br><span class="line">        vector&lt;EdgeNode&lt;W&gt;*&gt; _linkTable;<span class="comment">//邻接表</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历 一次。”遍历”即对结点进行某种操作的意思</p><h2 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h2><p>对邻接矩阵，深度优先可是使用递归的方式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _DFS(<span class="type">int</span> srcIndex, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span><br><span class="line">{</span><br><span class="line">  cout &lt;&lt; _vertexs[srcIndex] &lt;&lt; <span class="string">":"</span> &lt;&lt; srcIndex &lt;&lt; <span class="string">"-&gt;"</span>;<span class="comment">//输出当前节点</span></span><br><span class="line">  visited[srcIndex] = <span class="literal">true</span>;<span class="comment">//标记当前节点已访问</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">  {<span class="comment">//访问当前节点的相邻顶点</span></span><br><span class="line">    <span class="keyword">if</span>(_matrex[srcIndex][i] != <span class="built_in">W</span>() &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">      _DFS(i, visited);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line">  _DFS(srcIndex, visited);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h2><p>对邻接矩阵，广度优先可以使用队列实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> V&amp; src)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(_vertexs.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> srcIndex = <span class="built_in">GetVertexIndex</span>(src);</span><br><span class="line"></span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(srcIndex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; _vertexs[front] &lt;&lt; <span class="string">":"</span> &lt;&lt; front &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    <span class="comment">//好友入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _vertexs.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(visited[i] == <span class="literal">false</span> &amp;&amp; _matrex[front][i] != <span class="built_in">W</span>())</span><br><span class="line">      {</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>连通图中的每一棵生成树，都是原图的一个极大无环子图，即：从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成一条回路。 </p><p>若连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边。因此构造最小生成树的准则有三条：</p><ol><li>只能使用图中的边来构造最小生成树 </li><li>只能使用恰好n-1条边来连接图中的n个顶点</li><li>选用的n-1条边不能构成回路</li></ol><p>构造最小生成树的方法：<strong>Kruskal算法</strong>和<strong>Prim算法</strong>。</p><ul><li>这两个算法都采用了<strong>逐步求解的贪心策略</strong>。 贪心算法：是指在问题求解时，总是做出当前看起来最好的选择。也就是说贪心算法做出的不是整体最优的选择，而是某种意义上的局部最优解。贪心算法不是对所有的问题都能得到整体最优解。</li></ul><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><ol><li><p>任给一个有n个顶点的连通网络<code>N={V,E}</code></p></li><li><p>首先构造一个由这n个顶点组成、不含任何边的图<code>G={V,NULL}</code>，其中每个顶点自成一个连通分量</p></li><li>接着不断从E中取出权值最小的一条边(若有多条任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。</li><li>如此重复，直到所有顶点在同一个连通分量上为止。 </li></ol><ul><li>核心：每次迭代时，选出一条具有最小权值，且两端点不在同一连通分量上的边，加入生成树。</li></ul><blockquote><p>如何判断选出一条边以后跟已有的边是否构成回路：并查集</p><p>如果选的边在一个集合中，就不能再使用，不在一个集合才能添加</p></blockquote><h2 id="Prime算法"><a href="#Prime算法" class="headerlink" title="Prime算法"></a>Prime算法</h2><p>仍是贪心算法，但它先选出最小的一条边，接着并非从全局中找到最小的边，而是以最小的边为基础，选已有的边的邻接顶点链接出的边中最小的，避开了选出环路的情况</p><h1 id="单元最短路径"><a href="#单元最短路径" class="headerlink" title="单元最短路径"></a>单元最短路径</h1><p>从在带权图的某一顶点出发，找出一条通往另一顶点的最短路径，最短也就是沿路径各边的权值总和达到最小。</p><blockquote><p>Dijkstra算法和Floyd算法</p></blockquote><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>求一个点和图中的其他所有点之间的最路径</p><p><img src="/2021/03/20210312/008i3skNly1gptzx4hmntj30au0a0mxt.jpg" alt="截屏2021-04-23 21.25.02"></p><p><img src="/2021/03/20210312/008i3skNly1gpu0bcc8v9j30kv089wgk.jpg" alt="截屏2021-04-23 21.38.39"></p><div class="table-container"><table><thead><tr><th>路径</th><th>路径长度</th></tr></thead><tbody><tr><td>0，1</td><td>无穷大</td></tr><tr><td>0，2</td><td>50</td></tr><tr><td>0，3</td><td>10</td></tr><tr><td>0，4</td><td>50</td></tr></tbody></table></div><p>依次遍历所有的边，找出更短路径，找到则更新</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;图的构成&quot;&gt;&lt;a href=&quot;#图的构成&quot; class=&quot;headerlink&quot; title=&quot;图的构成&quot;&gt;&lt;/a&gt;图的构成&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;顶点集合&lt;/strong&gt;+&lt;strong&gt;边的集合&lt;/strong&gt;：&lt;code&gt;G = (V, E)&lt;/code&gt;，顶点集合&lt;code&gt;V = {x | x属于某个数据对象及}&lt;/code&gt;是有穷非空集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;E = {(x, y) | x, y属于V}&lt;/code&gt;或者&lt;code&gt;E = {&amp;lt;x, y&amp;gt; | x, y属于V &amp;amp;&amp;amp; Path(x, y)}&lt;/code&gt;是顶点间关系的有穷集合，也叫边集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(x, y)&lt;/code&gt;表示x到y的一条双向通道，即&lt;code&gt;(x, y)&lt;/code&gt;是无方向的，&lt;code&gt;Path(x, y)&lt;/code&gt;表示从x到y的一条单向通路，即&lt;code&gt;Path(x, y)是有方向的&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顶点和边：图中节点成为顶点，第i个顶点记作vi， 两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中第k条边记作ek，&lt;code&gt;ek = (vi, vj)&lt;/code&gt;或&lt;code&gt;ek = &amp;lt;vi, vj&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在有向图中，顶点对&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;是有序的，顶点对&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;称为顶点x到顶点y的一条边(弧)，&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;y ,x&amp;gt;&lt;/code&gt;是两条不同的边，如G3、G4&lt;/li&gt;
&lt;li&gt;在无向图中，顶点对(x, y)是无序的，顶点对(x,y) 称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，如G1、G2&lt;/li&gt;
&lt;li&gt;注意：&lt;strong&gt;无向边&lt;code&gt;(x, y)&lt;/code&gt;等于有向边&lt;code&gt;&amp;lt;x, y&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;y, x&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://zhaozhuolin.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="图" scheme="http://zhaozhuolin.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>在线的面试预约系统</title>
    <link href="http://zhaozhuolin.com/2020/08/20200827.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200827.html</id>
    <published>2020-08-26T16:05:00.000Z</published>
    <updated>2023-05-07T11:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>通过httplib库函数中的Post和Get方法来处理以下四种请求</p><ul><li><code>注册</code> ：处理浏览器传来的数据，并调用数据库函数增加列</li><li><code>登录</code> ：处理浏览器传来的数据，在数据库中进行查询，登陆成功则生成sessionID用以后续使用</li><li><code>数据页面</code>：处理浏览器传来的数据，使用sessionID查询当前登录的用户，在数据库中查询该用户信息并返回</li><li><code>数据提交</code>：处理浏览器传来的数据，根据头部的sessionID查询登陆用户，切割正文提交的信息，插入数据库</li></ul><span id="more"></span><p><img src="/2020/08/20200827/007S8ZIlly1gi4nyalqwpj31f40nijuu.jpg" alt="IMG_7559"></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><h3 id="http服务"><a href="#http服务" class="headerlink" title="http服务"></a>http服务</h3><p>创建了一个类来完成整个项目的运行，这个类用于保存登录数据库的参数、所有登录用户的sessionid、启动http服务，其结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AisSvr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AisSvr</span>()</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">OnInit</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span><span class="comment">//启动http服务</span></span></span><br><span class="line"><span class="function">  </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">GetSessionId</span><span class="params">(httplib::Request res, string* session_id)</span></span>;<span class="comment">//获取当前用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> string&amp; config_filename)</span></span>;<span class="comment">//打开配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string _svr_ip;<span class="comment">//服务端监听的IP地址</span></span><br><span class="line">  <span class="type">uint16_t</span> _svr_port;<span class="comment">//服务端监听的端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据库类成员</span></span><br><span class="line">  DataBaseSvr* _db;</span><br><span class="line">  string _db_ip;</span><br><span class="line">  string _db_user;</span><br><span class="line">  string _db_passwd;</span><br><span class="line">  string _db_name;</span><br><span class="line">  <span class="type">uint16_t</span> _db_port;</span><br><span class="line"></span><br><span class="line">  AllSessionInfo* _all_session;<span class="comment">//所有登录用户的sessionid</span></span><br><span class="line"></span><br><span class="line">  httplib::Server _http_svr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>对于数据库的操作，同样创建了一个类来完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataBaseSvr</span><span class="comment">//数据库类</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DataBaseSvr</span>(string&amp; host, string&amp; user, string&amp; passwd, string&amp; db, <span class="type">uint16_t</span> port)</span><br><span class="line">    &#123;</span><br><span class="line">      _host = host;</span><br><span class="line">      _user = user;</span><br><span class="line">      _passwd = passwd;</span><br><span class="line">      _db = db;</span><br><span class="line">      _port = port;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">mysql_init</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DataBaseSvr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">mysql_close</span>(&amp;_mysql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QuerySql</span><span class="params">(<span class="type">const</span> string&amp; sql)</span></span>;<span class="comment">//操作数据库接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Connect2MySQL</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="type">bool</span> <span class="title">QueryUserExist</span><span class="params">(Json::Value&amp; request_json, Json::Value* result)</span></span>;<span class="comment">//数据库查询</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QueryOneStuInfo</span><span class="params">(string user_id, Json::Value* result)</span></span>;<span class="comment">//查询用户信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//MySQL就是客户端的操作句柄</span></span><br><span class="line">    MYSQL _mysql;</span><br><span class="line">    string _host;</span><br><span class="line">    string _user;</span><br><span class="line">    string _passwd;</span><br><span class="line">    string _db;</span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sessionid管理"><a href="#sessionid管理" class="headerlink" title="sessionid管理"></a>sessionid管理</h3><p>创建了一个类专门计算MD5值，用另一个类进行封装，同时管理一批sessionid</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Session</span>(Json::Value&amp; user_info)</span><br><span class="line">    &#123;</span><br><span class="line">      _origin_str.<span class="built_in">clear</span>();</span><br><span class="line">      _user_info = user_info;</span><br><span class="line"></span><br><span class="line">      _origin_str += <span class="built_in">to_string</span>(_user_info[<span class="string">&quot;stu_id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_name&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">      _origin_str += _user_info[<span class="string">&quot;stu_interview_time&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Session</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SumMd5</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">string&amp; <span class="title">GetSessionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">SumMd5</span>();</span><br><span class="line">      <span class="keyword">return</span> _session_id;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//private:因为不想再写个接口获取sessionid所以直接将成员变量设为public（懒惰！）</span></span><br><span class="line">    string _session_id;<span class="comment">//保存session_id</span></span><br><span class="line">    string _origin_str;<span class="comment">//原始的串，用来生成session_id</span></span><br><span class="line">    Json::Value _user_info;<span class="comment">//原始串内容：stu_id, stu_name, stu_interview_time</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllSessionInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  ~<span class="built_in">AllSessionInfo</span>();</span><br><span class="line">  <span class="comment">//Set Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">SetSessionValue</span><span class="params">(string&amp; session_id, Session&amp; session_info)</span></span>;</span><br><span class="line">  <span class="comment">//Get Session</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetSessionValue</span><span class="params">(string&amp; session_id, Session* session_info)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//key：sessionid，value：session</span></span><br><span class="line">  unordered_map&lt;string, Session&gt; _session_map;</span><br><span class="line">  <span class="type">pthread_mutex_t</span> _map_lock;<span class="comment">//所有操作均需要互斥完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>该模块主要完成对浏览器响应正文的数据进行分割和解析，输出日志信息，较为简单</p><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><h3 id="响应登录请求-Post方法"><a href="#响应登录请求-Post方法" class="headerlink" title="响应登录请求(Post方法)"></a>响应登录请求(Post方法)</h3><ol><li>解析提交的内容</li><li>先根据邮箱作为查询条件，如果邮箱不存在，则登陆失败，如果邮箱存在，则校验密码</li><li>上一步校验失败，向浏览器返回false，校验成功则进行下一步</li><li>根据登录用户信息，生成sessionid，用以表示当前用户</li><li>跳转到个人信息页面</li></ol><h3 id="个人信息也页面-Get方法"><a href="#个人信息也页面-Get方法" class="headerlink" title="个人信息也页面(Get方法)"></a>个人信息也页面(Get方法)</h3><ol><li>根据请求头部的sessionid信息，从管理sessionid的类中获取当前登录用户信息</li><li>查询数据库，获取用户信息</li><li>组织应答</li></ol><h3 id="注册请求-Post方法"><a href="#注册请求-Post方法" class="headerlink" title="注册请求(Post方法)"></a>注册请求(Post方法)</h3><ol><li>解析请求正文</li><li>将解析出的用户信息插入注册信息表(此处需要开启数据库事务，加入注册信息插入失败，则回滚)</li><li>组织应答</li></ol><h3 id="预约请求-Post方法"><a href="#预约请求-Post方法" class="headerlink" title="预约请求(Post方法)"></a>预约请求(Post方法)</h3><p>基本思路同注册请求</p><h1 id="效果预览图与项目代码"><a href="#效果预览图与项目代码" class="headerlink" title="效果预览图与项目代码"></a>效果预览图与项目代码</h1><p>注册页面</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nypyjs4j310k0qiwgl.jpg" alt="IMG_7555"></p><p>登录页面</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4nzbxgiwj310k0qiwgh.jpg" alt="IMG_7556"></p><p>数据提交页面</p><p><img src="/2020/08/20200827/007S8ZIlly1gi4o34di6rj30xn06574p.jpg" alt="IMG_7554"></p><p>个人信息页面</p><p><img src="/2020/08/20200827/007S8ZIlly1gi4o35739vj30xn06574p.jpg" alt="IMG_7558"></p><p>GitHub地址：<a href="https://github.com/Latsummer/interview-system">https://github.com/Latsummer/interview-system</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h1&gt;&lt;p&gt;通过httplib库函数中的Post和Get方法来处理以下四种请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;注册&lt;/code&gt; ：处理浏览器传来的数据，并调用数据库函数增加列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;登录&lt;/code&gt; ：处理浏览器传来的数据，在数据库中进行查询，登陆成功则生成sessionID用以后续使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据页面&lt;/code&gt;：处理浏览器传来的数据，使用sessionID查询当前登录的用户，在数据库中查询该用户信息并返回&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据提交&lt;/code&gt;：处理浏览器传来的数据，根据头部的sessionID查询登陆用户，切割正文提交的信息，插入数据库&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="小作品" scheme="http://zhaozhuolin.com/categories/%E5%B0%8F%E4%BD%9C%E5%93%81/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="后端" scheme="http://zhaozhuolin.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>简单的Boost文档搜索引擎--基于jieba分词和HTTP协议</title>
    <link href="http://zhaozhuolin.com/2020/08/20200826.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200826.html</id>
    <published>2020-08-26T07:40:00.000Z</published>
    <updated>2023-05-07T11:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更方便的使用Boost库，于是想到实现一个基于Boost离线文档的搜索引擎，对离线的HTML文件进行分析，、并对查询词进行分词（借用第三方库），然后根据相关性（简陋的相关性公式）进行排序，最终将查询结果用JSON的数据格式进行组织打包，最终通过对外的http服务将查询结果返回</p><span id="more"></span><h2 id="成品效果以及GitHub链接"><a href="#成品效果以及GitHub链接" class="headerlink" title="成品效果以及GitHub链接"></a>成品效果以及GitHub链接</h2><blockquote><p>由于不怎么会前端的一些语法，所以页面比较简陋</p></blockquote><p><img src="/2020/08/20200826/007S8ZIlly1gi49kgwwqmj31hc0u01a0.jpg" alt="IMG_7552"></p><p><img src="/2020/08/20200826/007S8ZIlly1gi49kbll6kj30rx06wwg2.jpg" alt="IMG_7553"></p><p>详细代码于 - GitHub链接：<a href="https://github.com/Latsummer/Boost-search-engine">GitHub  Boost-search-engine</a></p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>按照处理流程，整个项目的结构可以被分为，预处理模块，索引模块，搜索模块以及服务器模块</p><ol><li>预处理模块：读取原始的HTML文档内容，进行预处理操作：解析一些重要的信息，如文档标题、文档的URL，文档的正文，即去除HTML标签，只保留正文；在预处理完毕之后，将结果整理成一个行文本文件，用以之后的模块使用</li><li>索引模块：将预处理好的行文本文件输入，根据预处理结果，在内存中构造正排索引（文档ID =&gt; 文档正文）和倒排索引（文档正文 =&gt; 文档ID）</li><li>搜索模块：输入查询词，先对查询词进行分词，然后实现触发，将查询结果按照相关性进行排序，依次拼装，按照JSON数据格式进行组织</li><li>服务器模块：加载搜索引擎模块，对外提供HTTP服务</li></ol><p><img src="/2020/08/20200826/007S8ZIlly1gi49l0rlk0j317m0csgnf.jpg" alt="IMG_7551"></p><h1 id="预处理模块"><a href="#预处理模块" class="headerlink" title="预处理模块"></a>预处理模块</h1><p>该模块核心功能为：读取并分析Boost文档的.html文件内容，解析出每个文档的标题，URL，正文，最终把结果输出为一个行文版文件</p><p>首先根据核心功能，定义一个可以表示一个文章的结构体，以及一些全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string g_input_path = <span class="string">&quot;../data/input/&quot;</span>;<span class="comment">//表示从哪个目录中读取boost文档中的html</span></span><br><span class="line">string g_output_path = <span class="string">&quot;../data/tmp/raw_input&quot;</span>;<span class="comment">//表示预处理模块的输出结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  string tittle;<span class="comment">//标题</span></span><br><span class="line">  string url;<span class="comment">//url</span></span><br><span class="line">  string content;<span class="comment">//正文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="枚举路径"><a href="#枚举路径" class="headerlink" title="枚举路径"></a>枚举路径</h2><p>使用Boost中的filesystem的递归文档迭代器来对每一个文件进行枚举，使用一个vector来临时存储，用于之后的解析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnumFile</span><span class="params">(<span class="type">const</span> string&amp; input_path, vector&lt;string&gt;* file_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">filesystem::path <span class="title">root_path</span><span class="params">(input_path)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">exists</span>(root_path) )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;目录不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个迭代器使用循环的时候可以自动完成递归（对文件）</span></span><br><span class="line">  boost::filesystem::recursive_directory_iterator end_iter;</span><br><span class="line">  <span class="keyword">for</span>(boost::filesystem::recursive_directory_iterator <span class="built_in">it</span>(root_path);  it != end_iter; it++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//当前路径对应的如果是目录则跳过</span></span><br><span class="line">    <span class="keyword">if</span>( !boost::filesystem::<span class="built_in">is_regular_file</span>(*it) )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//当前路径对应的文件如果不是html文件，跳过</span></span><br><span class="line">    <span class="keyword">if</span>( it-&gt;<span class="built_in">path</span>().<span class="built_in">extension</span>() != <span class="string">&quot;.html&quot;</span> )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//把得到的路径加入到vector中</span></span><br><span class="line">    file_list-&gt;<span class="built_in">push_back</span>(it-&gt;<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h2><ol><li>遍历上一步vector中存放的文件路径，读取文件内容，将读取内容写入到string类型变量<code>html</code>中</li><li>根据读取到的内容，首先解析出标题，按照html中的标签<code>&lt;title&gt;&lt;/title&gt;</code>，调用string类成员函数<code>substr</code>获取文章标题</li><li>根据读取到的内容，构造对应的URL，由于网络路径和文件路径一致，所以只需要在文件的路径前加上前缀<code>https://www.boost.org/doc/libs/1_53_0/doc/</code>即可</li><li>根绝读取到的内容，解析正文片段，跳过字符<code>&lt;</code>和字符<code>&gt;</code>中的内容，同时将内容中的<code>\n</code>替换为空格（因为最终结果要对应到原始的html文档）</li><li>对于2、3、4步骤，解析出的三个内容使用不可见字符<code>\3</code>分割，然后写入删除文件<code>raw_put</code>中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFile</span><span class="params">(<span class="type">const</span> string&amp; file_path, DocInfo* doc_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//1. 先读取文件内容</span></span><br><span class="line">  string html;</span><br><span class="line">  <span class="type">bool</span> ret = common::Util::<span class="built_in">Read</span>(file_path, &amp;html);</span><br><span class="line">  <span class="keyword">if</span>(!ret)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解析文件失败!&quot;</span> &lt;&lt; file_path &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 根据文件内容解析出标题</span></span><br><span class="line">  ret = <span class="built_in">ParseTitle</span>(html, &amp;doc_info-&gt;tittle);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;标题解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3. 根据文件路径，构造出对应的在线文档</span></span><br><span class="line">  ret = <span class="built_in">ParseUrl</span>(file_path, &amp;doc_info-&gt;url);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;url 解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4. 根据文件内容，去标签，作为doc_info中的content字段内容</span></span><br><span class="line">  ret = <span class="built_in">ParseContent</span>(html, &amp;doc_info-&gt;content);</span><br><span class="line">  <span class="keyword">if</span>( !ret )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正文解析失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h1><p>索引使用了正排索引和倒排索引，其结构体分别如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正排索引：给定doc_id映射到文档内容（DocInfo对象）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DocInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;</span><br><span class="line">  string _title;</span><br><span class="line">  string _url;</span><br><span class="line">  string _content;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒排索引：给定词，映射到包含该词语的文档id列表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Weight</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int64_t</span> _doc_id;<span class="comment">//该词在哪个文档出现</span></span><br><span class="line">  <span class="type">int</span> _weight;<span class="comment">//对应的权重</span></span><br><span class="line">  string _word;<span class="comment">//什么词</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个类来表示整个索引结构，并提供外部调用的API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Index</span>();</span><br><span class="line">    <span class="comment">//1. 查正排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> DocInfo* <span class="title">GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span>;</span><br><span class="line">    <span class="comment">//2. 查倒排</span></span><br><span class="line">    <span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>;</span><br><span class="line">    <span class="comment">//3. 构建索引</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Build</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">DocInfo* <span class="title">BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span>;</span><br><span class="line">    cppjieba::Jieba jieba;<span class="comment">//jieba分词</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//正排索引，数组下标对应到doc_id</span></span><br><span class="line">    vector&lt;DocInfo&gt; _forward_index;</span><br><span class="line">    <span class="comment">//倒排索引，使用一个hash表来表示映射关系</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;Weight&gt; &gt; _inverted_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建正排索引"><a href="#创建正排索引" class="headerlink" title="创建正排索引"></a>创建正排索引</h2><p>正排索引使用vector来存放，文章的ID就是其所在位置的下标，元素内容就是预处理模块中的输出内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DocInfo* <span class="title">Index::BuildForward</span><span class="params">(<span class="type">const</span> string&amp; line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vector&lt;string&gt; tokens;</span><br><span class="line">  common::Util::<span class="built_in">Split</span>(line, <span class="string">&quot;\3&quot;</span>, &amp;tokens);</span><br><span class="line">  <span class="keyword">if</span>( tokens.<span class="built_in">size</span>() != <span class="number">3</span> )<span class="comment">//如果没有被切分为3份，说明节分结果有问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//把切分结果填充到DocInfo对象中</span></span><br><span class="line">  DocInfo doc_info;</span><br><span class="line">  doc_info._doc_id = _forward_index.<span class="built_in">size</span>();</span><br><span class="line">  doc_info._title = tokens[<span class="number">0</span>];</span><br><span class="line">  doc_info._url = tokens[<span class="number">1</span>];</span><br><span class="line">  doc_info._content = tokens[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">  _forward_index.<span class="built_in">push_back</span>(<span class="built_in">move</span>(doc_info));<span class="comment">//转化为右值引用，移动语义复制赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index.<span class="built_in">back</span>();<span class="comment">//防止野指针问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建倒排索引"><a href="#创建倒排索引" class="headerlink" title="创建倒排索引"></a>创建倒排索引</h2><p>依次对标题与正文进行分词，建立统计词频的结构体，根据统计结果，填充<code>Weight</code>对象，其中成员<code>_weight</code>(权重)简单的设计了一个公式：权重 == 10 * 标题出现次数 + 正文出现次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//倒排是一个hash表</span></span><br><span class="line">  <span class="comment">//key是词（针对文档分词结果）</span></span><br><span class="line">  <span class="comment">//value是倒排拉链（包含若干个Weight对象）</span></span><br><span class="line">  <span class="comment">//每次遍历到一个文档，分析之后把信息更新到倒排结构中</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Index::BuildInverted</span><span class="params">(<span class="type">const</span> DocInfo&amp; doc_info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//0. 创建专门统计词频的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">WordCnt</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> _title_cnt;</span><br><span class="line">      <span class="type">int</span> _content_cnt;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">WordCnt</span>() </span><br><span class="line">          : _title_cnt(<span class="number">0</span>)</span><br><span class="line">          , _content_cnt(<span class="number">0</span>) </span><br><span class="line">      &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    unordered_map&lt;string, WordCnt&gt; word_cnt_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 对标题进行分词</span></span><br><span class="line">    vector&lt;string&gt; title_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.title, &amp;title_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="comment">//次数要考虑大小写问题，大小写应该都算成小写</span></span><br><span class="line">    <span class="keyword">for</span>(string&amp; word : title_token)</span><br><span class="line">    &#123;</span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">      ++word_cnt_map[word]._title_cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对正文分词</span></span><br><span class="line">    vector&lt;string&gt; content_token;</span><br><span class="line">    <span class="built_in">CutWord</span>(doc_info.content, &amp;content_token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 遍历分词结果，统计每个单词出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (string word : content_token) </span><br><span class="line">    &#123;</span><br><span class="line">       boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">       ++word_cnt_map[word]._content_cnt;                      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 根据统计结果，整个出Weight对象，把结果更新到倒排索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; word_pair : word_cnt_map)</span><br><span class="line">    &#123;</span><br><span class="line">      Weight weight;</span><br><span class="line">      weight._doc_id = doc_info.doc_id;</span><br><span class="line">      weight._weight = <span class="number">10</span> * word_pair.second._title_cnt + word_pair.second._content_cnt;</span><br><span class="line">      weight._word = word_pair.first;</span><br><span class="line"></span><br><span class="line">      vector&lt;Weight&gt;&amp; inverted_list = _inverted_index[word_pair.first];</span><br><span class="line">      inverted_list.<span class="built_in">push_back</span>(<span class="built_in">move</span>(weight));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Index::CutWord</span><span class="params">(<span class="type">const</span> string&amp; input, vector&lt;string&gt;* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    jieba.<span class="built_in">CutForSearch</span>(input, *output);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，整个索引模块建立完成，内存中即存在了正排索引结构和倒排索引结构，等待搜索模块去调用</p><h2 id="查询正排-倒排索引"><a href="#查询正排-倒排索引" class="headerlink" title="查询正排/倒排索引"></a>查询正排/倒排索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> DocInfo* <span class="title">Index::GetDocInfo</span><span class="params">(<span class="type">int64_t</span> doc_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( doc_id &lt; <span class="number">0</span> || doc_id &gt;= _forward_index.<span class="built_in">size</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;_forward_index[doc_id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> vector&lt;Weight&gt;* <span class="title">Index::GetInvertedList</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = _inverted_index.<span class="built_in">find</span>(key);</span><br><span class="line">  <span class="keyword">if</span>( it == _inverted_index.<span class="built_in">end</span>() )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Searcher</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//搜索过程中依赖索引，需要持有索引指针</span></span><br><span class="line">    Index* index;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Searcher</span>() </span><br><span class="line">        :<span class="built_in">index</span>(<span class="keyword">new</span> <span class="built_in">Index</span>())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> string&amp; input_path)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* results)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="function">string <span class="title">GenerateDesc</span><span class="params">(<span class="type">const</span> string&amp; content, <span class="type">const</span> string&amp; word)</span></span>;<span class="comment">//生成描述</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>在使用搜索模块时，创建<code>Searcher</code>对象，即<code>new</code>了一个Index对象，接着调用成员函数<code>Init</code>，它会调用Index的成员函数<code>Build</code>，来创建正排索引和倒排索引，在需要查询时，调用成员函数<code>Search</code>，完成查询过程，将结果写入string类对象<code>results</code>中</p><h2 id="搜索函数"><a href="#搜索函数" class="headerlink" title="搜索函数"></a>搜索函数</h2><p>搜索模块先对查询词进行分词，再根据分词结果去调用索引模块的查询正排，倒排成员函数，接着将查询结果按照权重降序排列，最后调用JSONCPP库函数来包装查询结果（同时调用相关函数来生成描述），序列化为字符串输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Searcher::Search</span><span class="params">(<span class="type">const</span> string&amp; query, string* output)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//1. [分词] 针对查询结果进行分词</span></span><br><span class="line">    vector&lt;string&gt; tokens;</span><br><span class="line">    index-&gt;<span class="built_in">CutWord</span>(query, &amp;tokens);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. [触发] 根据分词结果，查询倒排，把相关文档都获取到</span></span><br><span class="line">    vector&lt;Weight&gt; all_token_result;</span><br><span class="line">    <span class="keyword">for</span>(string word : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//做索引的时候，已经把其中的词统一转成小写了</span></span><br><span class="line">      <span class="comment">//查询到排的时候，也需要把查询词统一转成小写</span></span><br><span class="line">      boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span>* inverted_list = index-&gt;<span class="built_in">GetInvertedList</span>(word);</span><br><span class="line">      <span class="keyword">if</span>( inverted_list == <span class="literal">nullptr</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//说明该词在倒排索引中不存在，如果这个词比较生僻，</span></span><br><span class="line">        <span class="comment">//在所有文档中都没有出现过。此时得到的倒排拉链就是nullptr</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//tokens 包含多个结果，需要把多个结果合并到一起，才能进行统一排序</span></span><br><span class="line">      all_token_result.<span class="built_in">insert</span>(all_token_result.<span class="built_in">end</span>(), </span><br><span class="line">                              inverted_list-&gt;<span class="built_in">begin</span>(), inverted_list-&gt;<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. [排序] 把刚才查到的文档的倒排拉链合并到一起并按照权重进行降序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(all_token_result.<span class="built_in">begin</span>(), all_token_result.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> Weight&amp; w1, <span class="type">const</span> Weight&amp; w2)&#123;</span><br><span class="line">      <span class="comment">//实现降序排序 w1 &gt; w2</span></span><br><span class="line">      <span class="keyword">return</span> w1.weight &gt; w2.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. [包装结果] 把得到的这些倒排拉链中的文档id获取到，然后去查正排，</span></span><br><span class="line">    <span class="comment">//             再把doc_info中的内容构造成最终的预期格式(JSON)</span></span><br><span class="line">    <span class="comment">//使用JSONCPP库来实现</span></span><br><span class="line">    Json::Value results;<span class="comment">//包含若干个结果，每个结果就是一个JSON对象对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; weight : all_token_result)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//根据weight中的结果查询正排序</span></span><br><span class="line">      <span class="type">const</span> DocInfo* doc_info = index-&gt;<span class="built_in">GetDocInfo</span>(weight.doc_id);</span><br><span class="line">      <span class="comment">//把doc_info对象进一步包装成一个JSON对象</span></span><br><span class="line">      Json::Value result;</span><br><span class="line">      result[<span class="string">&quot;title&quot;</span>] = doc_info-&gt;title;</span><br><span class="line">      result[<span class="string">&quot;url&quot;</span>] = doc_info-&gt;url;</span><br><span class="line">      result[<span class="string">&quot;desc&quot;</span>] = <span class="built_in">GenerateDesc</span>(doc_info-&gt;content, weight.word);</span><br><span class="line">      results.<span class="built_in">append</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一步，把得到的results这个JSON对象序列化为字符串，写入output中</span></span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    *output = writer.<span class="built_in">write</span>(results);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，搜索模块就搭建好了，等待最终的服务器模块调用</p><h1 id="服务器模块"><a href="#服务器模块" class="headerlink" title="服务器模块"></a>服务器模块</h1><p>首先初始化Searcher对象，调用<code>Init</code>成员函数初始化索引结构，然后调用Server对象中的Get方法，接收网页端请求，分析参数调用查询函数，然就将结果返回给网页端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> httplib;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建Searcher对象</span></span><br><span class="line">    searcher::Searcher searcher;</span><br><span class="line">    <span class="type">bool</span> ret = searcher.<span class="built_in">Init</span>(<span class="string">&quot;../data/tmp/raw_input&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Searcher初始化失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server;</span><br><span class="line">    server.<span class="built_in">Get</span>(<span class="string">&quot;/searcher&quot;</span>, [&amp;searcher](<span class="type">const</span> Request&amp; req, Response&amp; resp)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!req.<span class="built_in">has_param</span>(<span class="string">&quot;query&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            resp.<span class="built_in">set_content</span>(<span class="string">&quot;请求参数错误&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string query = req.<span class="built_in">get_param_value</span>(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        cout  &lt;&lt; <span class="string">&quot;收到查询词：&quot;</span> &lt;&lt; query &lt;&lt; endl;</span><br><span class="line">        string results;</span><br><span class="line">        searcher.<span class="built_in">Search</span>(query, &amp;results);</span><br><span class="line">        resp.<span class="built_in">set_content</span>(results, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.<span class="built_in">set_base_dir</span>(<span class="string">&quot;./www&quot;</span>);</span><br><span class="line">    server.<span class="built_in">listen</span>(<span class="string">&quot;x.x.x.x&quot;</span>, [port]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个搜索引擎已经搭建完成，只需要运行起来即可</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了更方便的使用Boost库，于是想到实现一个基于Boost离线文档的搜索引擎，对离线的HTML文件进行分析，、并对查询词进行分词（借用第三方库），然后根据相关性（简陋的相关性公式）进行排序，最终将查询结果用JSON的数据格式进行组织打包，最终通过对外的http服务将查询结果返回&lt;/p&gt;</summary>
    
    
    
    <category term="小作品" scheme="http://zhaozhuolin.com/categories/%E5%B0%8F%E4%BD%9C%E5%93%81/"/>
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/tags/C/"/>
    
    <category term="后端" scheme="http://zhaozhuolin.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>特殊类设计</title>
    <link href="http://zhaozhuolin.com/2020/08/20200820.html"/>
    <id>http://zhaozhuolin.com/2020/08/20200820.html</id>
    <published>2020-08-20T06:14:00.000Z</published>
    <updated>2023-05-07T11:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只能在堆上创建对象的类"><a href="#只能在堆上创建对象的类" class="headerlink" title="只能在堆上创建对象的类"></a>只能在堆上创建对象的类</h1><ol><li>构造函数私有</li><li>提供一个静态的堆上创建对象的方法</li><li>防止拷贝（拷贝构造声明为私有且不实现，或者声明为delete）<span id="more"></span></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> HeapOnly* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapOnly;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HeapOnly</span>()</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp; H) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testHeaponly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HeapOnly* ptr = HeapOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只能在栈上创建对象的类"><a href="#只能在栈上创建对象的类" class="headerlink" title="只能在栈上创建对象的类"></a>只能在栈上创建对象的类</h1><ol><li>构造函数私有</li><li>提供一个静态的栈上创建对象的方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">StackOnly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">StackOnly</span>()&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testStackOnly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackOnly so = StackOnly::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：屏蔽new</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">StackOnly2</span>()</span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对象不能被拷贝的类"><a href="#对象不能被拷贝的类" class="headerlink" title="对象不能被拷贝的类"></a>对象不能被拷贝的类</h1><p>将拷贝构造与赋值运算符声明为delete函数或者声明为私有且不实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyBan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CopyBan</span>() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">CopyBan</span>(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">CopyBan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CopyBan&amp; cb) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="不能被继承的类"><a href="#不能被继承的类" class="headerlink" title="不能被继承的类"></a>不能被继承的类</h1><ol><li>父类构造声明为私有</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">NoSon</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>加上final关键字</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoSon</span> <span class="keyword">final</span></span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类只能创建一个对象，该模式可以保证该类中只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><ol><li>构造函数私有</li><li>提供一个静态的方法返回单例</li><li>声明一个静态的单例成员</li><li>拷贝构造和赋值声明为delete函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_single;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton _single;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line">Singleton Singleton::_single;</span><br></pre></td></tr></table></figure><p>特点：实现简单，多线程情境下效率高</p><p>缺陷：程序启动比较满，多个单例对象初始化的顺序无法控制</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><ol><li>构造函数私有</li><li>提供一个静态的方法返回单例，第一次调用创建对象，后续调用直接返回</li><li>声明一个静态指针，指针初始化为nullptr</li><li>拷贝构造和赋值声明为delete</li><li>保证线程安全（修改指针），双检查提高效率</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton2* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;<span class="comment">//双检查</span></span><br><span class="line">_mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (_ptr == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第一次调用， 创建对象</span></span><br><span class="line">_ptr = <span class="keyword">new</span> Singleton2;</span><br><span class="line">&#125;</span><br><span class="line">_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GC</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">GC</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_ptr)</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton2</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Singleton2</span>(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton2&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton2* _ptr;</span><br><span class="line"><span class="type">static</span> mutex _mtx;</span><br><span class="line"><span class="type">static</span> GC _gc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton2* Singleton2::_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton2::_mtx;</span><br><span class="line">Singleton2::GC Singleton2::_gc;</span><br></pre></td></tr></table></figure><p>特点：延迟加载，程序启动快，可以指定多个单例对象的初始化顺序</p><p>缺陷：实现较为复杂</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;只能在堆上创建对象的类&quot;&gt;&lt;a href=&quot;#只能在堆上创建对象的类&quot; class=&quot;headerlink&quot; title=&quot;只能在堆上创建对象的类&quot;&gt;&lt;/a&gt;只能在堆上创建对象的类&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;构造函数私有&lt;/li&gt;
&lt;li&gt;提供一个静态的堆上创建对象的方法&lt;/li&gt;
&lt;li&gt;防止拷贝（拷贝构造声明为私有且不实现，或者声明为delete）&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://zhaozhuolin.com/categories/C/"/>
    
    
    <category term="-C++ -类与对象" scheme="http://zhaozhuolin.com/tags/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
